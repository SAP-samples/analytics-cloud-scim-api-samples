{
	"info": {
		"_postman_id": "6df55cc7-31fc-4128-8924-4800f1fc848b",
		"name": "653-T-Uc-Utr-Oarrkie-Fcj-Es-Teams on Teams",
		"description": "Provided 'as is'\n================\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\nUser guide\n==========\n\nhttps://d.dam.sap.com/s/c/a/kv3cXuB\n\nBlog (for Q&A)\n==============\nhttps://blogs.sap.com/2021/05/28/sap-analytics-cloud-scim-api-best-practices-and-sample-scripts/\n\nAbout\n=====\n\nScript version 0.5\n\nSample scripts created by Matthew Shaw, SAP. <https://people.sap.com/matthew.shaw/#content:blogposts>",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "READ source team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200)  )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        \r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Team not found. We have to abort this file entry and move to the next\r",
							"        const team_in_current_file_row=pm.iterationData.get(\"file_source_team\");\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Team '+ team_in_current_file_row+' not found. Skipping this entry');\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request\r",
							"        postman.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (   schemas.includes('urn:ietf:params:scim:schemas:core:2.0:Group') );\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"            {\r",
							"                pm.expect(validschema);\r",
							"            }\r",
							"        );\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"        const team_in_current_file_row= pm.iterationData.get(\"file_source_team\");\r",
							"        \r",
							"        let source_team_index = array_of_teams.findIndex(element => element.teamname == team_in_current_file_row);\r",
							"        let source_team;\r",
							"\r",
							"        if (source_team_index<0) \r",
							"            {\r",
							"                source_team = {\"teamname\"  : team_in_current_file_row,\r",
							"                            \"displayname\": readbody.displayName,\r",
							"                            \"meta\"       : readbody.meta,\r",
							"                            \"members\"    : readbody.members,\r",
							"                            \"roles\"      : readbody.roles,\r",
							"                            \"users_chunk_size\" : 0,\r",
							"                            \"roles_chunk_size\" : 0,\r",
							"                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                array_of_teams.push(source_team);\r",
							"                source_team_index=array_of_teams.findIndex(element => element.teamname == source_team.teamname);\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                source_team = array_of_teams[source_team_index];\r",
							"            }\r",
							"        ;  // end team index\r",
							"\r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"        pm.variables.set(\"source_team_index\",source_team_index);\r",
							"\r",
							"        \r",
							"        if (!validschema)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schema version and it could corrupt your team. Aborting!');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"    }  // end response is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team '+pm.iterationData.get(\"file_source_team\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_source_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_source_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ target team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        \r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Team not found, we need to create it.\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false); // we have now authorised this session, albeit with a 404 not found!\r",
							"        const target_team_in_current_file_row=pm.iterationData.get(\"file_target_team\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Team not found. Creating new team '+ target_team_in_current_file_row);\r",
							"        pm.variables.set(\"currentteam\",target_team_in_current_file_row);\r",
							"        postman.setNextRequest('CREATE team');\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request\r",
							"        postman.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (   schemas.includes('urn:ietf:params:scim:schemas:core:2.0:Group') );\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"            {\r",
							"                pm.expect(validschema);\r",
							"            }\r",
							"        );\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"        const target_team_in_current_file_row= pm.iterationData.get(\"file_target_team\");\r",
							"        \r",
							"        let target_team_index = array_of_teams.findIndex(element => element.teamname == target_team_in_current_file_row);\r",
							"        let target_team;\r",
							"\r",
							"        if (target_team_index<0) \r",
							"            {\r",
							"                target_team = {\"teamname\"  : target_team_in_current_file_row,\r",
							"                            \"displayname\": readbody.displayName,\r",
							"                            \"meta\"       : readbody.meta,\r",
							"                            \"members\"    : readbody.members,\r",
							"                            \"roles\"      : readbody.roles,\r",
							"                            \"users_chunk_size\" : 0,\r",
							"                            \"roles_chunk_size\" : 0,\r",
							"                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                target_team.users_chunk_size= Math.round(((42-(42-21.85714))*210) - (readbody.members.length * 0.14));\r",
							"                if (target_team.users_chunk_size<1) { target_team.users_chunk_size = 1};\r",
							"                if ( readbody.members.length > 0)\r",
							"                {\r",
							"                    target_team.roles_chunk_size= Math.round((210/(readbody.members.length*46/210))*10);  //210 is the target duration in seconds, 46 is the average rate of users/role/second\r",
							"                    if (target_team.roles_chunk_size<1) { target_team.roles_chunk_size = 1};\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    target_team.roles_chunk_size= 50;\r",
							"                };\r",
							"                array_of_teams.push(target_team);\r",
							"                target_team_index=array_of_teams.findIndex(element => element.teamname == target_team.teamname);\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                target_team = array_of_teams[target_team_index];\r",
							"            }\r",
							"        ;  // end team index\r",
							"\r",
							"        const source_team_index = pm.variables.get(\"source_team_index\");\r",
							"        source_team=array_of_teams[source_team_index];\r",
							"        \r",
							"        \r",
							"        let users_waiting_to_be_added_in_this_batch    = target_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"        let users_waiting_to_be_removed_in_this_batch  = target_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"        let roles_waiting_to_be_added_in_this_batch    = target_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"        let roles_waiting_to_be_removed_in_this_batch  = target_team.arrayofroles_waiting_to_be_removed_in_this_batch; \r",
							"        \r",
							"        if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"        if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"        if (!roles_waiting_to_be_added_in_this_batch)   { roles_waiting_to_be_added_in_this_batch = [] };\r",
							"        if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"        if (pm.iterationData.get(\"file_users_action\") === \"add\")\r",
							"        {\r",
							"            const users_to_add_from_source_team = source_team.members;\r",
							"            users_to_add_from_source_team.forEach( myfunction_add_user_from_source_team_to_batch );\r",
							"\r",
							"            function myfunction_add_user_from_source_team_to_batch(value)\r",
							"            {\r",
							"\r",
							"                if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === value.value) )  // user_found_in_add_list\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already added to add list. No action needed (UA1)');\r",
							"                }\r",
							"                else if (users_waiting_to_be_removed_in_this_batch.find(element => element.value === value.value))  // user_found_in_remove_list\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+' User '+value.value+' found in remove list, will remove user from remove list (UA2)');\r",
							"                    const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value == value.value);\r",
							"                    users_waiting_to_be_removed_in_this_batch.splice(userindex,1)\r",
							"                }\r",
							"                else if ( target_team.members.find(element => element.value === value.value) )  // user_found_in_existing_team_membership\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already a member of team. Taking no action (UA3)');\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' being added to team ' +target_team.teamname+ ' (UA4)');\r",
							"                    users_waiting_to_be_added_in_this_batch.push(value);\r",
							"                }; // end if \r",
							"            };  // end function\r",
							"        }  // end if action is addusers\r",
							"        else if (pm.iterationData.get(\"file_users_action\") === \"remove\")\r",
							"        {\r",
							"            const users_to_remove_from_source_team = source_team.members;\r",
							"            users_to_remove_from_source_team.forEach( myfunction_remove_user_from_source_team_from_batch );\r",
							"\r",
							"            function myfunction_remove_user_from_source_team_from_batch(value)\r",
							"            {   // avoid adding any console logging in this function as it will slow the script execution considerably! \r",
							"\r",
							"                if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === value.value) ) // user_found_in_remove_list \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already in remove list. No action needed (UR1)');\r",
							"                }\r",
							"                else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === value.value) )  // user_found_in_add_list\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already will be removed from add list (UR2)');\r",
							"                    const userindex = users_waiting_to_be_added_in_this_batch.findIndex(element => element.value == value.value);\r",
							"                    users_waiting_to_be_added_in_this_batch.splice(userindex,1);\r",
							"                }\r",
							"                else if ( target_team.members.find(element => element.value === value.value) ) // user_found_in_existing_team_membership\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' added to the remove list (UR3)');\r",
							"                    users_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' not found. Cannot remove user! (UR4)');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        }  // end if action is remove users\r",
							"        else if (pm.iterationData.get(\"file_users_action\") === \"replace\")\r",
							"        {\r",
							"            //\r",
							"            users_waiting_to_be_added_in_this_batch = [];\r",
							"            users_waiting_to_be_removed_in_this_batch = [];\r",
							"            const users_to_set_for_this_source_team = source_team.members;\r",
							"\r",
							"            users_to_set_for_this_source_team.forEach( myfunction_add_users_from_set_list_to_add_list );\r",
							"            function myfunction_add_users_from_set_list_to_add_list(value)\r",
							"            {  \r",
							"                if ( target_team.members.find(element => element.value === value.value) ) \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (US1/US3)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' needs to be added to team (US2)');\r",
							"                    users_waiting_to_be_added_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"            target_team.members.forEach( myfunction_add_users_from_existing_team_to_remove_list );\r",
							"            function myfunction_add_users_from_existing_team_to_remove_list(value)\r",
							"            {   \r",
							"                if ( users_to_set_for_this_source_team.find(element => element.value === value.value) ) \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (US3/US1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' removed (US4)');\r",
							"                    users_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"        }  // if action set\r",
							"        else if (pm.iterationData.get(\"file_users_action\") === \"keep\")\r",
							"        {\r",
							"            // nothing to do\r",
							"        }\r",
							"        else if (pm.iterationData.get(\"file_users_action\") === \"intersect\")\r",
							"        {\r",
							"            users_waiting_to_be_added_in_this_batch = [];\r",
							"            users_waiting_to_be_removed_in_this_batch = [];\r",
							"            const users_to_intersect_for_this_source_team = source_team.members;\r",
							"\r",
							"            target_team.members.forEach( myfunction_add_users_from_existing_team_to_remove_list );\r",
							"            function myfunction_add_users_from_existing_team_to_remove_list(value)\r",
							"            {   \r",
							"                if ( users_to_intersect_for_this_source_team.find(element => element.value === value.value) ) \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (US3/US1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' removed (US4)');\r",
							"                    users_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"        }\r",
							"        else if (pm.iterationData.get(\"file_users_action\") === \"exclude\")\r",
							"        {\r",
							"            users_waiting_to_be_added_in_this_batch = [];\r",
							"            users_waiting_to_be_removed_in_this_batch = [];\r",
							"            const users_to_exclude_for_this_source_team = source_team.members;\r",
							"\r",
							"            users_to_exclude_for_this_source_team.forEach( myfunction_add_users_from_set_list_to_add_list );\r",
							"            function myfunction_add_users_from_set_list_to_add_list(value)\r",
							"            {  \r",
							"                if ( target_team.members.find(element => element.value === value.value) ) \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (US1/US3)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' needs to be added to team (US2)');\r",
							"                    users_waiting_to_be_added_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"            target_team.members.forEach( myfunction_add_users_from_existing_team_to_remove_list );\r",
							"            function myfunction_add_users_from_existing_team_to_remove_list(value)\r",
							"            {   \r",
							"                if ( users_to_exclude_for_this_source_team.find(element => element.value === value.value) ) \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (US3/US1)');\r",
							"                    users_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' removed (US4)');\r",
							"                    \r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid user action (supported actions: add, remove, replace, keep, intersect, exclude): '+ pm.iterationData.get(\"file_users_action\"));\r",
							"        } // end if action\r",
							"\r",
							"\r",
							"\r",
							"        if (pm.iterationData.get(\"file_roles_action\") === \"add\")\r",
							"        {\r",
							"            const roles_to_add_for_this_source_team = source_team.roles;\r",
							"\r",
							"            roles_to_add_for_this_source_team.forEach( myfunction_add_role_from_source_team_to_batch );\r",
							"\r",
							"            function myfunction_add_role_from_source_team_to_batch(value)\r",
							"            {\r",
							"                if ( roles_waiting_to_be_added_in_this_batch.find(element => element === value) )  // role_found_in_add_list\r",
							"                {\r",
							"                //    console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value+' already added to add list. No action needed (RA1)')\r",
							"                }\r",
							"                else if (roles_waiting_to_be_removed_in_this_batch.find(element => element === value))  // role_found_in_remove_list\r",
							"                {\r",
							"                //    console.log(pm.info.requestName+' '+pm.info.eventName+' Role '+value+' found in remove list, will remove role from remove list (RA2)');\r",
							"                    const roleindex = roles_waiting_to_be_removed_in_this_batch.findIndex(element => element == value);\r",
							"                    roles_waiting_to_be_removed_in_this_batch.splice(roleindex,1)\r",
							"                }\r",
							"                else if ( target_team.roles.find(element => element === value) )  // team_found_as_existing_role_membership\r",
							"                {\r",
							"                //    console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of role '+value+'. Taking no action (RA3)');\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                //    console.log(pm.info.requestName+' '+pm.info.eventName+': Team ' +target_team.teamname+ ' being added to Role '+value+' (RA4)');\r",
							"                    roles_waiting_to_be_added_in_this_batch.push(value);\r",
							"                }; // end if \r",
							"            };  // end function\r",
							"        }  // end if action is add roles\r",
							"        else if (pm.iterationData.get(\"file_roles_action\") === \"remove\")\r",
							"        {\r",
							"            //\r",
							"            const roles_to_remove_for_this_source_team = source_team.roles;\r",
							"            roles_to_remove_for_this_source_team.forEach( myfunction_remove_role_from_source_team_from_batch );\r",
							"\r",
							"            function myfunction_remove_role_from_source_team_from_batch(value)\r",
							"            {   // avoid adding any console logging in this function as it will slow the script execution considerably! \r",
							"\r",
							"                if ( roles_waiting_to_be_removed_in_this_batch.find(element => element === value) ) // role_found_in_remove_list \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value' already in remove list. No action needed (RR1)');\r",
							"                }\r",
							"                else if ( roles_waiting_to_be_added_in_this_batch.find(element => element === value) )  // role_found_in_add_list\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value+' already will be removed from add list (RR2)');\r",
							"                    const roleindex = roles_waiting_to_be_added_in_this_batch.findIndex(element => element == value);\r",
							"                    roles_waiting_to_be_added_in_this_batch.splice(roleindex,1);\r",
							"                }\r",
							"                else if ( target_team.roles.find(element => element === value) ) // role_found_in_existing_team_membership\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': role '+value.value+' added to the remove list (R3)');\r",
							"                    roles_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value.value+' not found. Cannot remove role! (R4)');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        }  // end if action is remove roles\r",
							"        else if (pm.iterationData.get(\"file_roles_action\") === \"replace\")\r",
							"        {\r",
							"            roles_waiting_to_be_added_in_this_batch = [];\r",
							"            roles_waiting_to_be_removed_in_this_batch = [];\r",
							"            const roles_to_set_for_this_source_team = source_team.roles;\r",
							"\r",
							"            roles_to_set_for_this_source_team.forEach( myfunction_add_roles_from_set_list_to_add_list );\r",
							"            function myfunction_add_roles_from_set_list_to_add_list(value)\r",
							"            {  \r",
							"                if ( target_team.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of role '+value.value+' (RS1/RS3)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team needs to be added as a member of role '+value.value+' (RS2)');\r",
							"                    roles_waiting_to_be_added_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"            target_team.roles.forEach( myfunction_add_roles_from_existing_team_to_remove_list );\r",
							"            function myfunction_add_roles_from_existing_team_to_remove_list(value)\r",
							"            {   \r",
							"                if ( roles_to_set_for_this_source_team.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of Role '+value+' (RS3/RS1)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value+' removed (RS4)');\r",
							"                    roles_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"        }  // if action \r",
							"        else if (pm.iterationData.get(\"file_roles_action\") === \"keep\")\r",
							"        {\r",
							"            // nothing to do\r",
							"        }\r",
							"        else if (pm.iterationData.get(\"file_roles_action\") === \"intersect\")\r",
							"        {\r",
							"            roles_waiting_to_be_added_in_this_batch = [];\r",
							"            roles_waiting_to_be_removed_in_this_batch = [];\r",
							"            const roles_to_intersect_for_this_source_team = source_team.roles;\r",
							"\r",
							"            target_team.roles.forEach( myfunction_add_roles_from_existing_team_to_remove_list );\r",
							"            function myfunction_add_roles_from_existing_team_to_remove_list(value)\r",
							"            {   \r",
							"                if ( roles_to_intersect_for_this_source_team.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of Role '+value+' (RS3/RS1)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value+' removed (RS4)');\r",
							"                    roles_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"        }\r",
							"        else if (pm.iterationData.get(\"file_roles_action\") === \"exclude\")\r",
							"        {\r",
							"            roles_waiting_to_be_added_in_this_batch = [];\r",
							"            roles_waiting_to_be_removed_in_this_batch = [];\r",
							"            const roles_to_exclude_for_this_source_team = source_team.roles;\r",
							"\r",
							"            roles_to_exclude_for_this_source_team.forEach( myfunction_add_roles_from_set_list_to_add_list );\r",
							"            function myfunction_add_roles_from_set_list_to_add_list(value)\r",
							"            {  \r",
							"                if ( target_team.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of role '+value.value+' (RS1/RS3)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team needs to be added as a member of role '+value.value+' (RS2)');\r",
							"                    roles_waiting_to_be_added_in_this_batch.push(value);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"            target_team.roles.forEach( myfunction_add_roles_from_existing_team_to_remove_list );\r",
							"            function myfunction_add_roles_from_existing_team_to_remove_list(value)\r",
							"            {   \r",
							"                if ( roles_to_exclude_for_this_source_team.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of Role '+value+' (RS3/RS1)');\r",
							"                    roles_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value+' removed (RS4)');\r",
							"                    \r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid role action (supported actions: add, remove, replace, keep, intersect, exclude): '+ pm.iterationData.get(\"file_roles_action\"));\r",
							"        } // end if action\r",
							"\r",
							"\r",
							"        target_team.arrayofusers_waiting_to_be_added_in_this_batch  =users_waiting_to_be_added_in_this_batch;\r",
							"        target_team.arrayofusers_waiting_to_be_removed_in_this_batch=users_waiting_to_be_removed_in_this_batch;\r",
							"        target_team.arrayofroles_waiting_to_be_added_in_this_batch  =roles_waiting_to_be_added_in_this_batch;\r",
							"        target_team.arrayofroles_waiting_to_be_removed_in_this_batch=roles_waiting_to_be_removed_in_this_batch;\r",
							"        array_of_teams[target_team_index]=target_team;\r",
							"\r",
							"\r",
							"        // we can avoid any need to update the target team if no changes are necessary\r",
							"        let need_target_team = ( (target_team.arrayofusers_waiting_to_be_added_in_this_batch.length  > 0)\r",
							"                            || (target_team.arrayofusers_waiting_to_be_removed_in_this_batch.length >0)\r",
							"                            || (target_team.arrayofroles_waiting_to_be_added_in_this_batch.length   >0)\r",
							"                            || (target_team.arrayofroles_waiting_to_be_removed_in_this_batch.length >0) );\r",
							"        if (!need_target_team) \r",
							"        {\r",
							"            array_of_teams.splice(target_team_index,1)\r",
							"        };\r",
							"        \r",
							"        array_of_teams.splice(source_team_index,1);\r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"\r",
							"        if ( need_target_team )\r",
							"        {\r",
							"            pm.variables.set(\"currentteam\", target_team.teamname);\r",
							"            postman.setNextRequest();\r",
							"        }\r",
							"        else \r",
							"        {\r",
							"            // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"            // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team already correct. No update needed');\r",
							"            postman.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"        \r",
							"        if (!validschema)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schema version and it could corrupt your team. Aborting!');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"    }  // end response is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team '+pm.iterationData.get(\"file_target_team\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_target_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_target_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const currentteam = pm.variables.get(\"currentteam\");\r",
							"//console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+currentteam);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const array_of_teams  = pm.variables.get(\"array_of_teams\");\r",
							"    const this_team_index = array_of_teams.findIndex(element => element.teamname == currentteam);\r",
							"    const this_team       = array_of_teams[this_team_index];\r",
							"    const displayname     = this_team.displayname;\r",
							"    const meta            = this_team.meta;\r",
							"    const users_chucksize       = this_team.users_chunk_size;\r",
							"    const roles_chunksize       = this_team.roles_chunk_size;\r",
							"    const users_in_this_team_update =this_team.members;\r",
							"    const roles_in_this_team_update =this_team.roles;\r",
							"    const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"    const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"    const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"    const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"\r",
							"    if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_added_in_this_batch)   { roles_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"    \r",
							"\r",
							"    let number_of_users_that_can_change_in_this_chunk;\r",
							"    if ((users_waiting_to_be_added_in_this_batch.length+users_waiting_to_be_removed_in_this_batch.length)>=users_chucksize)\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_chucksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=(users_waiting_to_be_added_in_this_batch.length + users_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"\r",
							"    let number_of_users_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_users_that_can_be_added_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_added_in_this_chunk =0;\r",
							"\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length > number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (users_waiting_to_be_removed_in_this_batch.length<=number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk-number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (users_waiting_to_be_added_in_this_batch.length<number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=users_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    const max_users_in_single_PUT_request = 32767;\r",
							"    if ((this_team.members.length+number_of_users_that_can_be_added_in_this_chunk) > max_users_in_single_PUT_request)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Maximum number of users reached '+max_users_in_single_PUT_request);\r",
							"        number_of_users_that_can_be_added_in_this_chunk=max_users_in_single_PUT_request-this_team.members.length\r",
							"    }\r",
							"\r",
							"\r",
							"\r",
							"    let number_of_roles_that_can_change_in_this_chunk;\r",
							"    if ((roles_waiting_to_be_added_in_this_batch.length+roles_waiting_to_be_removed_in_this_batch.length)>=roles_chunksize)\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=roles_chunksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=(roles_waiting_to_be_added_in_this_batch.length + roles_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"    \r",
							"    if (roles_waiting_to_be_removed_in_this_batch.length > number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_removed_in_this_batch.length<=number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=roles_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk-number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_added_in_this_batch.length<number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=roles_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    if (number_of_users_that_can_be_removed_in_this_chunk > 0)\r",
							"    {\r",
							"        // if we can remove users, then we should remove all users before adding or removing any roles\r",
							"        // we have disabled the ability for any roles to be added or removed under this condition\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        // but if we have any roles to add or remove then we must also prevent any new user from being added in this chunk\r",
							"        // since it is possible users will be removed and added within the same chunk, hence...\r",
							"        if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"        {\r",
							"            // we have now disabled the ability for new users to be added when users can be removed AND when there are role changes\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"        }\r",
							"    }\r",
							"    else if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"    {\r",
							"            // this is when there are users that can be added and there are changed needed to roles.\r",
							"            // in this condition we need to prevent new users from being added until all the role changes have been made.\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    };\r",
							"\r",
							"    let number_of_users_removed = 0;\r",
							"    let number_of_users_added   = 0;\r",
							"\r",
							"    const users_removed_in_this_chunk = [];\r",
							"    while (number_of_users_removed < number_of_users_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_user=users_waiting_to_be_removed_in_this_batch.shift();\r",
							"        users_removed_in_this_chunk.push(removing_user);\r",
							"        \r",
							"        let removing_user_index = users_in_this_team_update.findIndex(element => element.value == removing_user.value);\r",
							"        users_in_this_team_update.splice(removing_user_index,1);\r",
							"        number_of_users_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofusers_removed_in_this_chunk\",users_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_users_added < number_of_users_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        users_in_this_team_update.push(users_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_users_added++;\r",
							"    };\r",
							"\r",
							"\r",
							"    let number_of_roles_removed = 0;\r",
							"    let number_of_roles_added   = 0;\r",
							"\r",
							"    const roles_removed_in_this_chunk = [];\r",
							"    while (number_of_roles_removed < number_of_roles_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_role=roles_waiting_to_be_removed_in_this_batch.shift();\r",
							"        roles_removed_in_this_chunk.push(removing_role);\r",
							"        \r",
							"        let removing_role_index = roles_in_this_team_update.findIndex(element => element == removing_role);\r",
							"        roles_in_this_team_update.splice(removing_role_index,1);\r",
							"        number_of_roles_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofroles_removed_in_this_chunk\",roles_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_roles_added < number_of_roles_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        roles_in_this_team_update.push(roles_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_roles_added++;\r",
							"    };\r",
							"\r",
							"// don't need these lines\r",
							"    //pm.variables.set(\"arrayofusers_waiting_to_be_added_in_this_batch\",users_waiting_to_be_added_in_this_batch);\r",
							"    //pm.variables.set(\"arrayofusers_waiting_to_be_removed_in_this_batch\",users_waiting_to_be_removed_in_this_batch);\r",
							"\r",
							"    const number_of_users_actually_changed = number_of_users_that_can_be_added_in_this_chunk + number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    const number_of_roles_actually_changed = number_of_roles_that_can_be_added_in_this_chunk + number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    pm.variables.set(\"number_of_users_in_this_chunk\",number_of_users_actually_changed);\r",
							"    pm.variables.set(\"number_of_roles_in_this_chunk\",number_of_roles_actually_changed);\r",
							"    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"    pm.variables.set(\"displayname\",displayname);\r",
							"    pm.variables.set(\"meta\",   JSON.stringify(meta));\r",
							"    pm.variables.set(\"members\",JSON.stringify(users_in_this_team_update));\r",
							"    pm.variables.set(\"roles\",  JSON.stringify(roles_in_this_team_update));\r",
							"    pm.variables.set(\"expected_user_count\",users_in_this_team_update.length);\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName\r",
							"                +': Updating team: '+currentteam+': adding '+number_of_users_that_can_be_added_in_this_chunk\r",
							"                +' users, removing '+number_of_users_that_can_be_removed_in_this_chunk\r",
							"                +' users, adding '+number_of_roles_that_can_be_added_in_this_chunk\r",
							"                +' roles, removing '+number_of_roles_that_can_be_removed_in_this_chunk\r",
							"                +' roles');\r",
							"\r",
							"}  // end if errors"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE team\", () => {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"});\r",
							"\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody            = JSON.parse(responseBody);\r",
							"        const expected_user_count = pm.variables.get(\"expected_user_count\");\r",
							"        const actual_user_count   = readbody.members.length;\r",
							"        const previouserrors=pm.variables.get(\"ContinuousErrors\");  // errors holds the number of previous errors before this sucessful event. We need to know this so not to adjust the chunk size.\r",
							"                                                            // adjusting the chunk size after a previous error could be because the previous error was resolved by a repeated call. \r",
							"                                                            // and that repeated call could had taken a fraction of the normal processing time because it had already partly processed it beforehand.\r",
							"        \r",
							"        if (expected_user_count == actual_user_count)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in team as expected');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in the team, however '+ expected_user_count+' where expected');\r",
							"        };\r",
							"\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname == pm.variables.get(\"currentteam\"));\r",
							"        const this_team = array_of_teams[this_team_index];\r",
							"        \r",
							"        const number_of_user_changes_in_the_last_update=pm.variables.get(\"number_of_users_in_this_chunk\");\r",
							"        if (number_of_user_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const users_per_second = Math.round((number_of_user_changes_in_the_last_update/(pm.response.responseTime/1000))*10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+users_per_second+' users/second');\r",
							"\r",
							"            const users_in_last_request= JSON.parse(pm.variables.get(\"members\"));\r",
							"            users_in_last_request.forEach( myfunction_find_missing_users );\r",
							"            function myfunction_find_missing_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (S3/S1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' was not found in the team, but was expected to be present');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const users_that_should_had_been_removed =pm.variables.get(\"arrayofusers_removed_in_this_chunk\");\r",
							"            users_that_should_had_been_removed.forEach( myfunction_find_not_removed_users );\r",
							"            function myfunction_find_not_removed_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' should had been removed, but was not');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"        \r",
							"        const number_of_roles_changes_in_the_last_update=pm.variables.get(\"number_of_roles_in_this_chunk\");\r",
							"        if (number_of_roles_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const roles_per_second = Math.round((number_of_roles_changes_in_the_last_update/(pm.response.responseTime/1000))*100)/100;\r",
							"            const users_per_role_per_second = Math.round( ((this_team.members.length*number_of_roles_changes_in_the_last_update)/(pm.response.responseTime/1000)) *10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+roles_per_second+' roles/second, '+users_per_role_per_second+' users/role/second');\r",
							"\r",
							"            const roles_in_last_request= JSON.parse(pm.variables.get(\"roles\"));\r",
							"            roles_in_last_request.forEach( myfunction_find_missing_roles );\r",
							"            function myfunction_find_missing_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team, already a member of '+value+' role (R3/R1)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Team not a member of role '+value+' but was expected to be');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const roles_that_should_had_been_removed =pm.variables.get(\"arrayofroles_removed_in_this_chunk\");\r",
							"            roles_that_should_had_been_removed.forEach( myfunction_find_not_removed_roles );\r",
							"            function myfunction_find_not_removed_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Role '+value.value+' should no longer contain this team, but does');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"\r",
							"        const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"        const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"        const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"        const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"        if( (users_waiting_to_be_added_in_this_batch.length\r",
							"            +users_waiting_to_be_removed_in_this_batch.length\r",
							"            +roles_waiting_to_be_added_in_this_batch.length\r",
							"            +roles_waiting_to_be_removed_in_this_batch.length) >0 ) \r",
							"        {\r",
							"            this_team.members=readbody.members;  // we need to reload the members that are actually in the team into our members list so the current list is accurate\r",
							"            this_team.roles  =readbody.roles;\r",
							"\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' users: '+this_team.members.length+' (yet to add: '+users_waiting_to_be_added_in_this_batch.length+' & remove: '+users_waiting_to_be_removed_in_this_batch.length+') member of: '+this_team.roles.length+' roles (yet to be added to: '+roles_waiting_to_be_added_in_this_batch.length+' & removed from: '+roles_waiting_to_be_removed_in_this_batch.length+')');\r",
							"            // need to test if chucksize is too large, if so we need to reduce it\r",
							"\r",
							"            if (number_of_user_changes_in_the_last_update>0) \r",
							"            {\r",
							"                // then our last update was for adding or removing users, so we need to change the chunk size accordingly\r",
							"                // however, there is a condition where we are removing users to allow updates to roles to be made, before we then start adding users in.\r",
							"                // it means that a chunk update may not have been 'full' of users, this in turn means the last update could had been very quick and we need to\r",
							"                // only adjust the chunk size when the last update was 'full'.\r",
							"\r",
							"                const max_users_in_single_PUT_request = 32767;\r",
							"                if (readbody.members.length>=max_users_in_single_PUT_request)\r",
							"                {\r",
							"                    postman.setNextRequest(null);\r",
							"                }\r",
							"                else if ( (number_of_user_changes_in_the_last_update == this_team.users_chunk_size) && (previouserrors ===0 ) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.users_chunk_size;\r",
							"                    if (pm.response.responseTime>270000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.6);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime>210000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.8);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 2);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<120000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 1.75);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 2 mins. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.users_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                    postman.setNextRequest(pm.info.requestName); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    postman.setNextRequest(pm.info.requestName); \r",
							"                };\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // our last update was for adding or removing roles, so we need to change the chunk size accordingly \r",
							"                // however we may only remove roles before adding them, so we need to check the chunk was 'full'\r",
							"                if ( (number_of_roles_changes_in_the_last_update == this_team.roles_chunk_size) && (previouserrors === 0) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.roles_chunk_size;\r",
							"                    if ( (pm.response.responseTime>270000)  && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if ( (pm.response.responseTime>210000) && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<20000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 20 secs. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<80000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min 30 secs. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.roles_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                };\r",
							"                postman.setNextRequest(pm.info.requestName); \r",
							"            };\r",
							"        }\r",
							"        else // the current team has been processed\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' update complete it has '+readbody.members.length+' users and is a member of '+readbody.roles.length+' roles');\r",
							"            // so we should now remove the team from the teams array\r",
							"            array_of_teams.splice(this_team_index,1);\r",
							"            pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"            const teams_to_update = array_of_teams.length;\r",
							"            if ( teams_to_update > 0 )\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+array_of_teams[0].teamname);\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[0].teamname);\r",
							"                postman.setNextRequest(pm.info.requestName);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Team updated');\r",
							"                postman.setNextRequest(null);\r",
							"            };\r",
							"\r",
							"        };  // end waiting to be added/removed\r",
							"\r",
							"        \r",
							"    }  // end reponse is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }  // end if else\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],\r\n    \"id\": \"{{currentteam}}\",\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"meta\": {{meta}},\r\n    \"members\": {{members}},\r\n    \"roles\": {{roles}}\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_target_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_target_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating team '+pm.variables.get(\"currentteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 201)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated so skip to next user\r",
							"        postman.setNextRequest('READ target team');\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=4;  // maxerrors should be at least 3 to allow for recovery of invalid access tokens and csrf tokens (each consuming 1 error)\r",
							"                            // it means a setting of 3 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // thus a setting of 4 is recommended to allow at least 1 re-attempted call in such a condition\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        if (pm.response.code === 400)\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': 400 errors can be caused because the Team folder can not be created because it already exists. Delete the team folder first. Login to SAP Analytics Cloud and select Menu-Files-System, then delete the folder matching the team name');\r",
							"        }\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\": [\r\n    \"urn:ietf:params:scim:schemas:core:2.0:Group\"\r\n  ],\r\n  \"id\": \"{{currentteam}}\",\r\n  \"displayName\": \"{{currentteam}} with Team Folder\"\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(responseBody);\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        postman.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ responseBody);\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=3;  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    postman.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}