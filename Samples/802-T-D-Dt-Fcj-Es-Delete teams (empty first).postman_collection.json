{
	"info": {
		"_postman_id": "a22cdc05-4050-41e0-9610-24ee4cfa6964",
		"name": "802-T-D-Dt-Fcj-Es-Delete teams (empty first)",
		"description": "Provided 'as is'\n================\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\nUser guide\n==========\n\nhttps://d.dam.sap.com/s/c/a/kv3cXuB\n\nBlog (for Q&A)\n==============\nhttps://blogs.sap.com/2021/05/28/sap-analytics-cloud-scim-api-best-practices-and-sample-scripts/\n\nAbout\n=====\n\nScript version 0.5\n\nSample scripts created by Matthew Shaw, SAP. <https://people.sap.com/matthew.shaw/#content:blogposts>",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "READ team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        \r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Team not found, we need to create it.\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false); // we have now authorised this session, albeit with a 404 not found!\r",
							"        const delete_team_in_current_file_row=pm.iterationData.get(\"file_delete_team\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Team '+ delete_team_in_current_file_row+' already deleted!');\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request\r",
							"        postman.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"\r",
							"        let array_of_teams = [];\r",
							"        const delete_team_in_current_file_row= pm.iterationData.get(\"file_delete_team\");\r",
							"        let delete_team;\r",
							"\r",
							"        delete_team = {\"teamname\"  : delete_team_in_current_file_row,\r",
							"                    \"displayname\": readbody.displayName,\r",
							"                    \"meta\"       : readbody.meta,\r",
							"                    \"members\"    : readbody.members,\r",
							"                    \"roles\"      : readbody.roles,\r",
							"                    \"users_chunk_size\" : 0,\r",
							"                    \"roles_chunk_size\" : 0,\r",
							"                    \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                    \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"        delete_team.users_chunk_size= Math.round(((42-(42-21.85714))*210) - (readbody.members.length * 0.14));\r",
							"        if (delete_team.users_chunk_size<1) { delete_team.users_chunk_size = 1};\r",
							"        if ( readbody.members.length > 0)\r",
							"        {\r",
							"            delete_team.roles_chunk_size= Math.round((210/(readbody.members.length*46/210))*10);  //210 is the target duration in seconds, 46 is the average rate of users/role/second\r",
							"            if (delete_team.roles_chunk_size<1) { delete_team.roles_chunk_size = 1};\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            delete_team.roles_chunk_size= 50;\r",
							"        };\r",
							"        array_of_teams.push(delete_team);\r",
							"    \r",
							"        \r",
							"\r",
							"    //    let users_waiting_to_be_removed_in_this_batch  = delete_team.members;\r",
							"    //    let roles_waiting_to_be_removed_in_this_batch  = delete_team.roles; \r",
							"   //     if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"   //     if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							" //       delete_team.arrayofusers_waiting_to_be_removed_in_this_batch=users_waiting_to_be_removed_in_this_batch;\r",
							" //       delete_team.arrayofroles_waiting_to_be_removed_in_this_batch=roles_waiting_to_be_removed_in_this_batch;\r",
							"        delete_team.arrayofusers_waiting_to_be_removed_in_this_batch=delete_team.members;\r",
							"        delete_team.arrayofroles_waiting_to_be_removed_in_this_batch=delete_team.roles;\r",
							"    //    array_of_teams[0]=delete_team;\r",
							"\r",
							"\r",
							"        // we can avoid any need to update the target team if no changes are necessary\r",
							"        let need_to_empty_team = ( (delete_team.arrayofusers_waiting_to_be_removed_in_this_batch.length >0)\r",
							"                                || (delete_team.arrayofroles_waiting_to_be_removed_in_this_batch.length >0) );\r",
							"\r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"\r",
							"        if ( need_to_empty_team )\r",
							"        {\r",
							"            pm.variables.set(\"currentteam\", delete_team.teamname);\r",
							"            postman.setNextRequest();\r",
							"        }\r",
							"        else \r",
							"        {\r",
							"            // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"            // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team already empty');\r",
							"            postman.setNextRequest(\"DELETE team\");\r",
							"        };\r",
							"    }  // end response is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team '+pm.iterationData.get(\"file_delete_team\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_delete_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_delete_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "EMPTY team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const currentteam = pm.variables.get(\"currentteam\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Emptying team '+currentteam);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const array_of_teams  = pm.variables.get(\"array_of_teams\");\r",
							"    const this_team_index = array_of_teams.findIndex(element => element.teamname == currentteam);\r",
							"    const this_team       = array_of_teams[this_team_index];\r",
							"    const displayname     = this_team.displayname;\r",
							"    const meta            = this_team.meta;\r",
							"    const users_chucksize       = this_team.users_chunk_size;\r",
							"    const roles_chunksize       = this_team.roles_chunk_size;\r",
							"    const users_in_this_team_update =this_team.members;\r",
							"    const roles_in_this_team_update =this_team.roles;\r",
							"    const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"    const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"\r",
							"    if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"    \r",
							"\r",
							"    let number_of_users_that_can_change_in_this_chunk;\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length>=users_chucksize)\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_chucksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"    };\r",
							"\r",
							"    let number_of_users_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_removed_in_this_chunk =0;\r",
							"\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length > number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"    }\r",
							"    else \r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"    }\r",
							"    \r",
							"\r",
							"    let number_of_roles_that_can_change_in_this_chunk;\r",
							"    if (roles_waiting_to_be_removed_in_this_batch.length>=roles_chunksize)\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=roles_chunksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=(roles_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"    \r",
							"    if (roles_waiting_to_be_removed_in_this_batch.length > number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"    }\r",
							"    else \r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=roles_waiting_to_be_removed_in_this_batch.length;\r",
							" \r",
							"    };\r",
							"\r",
							"    if (number_of_users_that_can_be_removed_in_this_chunk > 0)\r",
							"    {\r",
							"        // if we can remove users, then we should remove all users before adding or removing any roles\r",
							"        // we have disabled the ability for any roles to be added or removed under this condition\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        // but if we have any roles to add or remove then we must also prevent any new user from being added in this chunk\r",
							"        // since it is possible users will be removed and added within the same chunk, hence...\r",
							"    }\r",
							"    else if ( number_of_roles_that_can_change_in_this_chunk > 0 )\r",
							"    {\r",
							"            // this is when there are users that can be added and there are changed needed to roles.\r",
							"            // in this condition we need to prevent new users from being added until all the role changes have been made.\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    };\r",
							"\r",
							"    let number_of_users_removed = 0;\r",
							"  \r",
							"\r",
							"    const users_removed_in_this_chunk = [];\r",
							"    while (number_of_users_removed < number_of_users_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_user=users_waiting_to_be_removed_in_this_batch.shift();\r",
							"        users_removed_in_this_chunk.push(removing_user);\r",
							"        \r",
							"        let removing_user_index = users_in_this_team_update.findIndex(element => element.value == removing_user.value);\r",
							"        users_in_this_team_update.splice(removing_user_index,1);\r",
							"        number_of_users_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofusers_removed_in_this_chunk\",users_removed_in_this_chunk)\r",
							"\r",
							"    let number_of_roles_removed = 0;\r",
							"\r",
							"    const roles_removed_in_this_chunk = [];\r",
							"    while (number_of_roles_removed < number_of_roles_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_role=roles_waiting_to_be_removed_in_this_batch.shift();\r",
							"        roles_removed_in_this_chunk.push(removing_role);\r",
							"        \r",
							"        let removing_role_index = roles_in_this_team_update.findIndex(element => element == removing_role);\r",
							"        roles_in_this_team_update.splice(removing_role_index,1);\r",
							"        number_of_roles_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofroles_removed_in_this_chunk\",roles_removed_in_this_chunk);\r",
							"    pm.variables.set(\"arrayofusers_waiting_to_be_removed_in_this_batch\",users_waiting_to_be_removed_in_this_batch);\r",
							"\r",
							"    const number_of_users_actually_changed = number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    const number_of_roles_actually_changed = number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    pm.variables.set(\"number_of_users_in_this_chunk\",number_of_users_actually_changed);\r",
							"    pm.variables.set(\"number_of_roles_in_this_chunk\",number_of_roles_actually_changed);\r",
							"    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"    pm.variables.set(\"displayname\",displayname);\r",
							"    pm.variables.set(\"meta\",   JSON.stringify(meta));\r",
							"    pm.variables.set(\"members\",JSON.stringify(users_in_this_team_update));\r",
							"    pm.variables.set(\"roles\",  JSON.stringify(roles_in_this_team_update));\r",
							"    pm.variables.set(\"expected_user_count\",users_in_this_team_update.length);\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName\r",
							"                +': Updating team: '+currentteam+': removing '+number_of_users_that_can_be_removed_in_this_chunk\r",
							"                +' users, removing '+number_of_roles_that_can_be_removed_in_this_chunk\r",
							"                +' roles');\r",
							"\r",
							"}  // end if errors"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE team\", () => {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"});\r",
							"\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // we are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // we need to issue a GET call to obtain access. \r",
							"        // it is unlikely we'll get a 403 on this call, since the earlier 401 error would have first requested a new csrf-token, then on the second 401 error it would request\r",
							"        // a new access token. And because the 'recovery' variable is set to a GET call, when that GET call is issued, the session be authorised.\r",
							"        // And because 'NeedGetToBeAuthorised' is set to true, any post-processing in the GET call will be skipped and we'll come back to his call, when a re-submit of the call will be made,\r",
							"        // because 'ContinuousErrors' will be over 0.  Thus, its very unlikely we'll receive a 403 error, but we'll include it just in case!\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403    \r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        const readbody            = JSON.parse(responseBody);\r",
							"        const expected_user_count = pm.variables.get(\"expected_user_count\");\r",
							"        const actual_user_count   = readbody.members.length;\r",
							"        const previouserrors=pm.variables.get(\"ContinuousErrors\");  // errors holds the number of previous errors before this sucessful event. We need to know this so not to adjust the chunk size.\r",
							"                                                            // adjusting the chunk size after a previous error could be because the previous error was resolved by a repeated call. \r",
							"                                                            // and that repeated call could had taken a fraction of the normal processing time because it had already partly processed it beforehand.\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        \r",
							"        if (expected_user_count == actual_user_count)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in team as expected');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in the team, however '+ expected_user_count+' where expected');\r",
							"        };\r",
							"\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        const this_team = array_of_teams[0];\r",
							"        \r",
							"        const number_of_user_changes_in_the_last_update=pm.variables.get(\"number_of_users_in_this_chunk\");\r",
							"        if (number_of_user_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const users_per_second = Math.round((number_of_user_changes_in_the_last_update/(pm.response.responseTime/1000))*10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+users_per_second+' users/second');\r",
							"\r",
							"            const users_in_last_request= JSON.parse(pm.variables.get(\"members\"));\r",
							"            users_in_last_request.forEach( myfunction_find_missing_users );\r",
							"            function myfunction_find_missing_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (S3/S1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' was not found in the team, but was expected to be present');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const users_that_should_had_been_removed =pm.variables.get(\"arrayofusers_removed_in_this_chunk\");\r",
							"            users_that_should_had_been_removed.forEach( myfunction_find_not_removed_users );\r",
							"            function myfunction_find_not_removed_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' should had been removed, but was not');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"        \r",
							"        const number_of_roles_changes_in_the_last_update=pm.variables.get(\"number_of_roles_in_this_chunk\");\r",
							"        if (number_of_roles_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const roles_per_second = Math.round((number_of_roles_changes_in_the_last_update/(pm.response.responseTime/1000))*100)/100;\r",
							"            const users_per_role_per_second = Math.round( ((this_team.members.length*number_of_roles_changes_in_the_last_update)/(pm.response.responseTime/1000)) *10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+roles_per_second+' roles/second, '+users_per_role_per_second+' users/role/second');\r",
							"\r",
							"            const roles_in_last_request= JSON.parse(pm.variables.get(\"roles\"));\r",
							"            roles_in_last_request.forEach( myfunction_find_missing_roles );\r",
							"            function myfunction_find_missing_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team, already a member of '+value+' role (R3/R1)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Team not a member of role '+value+' but was expected to be');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const roles_that_should_had_been_removed =pm.variables.get(\"arrayofroles_removed_in_this_chunk\");\r",
							"            roles_that_should_had_been_removed.forEach( myfunction_find_not_removed_roles );\r",
							"            function myfunction_find_not_removed_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Role '+value.value+' should no longer contain this team, but does');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"\r",
							"        const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"        const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"        if( (users_waiting_to_be_removed_in_this_batch.length\r",
							"            +roles_waiting_to_be_removed_in_this_batch.length) >0 ) \r",
							"        {\r",
							"            this_team.members=readbody.members;  // we need to reload the members that are actually in the team into our members list so the current list is accurate\r",
							"            this_team.roles  =readbody.roles;\r",
							"\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' users: '+this_team.members.length+' (yet to remove: '+users_waiting_to_be_removed_in_this_batch.length+') member of: '+this_team.roles.length+' roles (yet to be removed from: '+roles_waiting_to_be_removed_in_this_batch.length+')');\r",
							"            // need to test if chucksize is too large, if so we need to reduce it\r",
							"\r",
							"            if (number_of_user_changes_in_the_last_update>0) \r",
							"            {\r",
							"                // then our last update was for adding or removing users, so we need to change the chunk size accordingly\r",
							"                // however, there is a condition where we are removing users to allow updates to roles to be made, before we then start adding users in.\r",
							"                // it means that a chunk update may not have been 'full' of users, this in turn means the last update could had been very quick and we need to\r",
							"                // only adjust the chunk size when the last update was 'full'.\r",
							"\r",
							"                if ( (number_of_user_changes_in_the_last_update == this_team.users_chunk_size) && (previouserrors ===0 ) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.users_chunk_size;\r",
							"                    if (pm.response.responseTime>270000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.6);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime>210000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.8);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 2);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<120000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 1.75);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 2 mins. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.users_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                    postman.setNextRequest(pm.info.requestName); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    postman.setNextRequest(pm.info.requestName); \r",
							"                };\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // our last update was for adding or removing roles, so we need to change the chunk size accordingly \r",
							"                // however we may only remove roles before adding them, so we need to check the chunk was 'full'\r",
							"                if ( (number_of_roles_changes_in_the_last_update == this_team.roles_chunk_size) && (previouserrors === 0) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.roles_chunk_size;\r",
							"                    if ( (pm.response.responseTime>270000)  && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if ( (pm.response.responseTime>210000) && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<20000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 20 secs. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<80000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min 30 secs. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.roles_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                };\r",
							"                postman.setNextRequest(pm.info.requestName); \r",
							"            };\r",
							"        }\r",
							"        else // the current team has been processed\r",
							"        {\r",
							"            // so we should now remove the team from the teams array\r",
							"            array_of_teams.splice(this_team_index,1);\r",
							"            pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team emptied of users and its no longer a member of any roles');\r",
							"            postman.setNextRequest();\r",
							"            };\r",
							"\r",
							"        };  // end waiting to be added/removed\r",
							"        \r",
							"    }  // end reponse is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }  // end if else\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],\r\n    \"id\": \"{{currentteam}}\",\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"meta\": {{meta}},\r\n    \"members\": {{members}},\r\n    \"roles\": {{roles}}\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_delete_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_delete_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "DELETE team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"DELETE team\", function () \r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([204,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // we are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // we need to issue a GET call to obtain access. \r",
							"        // it is unlikely we'll get a 403 on this call, since the earlier 401 error would have first requested a new csrf-token, then on the second 401 error it would request\r",
							"        // a new access token. And because the 'recovery' variable is set to a GET call, when that GET call is issued, the session be authorised.\r",
							"        // And because 'NeedGetToBeAuthorised' is set to true, any post-processing in the GET call will be skipped and we'll come back to his call, when a re-submit of the call will be made,\r",
							"        // because 'ContinuousErrors' will be over 0.  Thus, its very unlikely we'll receive a 403 error, but we'll include it just in case!\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403    \r",
							"else if (pm.response.code === 204)\r",
							"{\r",
							"    // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"    pm.variables.set(\"ContinuousErrors\",0);\r",
							"    \r",
							"    const currentteam = pm.variables.get(\"currentteam\");\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Team '+currentteam+' successfully deleted');\r",
							"    postman.setNextRequest(null);\r",
							"}\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }  // end if else\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const currentteam = pm.variables.get(\"currentteam\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Deleting team '+currentteam);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "DELETE",
				"header": [
					{
						"key": "id",
						"type": "text",
						"value": "I049477V3",
						"disabled": true
					},
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Authorization",
						"type": "text",
						"value": "Bearer ",
						"disabled": true
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_delete_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_delete_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(responseBody);\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        postman.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ responseBody);\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=3;  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    postman.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}