{
	"info": {
		"_postman_id": "4763c8e7-0583-4d05-8be5-ab363662c9fa",
		"name": "232-U-UC-UClemr-Oarrk-Fj-Es-SAML Update/create users (with roles, no teams)",
		"description": "Provided 'as is'\n================\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\nUser guide\n==========\n\nhttps://d.dam.sap.com/s/c/a/kv3cXuB\n\nBlog (for Q&A)\n==============\nhttps://blogs.sap.com/2021/05/24/sap-analytics-cloud-scim-api-best-practices-and-sample-scripts/\n\nAbout\n=====\n\nScript version 0.5\n\nSample scripts created by Matthew Shaw, SAP. <https://people.sap.com/matthew.shaw/#content:blogposts>",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "READ user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // No user so we can't update the user. Abort this entry\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': User not found '+pm.iterationData.get(\"file_userid\")+', so will now create this user');\r",
							"        postman.setNextRequest(\"CREATE user\");\r",
							"    }\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated and the user does exist so we can now read the properties that make up this user\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (schemas.includes('urn:ietf:params:scim:schemas:core:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:enterprise:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0')\r",
							"                          );  // the schema read must contain these definitions, otherwise we could be PUTting back missing properties\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"        {\r",
							"            pm.expect(validschema);\r",
							"        }\r",
							"        );\r",
							"\r",
							"        if (validschema)\r",
							"            {            \r",
							"                // reading the current user value of the user properties held in SAP Analytics Cloud. \r",
							"                const SACvalueemail  = readbody.emails[0].value;  // we assume there is only 1 email address in the array and the one we want is the first listed.\r",
							"                const SACroles       = readbody.roles;\r",
							"                // need to grab the user custom parameters next...\r",
							"                const customparams   = readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"                // .. then we can get the current value and turn it to a String to allow a comparision with the desired setting\r",
							"                const SACvalueisconcurrent     = customparams.isConcurrent.toString(); // we need to change this boolean value to a string so the compare works\r",
							"                const SACenterpriseproperties  = readbody[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"                const SACvaluemanager          = SACenterpriseproperties.manager.managerId;\r",
							"\r",
							"                // read the desired values\r",
							"                // we can not update the givenname, familyname or displayname\r",
							"                // this script *can* update the email address\r",
							"                // it means this script can only update the email, isConcurrent and the managerId\r",
							"                const file_isconcurrent        =pm.iterationData.get(\"file_isconcurrent\").toString(); // the desired value from the file. \r",
							"                                                                                                // we need to change this boolean value to a string so the compare works\r",
							"                const file_email               =pm.iterationData.get(\"file_email\");\r",
							"                const file_managerid           =pm.iterationData.get(\"file_managerid\");\r",
							"                const file_roles_array         =pm.iterationData.get(\"file_JSON_roles\");\r",
							"                \r",
							"                let file_corrected_roles_array = [];\r",
							"\r",
							"                file_roles_array.forEach( myfunction_correct_role_definition);\r",
							"\r",
							"                function myfunction_correct_role_definition(value)\r",
							"                {\r",
							"                    let new_role_definition;\r",
							"                    let current_role_defintion=value.value;\r",
							"                    if (current_role_defintion.indexOf(\"PROFILE:\")==0)\r",
							"                    {\r",
							"                        file_corrected_roles_array.push(current_role_defintion);\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        new_role_definition=\"PROFILE:\".concat(pm.environment.get(\"ContentNamespace\"),\":\",current_role_defintion);\r",
							"                        file_corrected_roles_array.push(new_role_definition);\r",
							"                    } // end if\r",
							"                }; // end function\r",
							"\r",
							"                // we need to determine if there are roles in the user that aren't in the file, and the other way around too\r",
							"                let role_missing_in_SAC = false;\r",
							"                let role_found_in_SAC   = false;\r",
							"                file_corrected_roles_array.forEach( myfunction_test_roles_in_file );\r",
							"                function myfunction_test_roles_in_file(value)\r",
							"                {  \r",
							"                    if ( SACroles.find(element => element === value) ) // \r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User already a member of role '+value+' (RS1/RS3)');\r",
							"                        role_found_in_SAC = true;\r",
							"                    }\r",
							"                    else // role not found\r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User not a member of role '+value+' (RS2)');\r",
							"                        role_missing_in_SAC = true;\r",
							"                    }\r",
							"                    ; // end if \r",
							"                };  // end function\r",
							"\r",
							"                let role_missing_in_file = false;\r",
							"                SACroles.forEach( myfunction_test_roles_in_SAC );\r",
							"                function myfunction_test_roles_in_SAC(value)\r",
							"                {   \r",
							"                    if ( file_corrected_roles_array.find(element => element === value) ) // \r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User already a member of Role '+value+' (RS3/RS1)');\r",
							"                        role_found_in_file = true;\r",
							"                    }\r",
							"                    else // role not found\r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': Role not a member of role '+value+' (RS4)');\r",
							"                        role_missing_in_file = true;\r",
							"                    }\r",
							"                    ; // end if \r",
							"                };  // end function\r",
							"\r",
							"                let roles_update_required = false;\r",
							"                const roles_action =pm.iterationData.get(\"file_roles_action\");\r",
							"\r",
							"                if (roles_action===\"add\")\r",
							"                {\r",
							"                    roles_update_required = (role_missing_in_SAC);\r",
							"                }\r",
							"                else if (roles_action===\"keep\")\r",
							"                {\r",
							"                    // nothing to do\r",
							"                }\r",
							"                else if (roles_action===\"remove\")\r",
							"                {\r",
							"                    roles_update_required = (role_found_in_SAC);\r",
							"                }\r",
							"                else if (roles_action===\"replace\")\r",
							"                {\r",
							"                    roles_update_required = ( (role_missing_in_SAC || role_missing_in_file) );\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid roles action (supported actions: add, remove, replace, keep): '+ roles_action);\r",
							"                } // end roles_action\r",
							"\r",
							"                const updaterequired = ( (SACvalueisconcurrent  != file_isconcurrent)\r",
							"                                      || (SACvalueemail         != file_email)\r",
							"                                      || (SACvaluemanager       != file_managerid)\r",
							"                                      || (roles_update_required)     );\r",
							"                // updaterequries will be true or false. It will be true if the values are different, false otherwise\r",
							"                if (updaterequired)\r",
							"                    {\r",
							"                        pm.variables.set(\"readbody\", readbody)\r",
							"                        postman.setNextRequest(); // let Postman run the next call to UPDATE user\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': User already set correctly. Skipping user '+ pm.iterationData.get(\"file_userid\"));\r",
							"                        postman.setNextRequest(null); // skip this row in the file and read the next row\r",
							"                    }\r",
							"                 ;\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schmea version and it could corrupt your user. Aborting!');\r",
							"                postman.setNextRequest(null);\r",
							"            }\r",
							"        ;  // end if validschema\r",
							"    }  // end if response === 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"// we need to read the current properties of the user,\r",
							"// change the properties we want to and *then* we can PUT back all the user properties correctly having only changed the properties we need to change\r",
							"const readbody            =pm.variables.get(\"readbody\"); // reading the response body of the previous call that read the user\r",
							"const username            =readbody.userName; // changes to the username isn't allowed\r",
							"\r",
							"const preferredlanguage   =readbody.preferredLanguage;  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"\r",
							"const meta                =readbody.meta;    // changes to the meta isn't allowed\r",
							"const name                =readbody.name;    // changes to the name isn't allowed\r",
							"const displayname         =readbody.displayName; // string value\r",
							"const active              =readbody.active; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const emails              =readbody.emails; // JSON array of 'value','type','primary'\r",
							"emails[0].value           =pm.iterationData.get(\"file_email\");\r",
							"const photos              =readbody.photos; // JSON array\r",
							"let   roles               =readbody.roles;  // JSON array of SAC roles\r",
							"const groups              =readbody.groups; // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                          //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"const customparams        =readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"const dataaccesslanguage  =customparams.dataAccessLanguage; // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"const dateformatting      =customparams.dateFormatting;     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"const timeformatting      =customparams.timeFormatting;     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"const numberformatting    =customparams.numberFormatting;   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"const cleanupnotificationsnumberofdays=customparams.cleanUpNotificationsNumberOfDays; // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin=customparams.systemNotificationsEmailOptIn; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin =customparams.marketingEmailOptIn;                    // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const isconcurrent        =pm.iterationData.get(\"file_isconcurrent\");  // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE' \r",
							"const extension           =readbody[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"const manager             =extension.manager; // JSON array\r",
							"manager.managerId         =pm.iterationData.get(\"file_managerid\");\r",
							"\r",
							"\r",
							"//\r",
							"// if you wish to make simple modifications to this script, do so only by changing the code ***ABOVE*** this line and keep the code ***BELOW*** unchanged.\r",
							"//\r",
							"const file_roles_array         =pm.iterationData.get(\"file_JSON_roles\");\r",
							"let file_corrected_roles_array = [];\r",
							"file_roles_array.forEach( myfunction_correct_role_definition);\r",
							"\r",
							"function myfunction_correct_role_definition(value)\r",
							"{\r",
							"    let new_role_definition;\r",
							"    let current_role_defintion=value.value;\r",
							"    if (current_role_defintion.indexOf(\"PROFILE:\")==0)\r",
							"    {\r",
							"        file_corrected_roles_array.push(current_role_defintion);\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        new_role_definition=\"PROFILE:\".concat(pm.environment.get(\"ContentNamespace\"),\":\",current_role_defintion);\r",
							"        file_corrected_roles_array.push(new_role_definition);\r",
							"    } // end if\r",
							"}; // end function\r",
							"\r",
							"const roles_action =pm.iterationData.get(\"file_roles_action\");\r",
							"if (roles_action===\"add\")\r",
							"{\r",
							"    file_corrected_roles_array.forEach( myfunction_add_role_from_file_to_user );\r",
							"\r",
							"    function myfunction_add_role_from_file_to_user(value)\r",
							"    {\r",
							"        if ( roles.find(element => element === value) )  \r",
							"        {\r",
							"        //    console.log(pm.info.requestName+' '+pm.info.eventName+': User already a member of Role '+value+'. No action needed (RA1)')\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"        //    console.log(pm.info.requestName+' '+pm.info.eventName+': User not yet a member of Role '+value+' (RA4)');\r",
							"            roles.push(value);\r",
							"        }; // end if \r",
							"    };  // end function\r",
							"}\r",
							"else if (roles_action===\"keep\")\r",
							"{\r",
							"    // nothing to do\r",
							"}\r",
							"else if (roles_action===\"remove\")\r",
							"{\r",
							"    file_corrected_roles_array.forEach( myfunction_remove_role_from_file_from_user );\r",
							"\r",
							"    function myfunction_remove_role_from_file_from_user(value)\r",
							"    {\r",
							"        if ( roles.find(element => element === value) ) \r",
							"        {\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': User will be removed from role '+value+' membership (RR1)');\r",
							"            const roleindex = roles.findIndex(element => element == value);\r",
							"            roles.splice(roleindex,1);\r",
							"        }\r",
							"        else // role not found\r",
							"        {\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': User not a member of Role '+value+'. No action needed (R4)');\r",
							"        }\r",
							"        ; // end if \r",
							"    };  // end function\r",
							"}\r",
							"else if (roles_action===\"replace\")\r",
							"{\r",
							"    roles=file_corrected_roles_array;\r",
							"}\r",
							"else\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid roles action (supported actions: add, remove, replace, keep): '+ roles_action);\r",
							"} // end roles_action\r",
							"\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"id\",readbody.id);\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"meta\",JSON.stringify(meta));\r",
							"pm.variables.set(\"name\",JSON.stringify(name));     // JSON array of givenName and familyName\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"active\",active);                 // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"emails\",JSON.stringify(emails)); // JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"photos\",JSON.stringify(photos)); // JSON array\r",
							"pm.variables.set(\"roles\",JSON.stringify(roles));   // JSON array of SAC roles\r",
							"pm.variables.set(\"groups\",JSON.stringify(groups)); // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                                             //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"manager\",JSON.stringify(manager)); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 400)\r",
							"    {\r",
							"        // the user exists because of the previous READ user request. However we can't update the user, most likely due to a conflict of email address\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to update user '+ pm.iterationData.get(\"file_userid\") +' probably due to email conflict with another user. Response: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we updated the user so we can now proceed to the next row in the file. \r",
							"        // we don't need to let Postman run to GET accesstoken\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User '+ pm.iterationData.get(\"file_userid\") +' updated');\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n    \"userName\": \"{{username}}\",\r\n    \"id\": \"{{id}}\",\r\n    \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n    \"meta\": {{meta}},\r\n    \"name\": {{name}},\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"active\": {{active}},\r\n    \"emails\": {{emails}},\r\n    \"photos\": {{photos}},\r\n    \"roles\": {{roles}},\r\n    \"groups\": {{groups}},\r\n    \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n        \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n        \"dateFormatting\": \"{{dateformatting}}\",\r\n        \"timeFormatting\": \"{{timeformatting}}\",\r\n        \"numberFormatting\": \"{{numberformatting}}\",\r\n        \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n        \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n        \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n        \"isConcurrent\": {{isconcurrent}}\r\n    },\r\n    \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n        \"manager\": {{manager}}\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"\r",
							"\r",
							"//  Important! Be sure to create users correctly. Its far better to set them correctly at the time of creation rather than having to update users later\r",
							"//             Spend time now to carefully set the following values correctly\r",
							"\r",
							"\r",
							"\r",
							"const preferredlanguage   =\"en\";  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"const active              =\"true\";          // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'. A false setting will prevent the user from being able to login. \r",
							"const dataaccesslanguage  =\"zz\";            // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage. 'zz' is probably the best option\r",
							"const dateformatting      =\"dd/MM/yyyy\";    // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"const timeformatting      =\"H:mm:ss\";       // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"const numberformatting    =\"1,234.56\";      // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"const cleanupnotificationsnumberofdays=0;   // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin=\"false\";// possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin =\"false\";         // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'. Can be very handy to set to true as users will receive updates on new features.\r",
							"                                // It is recommended to set this to true, but it's set as false by default here as that is the default setting when creating users manually within SAP Analytics Cloud\r",
							"\r",
							"\r",
							"\r",
							"// In general do not edit below this line unless you want to 'fix' these values and ignore whats in the file.\r",
							"// You could remove the column/value from the file and fix the value here.\r",
							"// Any changes you make here are for 'new' users and so you will probably need to update the code in the 'READ user tests' and 'UPDATE user pre-request' for updating existing users\r",
							"const isconcurrent        =pm.iterationData.get(\"file_isconcurrent\");  // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE' \r",
							"const managerid           =pm.iterationData.get(\"file_managerid\");\r",
							"const displayname         =pm.iterationData.get(\"file_displayname\");\r",
							"const givenname           =pm.iterationData.get(\"file_givenname\");\r",
							"const familyname          =pm.iterationData.get(\"file_familyname\");\r",
							"// if you wish to make simple modifications to this script, do so only by changing the code ***ABOVE*** this line and keep the code ***BELOW*** unchanged.\r",
							"const userid              =pm.iterationData.get(\"file_userid\");\r",
							"const desiredemail        =pm.iterationData.get(\"file_email\");\r",
							"const domainname          =desiredemail.substr(desiredemail.search(\"@\"));\r",
							"const email               =userid.concat(domainname);\r",
							"const username            =email;\r",
							"\r",
							"\r",
							"let corrected_roles_array = [];\r",
							"\r",
							"const roles_action =pm.iterationData.get(\"file_roles_action\");\r",
							"if ( (roles_action===\"add\") || (roles_action===\"replace\") )\r",
							"{\r",
							"    // we will only assign roles to new users if the roles action is either add or replace, otherwise the user will not be assigned to any roles\r",
							"    const file_roles_array = pm.iterationData.get(\"file_JSON_roles\");\r",
							"    file_roles_array.forEach( myfunction_correct_role_definition);\r",
							"\r",
							"    function myfunction_correct_role_definition(value)\r",
							"    {\r",
							"        let new_role_definition;\r",
							"        let current_role_defintion=value.value;\r",
							"        if (current_role_defintion.indexOf(\"PROFILE:\")==0)\r",
							"        {\r",
							"            corrected_roles_array.push(current_role_defintion);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            new_role_definition=\"PROFILE:\".concat(pm.environment.get(\"ContentNamespace\"),\":\",current_role_defintion);\r",
							"            corrected_roles_array.push(new_role_definition);\r",
							"        } // end if\r",
							"    }; // end function\r",
							"};\r",
							"\r",
							"const corrected_teams_array = [];\r",
							"\r",
							"\r",
							"pm.variables.set(\"userid\",userid);\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"givenname\",givenname);\r",
							"pm.variables.set(\"familyname\",familyname);\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"active\",active);                 // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"email\",email);                   // string that is used inside a JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"roles\",JSON.stringify(corrected_roles_array));   // JSON array of SAC roles\r",
							"// pm.variables.set(\"groups\",JSON.stringify(corrected_teams_array)); // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                                             //             This entry will be ignored until then but its set here, albeit commented out, so it will work when supported.\r",
							"                                                             //             Once SAP Analytics Cloud supports assigning groups (teams) upon user creation, this line will need to un-commented\r",
							"                                                             //             and an entry into the Body will need to be added:  \"groups\": {{groups}},\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"managerid\",managerid); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,201,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        // as this is non-GET call, but we don#t need to set NeedGetToBeAuthorised to true as we can just re-read this user to obtain the authorisation needed.\r",
							"        // We shall set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if ( pm.response.code === 502)\r",
							"{\r",
							"    // we received a 502 which suggests the user was created but we can't be 100% sure.\r",
							"    // we shall thus go and read the user again, as its likely the user was created.\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Possible error when creating user '+pm.variables.get(\"userid\")+'. Assuming user created ok and re-reading user. Response: '+responseBody);\r",
							"    postman.setNextRequest(\"READ user\");\r",
							"}\r",
							"else if (pm.response.code === 409)\r",
							"{\r",
							"    // there is a conflict and so the user must already exist\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Failed to create user '+pm.variables.get(\"userid\")+'. Possible email conflict with another user. Response: '+responseBody);\r",
							"    postman.setNextRequest();\r",
							"}\r",
							"else if ( (pm.response.code === 200) || (pm.response.code === 201) )\r",
							"{\r",
							"    // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"    pm.variables.set(\"ContinuousErrors\",0);\r",
							"    const readbody    = JSON.parse(responseBody);\r",
							"    const username_created_in_SAC=readbody.userName;\r",
							"    const requested_username=pm.variables.get(\"userid\");\r",
							"    if (username_created_in_SAC===requested_username)\r",
							"    {\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User created: '+username_created_in_SAC);\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User created but with different username than requested. (This sample script will update a users email address) Requested: '+requested_username+' but created: '+username_created_in_SAC);\r",
							"    };\r",
							"    postman.setNextRequest(\"READ user\");\r",
							"}\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        const requested_username=pm.variables.get(\"userid\");\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors when creating user '+requested_username+'. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected when creating user '+requested_username+'. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error when creating user '+requested_username+'. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\":[\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n  \"userName\": \"{{username}}\",\r\n  \"id\": \"{{userid}}\",\r\n  \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n  \"name\": {\r\n     \"givenName\":\"{{givenname}}\",\r\n     \"familyName\":\"{{familyname}}\"\r\n  },\r\n  \"displayName\": \"{{displayname}}\",\r\n  \"active\": {{active}},\r\n  \"emails\": [\r\n    {\r\n      \"value\": \"{{email}}\",\r\n      \"type\": \"work\",\r\n      \"primary\": true\r\n    }\r\n  ],\r\n  \"roles\": {{roles}},\r\n  \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n    \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n    \"dateFormatting\": \"{{dateformatting}}\",\r\n    \"timeFormatting\": \"{{timeformatting}}\",\r\n    \"numberFormatting\": \"{{numberformatting}}\",\r\n    \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n    \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n    \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n    \"isConcurrent\": {{isconcurrent}}\r\n  },\r\n  \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n    \"manager\": {\r\n      \"managerId\": \"{{managerid}}\"\r\n    }\r\n  }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"   pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(responseBody);\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        postman.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ responseBody);\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=3;  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    postman.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}