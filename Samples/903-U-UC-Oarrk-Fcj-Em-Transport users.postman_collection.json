{
	"info": {
		"_postman_id": "d62ef6c2-7032-482c-aa8b-7efb808232a2",
		"name": "903-U-UC-Oarrk-Fcj-Em-Transport users",
		"description": "Provided 'as is'\n================\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\nUser guide\n==========\n\nhttps://d.dam.sap.com/a/kv3cXuB\n\nBlog (for Q&A)\n==============\nhttps://blogs.sap.com/2021/05/28/sap-analytics-cloud-scim-api-best-practices-and-sample-scripts/\n\nAbout\n=====\n\nScript version 0.6\n\nSample scripts created by Matthew Shaw, SAP. <https://people.sap.com/matthew.shaw/#content:blogposts>",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "READ source user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading source user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ source user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"Source-x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"Source-x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new source access token');\r",
							"        postman.setNextRequest(\"GET source accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // No user so we can't update the user. Abort this entry\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': User not found '+pm.iterationData.get(\"file_userid\")+'. Skipping user');\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New source session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        postman.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated and the user does exist so we can now read the properties that make up this user\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (schemas.includes('urn:ietf:params:scim:schemas:core:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:enterprise:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0')\r",
							"                          );  // the schema read must contain these definitions, otherwise we could be PUTting back missing properties\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"        {\r",
							"            pm.expect(validschema);\r",
							"        }\r",
							"        );\r",
							"\r",
							"        if (validschema)\r",
							"            {            \r",
							"                // storing the source user definition\r",
							"                pm.variables.set(\"current_source_user\",readbody);\r",
							"                // allow to proceed to next call, to read the target user\r",
							"                postman.setNextRequest();\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schmea version and it could corrupt your user. Aborting!');\r",
							"                postman.setNextRequest(null);\r",
							"            }\r",
							"        ;  // end if validschema\r",
							"    }  // end if response === 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{Source-accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{Source-x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{Source-SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{Source-SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ target user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading target user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ target user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"Target-x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"Target-x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new target access token');\r",
							"        postman.setNextRequest(\"GET target accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // No user so we can't update the user. Abort this entry\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Target user not found '+pm.iterationData.get(\"file_userid\")+', so will now create this user');\r",
							"        postman.setNextRequest(\"CREATE target user\");\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        postman.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated and the user does exist so we can now read the properties that make up this user\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (schemas.includes('urn:ietf:params:scim:schemas:core:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:enterprise:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0')\r",
							"                          );  // the schema read must contain these definitions, otherwise we could be PUTting back missing properties\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"        {\r",
							"            pm.expect(validschema);\r",
							"        }\r",
							"        );\r",
							"\r",
							"        if (validschema)\r",
							"            {            \r",
							"                current_source_user=pm.variables.get(\"current_source_user\");\r",
							"\r",
							"                // reading the current target user value of the user properties held in SAP Analytics Cloud. \r",
							"                const target_email              = readbody.emails[0].value;  // we assume there is only 1 email address in the array and the one we want is the first listed.\r",
							"                const source_email              = current_source_user.emails[0].value;\r",
							"                const target_preferredLanguage  = readbody.preferredLanguage;\r",
							"                const source_preferredLanguage  = current_source_user.preferredLanguage;\r",
							"                const target_active             = readbody.active.toString();\r",
							"                const source_active             = current_source_user.active.toString();\r",
							"                // name and displayName can not be updated as they are managed by the identity provider\r",
							"                const   target_photos             = JSON.stringify(readbody.photos);\r",
							"                //if (!target_photos) {target_photos =[] };\r",
							"                const   source_photos             = JSON.stringify(current_source_user.photos);\r",
							"                //if (!source_photos) {source_photos =[] };\r",
							"                let   target_roles_array        = readbody.roles;\r",
							"                let   source_roles_array        = current_source_user.roles;\r",
							"                if ( (target_roles_array.length===1) && (target_roles_array[0]==\"\")) {target_roles_array=[]};\r",
							"                if ( (source_roles_array.length===1) && (source_roles_array[0]==\"\")) {source_roles_array=[]};\r",
							"                const target_teams_array        = readbody.groups;\r",
							"                const source_teams_array        = current_source_user.groups;\r",
							"                const target_customparams       = readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"                const source_customparams       = current_source_user[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"                const target_dataAccessLanguage = target_customparams.dataAccessLanguage;\r",
							"                const source_dataAccessLanguage = source_customparams.dataAccessLanguage;\r",
							"                const target_dateFormatting     = target_customparams.dateFormatting\r",
							"                const source_dateFormatting     = source_customparams.dateFormatting;\r",
							"                const target_timeFormatting     = target_customparams.timeFormatting;\r",
							"                const source_timeFormatting     = source_customparams.timeFormatting;\r",
							"                const target_numberFormatting   = target_customparams.numberFormatting;\r",
							"                const source_numberFormatting   = source_customparams.numberFormatting;\r",
							"                const target_cleanUpNotificationsNumberOfDays = target_customparams.cleanUpNotificationsNumberOfDays;\r",
							"                const source_cleanUpNotificationsNumberOfDays = source_customparams.cleanUpNotificationsNumberOfDays;\r",
							"                const target_systemNotificationsEmailOptIn = target_customparams.systemNotificationsEmailOptIn;\r",
							"                const source_systemNotificationsEmailOptIn = source_customparams.systemNotificationsEmailOptIn;\r",
							"                const target_marketingEmailOptIn = target_customparams.marketingEmailOptIn.toString();\r",
							"                const source_marketingEmailOptIn = source_customparams.marketingEmailOptIn.toString();\r",
							"                const target_isconcurrent       = target_customparams.isConcurrent.toString();\r",
							"                const source_isconcurrent       = source_customparams.isConcurrent.toString();\r",
							"                const target_enterpriseproperties = readbody[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"                const source_enterpriseproperties = current_source_user[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"                const target_managerid          = target_enterpriseproperties.manager.managerId;\r",
							"                const source_managerid          = source_enterpriseproperties.manager.managerId;      \r",
							"                // we need to check if the userName property needs to be updated, but that only applies depending upon the source and target SAML setup\r",
							"                let update_username = false;\r",
							"\r",
							"                switch (pm.variables.get(\"Source-SAMLSSO\"))\r",
							"                {\r",
							"                    case 'custom':\r",
							"                    {\r",
							"                        switch (pm.variables.get(\"Target-SAMLSSO\"))\r",
							"                        {\r",
							"                            case 'custom':\r",
							"                            {\r",
							"                                // we need to check the userName of source and target match, because they may not\r",
							"                                if (source_username != target_username ) {update_username=true};\r",
							"                                break;\r",
							"                            }\r",
							"                            case 'email':\r",
							"                            {\r",
							"                                // we're mapping from customSSO to email, so there's no option for taking the custom userName!\r",
							"                                break;\r",
							"                            }\r",
							"                            default:\r",
							"                            {\r",
							"                                // default IdP or custom userid means userName always matchs userid.\r",
							"                                // we're mapping from SSO to email, so there's no option for taking the custom userName!\r",
							"                                break;\r",
							"                            }\r",
							"                        }\r",
							"                        break;\r",
							"                    }\r",
							"                    case 'email':\r",
							"                    {\r",
							"                        // when the source is SSOemail there's no userName to bring across because it is the email\r",
							"                        break;\r",
							"                    }\r",
							"                    default:\r",
							"                    {\r",
							"                        // source is default idp or SSO on userid\r",
							"                        // it means the userName can't be changed, so no need to check\r",
							"                        break;\r",
							"                    }\r",
							"                };                                      \r",
							"                // we don't need to correct any roles array because the source is SAC and not a file, so the entries will be valid\r",
							"                // however, it does mean the role in the target must exist and have the same namespace definition as the source\r",
							"\r",
							"                // we need to determine if there are roles in the user that aren't in the file, and the other way around too\r",
							"                let role_missing_in_SAC = false;\r",
							"                let role_found_in_SAC   = false;\r",
							"\r",
							"                source_roles_array.forEach( myfunction_test_roles_in_file );\r",
							"                function myfunction_test_roles_in_file(value)\r",
							"                {  \r",
							"                    if ( target_roles_array.find(element => element === value) ) // \r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User already a member of role '+value+' (RS1/RS3)');\r",
							"                        role_found_in_SAC = true;\r",
							"                    }\r",
							"                    else // role not found\r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User not a member of role '+value+' (RS2)');\r",
							"                        role_missing_in_SAC = true;\r",
							"                    }\r",
							"                    ; // end if \r",
							"                };  // end function\r",
							"\r",
							"                let role_missing_in_file = false;\r",
							"                target_roles_array.forEach( myfunction_test_roles_in_SAC );\r",
							"                function myfunction_test_roles_in_SAC(value)\r",
							"                {   \r",
							"                    if ( source_roles_array.find(element => element === value) ) // \r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User already a member of Role '+value+' (RS3/RS1)');\r",
							"                        role_found_in_file = true;\r",
							"                    }\r",
							"                    else // role not found\r",
							"                    {\r",
							"                        //console.log(pm.info.requestName+' '+pm.info.eventName+': Role not a member of role '+value+' (RS4)');\r",
							"                        role_missing_in_file = true;\r",
							"                    }\r",
							"                    ; // end if \r",
							"                };  // end function\r",
							"\r",
							"                let roles_update_required = false;\r",
							"                const roles_action =pm.iterationData.get(\"file_roles_action\");\r",
							"\r",
							"                if (roles_action===\"add\")\r",
							"                {\r",
							"                    roles_update_required = (role_missing_in_SAC);\r",
							"                }\r",
							"                else if (roles_action===\"keep\")\r",
							"                {\r",
							"                    // nothing to do\r",
							"                }\r",
							"                else if (roles_action===\"remove\")\r",
							"                {\r",
							"                    roles_update_required = (role_found_in_SAC);\r",
							"                }\r",
							"                else if (roles_action===\"replace\")\r",
							"                {\r",
							"                    roles_update_required = ( (role_missing_in_SAC || role_missing_in_file) );\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid roles action (supported actions: add, remove, replace, keep): '+ roles_action);\r",
							"                } // end roles_action\r",
							"\r",
							"                // We shall now process the team requirements for this user and store them in an array for processing when the end of the file is reached, thus 'batching' up all\r",
							"                // requests, so that a team can be updated with potentially just 1 PUT rather than a PUT for each and every user update. Remember we can't (yet) update a user\r",
							"                // to be a member of a team on a user basis, though this is planned in the roadmap.\r",
							"\r",
							"                let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"                if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"\r",
							"                \r",
							"                const userid         = readbody.id;\r",
							"\r",
							"                \r",
							"                \r",
							"\r",
							"                const teams_action =pm.iterationData.get(\"file_teams_action\");\r",
							"                if (teams_action===\"add\")\r",
							"                {\r",
							"                    source_teams_array.forEach( myfunction_add_user_to_waiting_to_add_to_team);\r",
							"\r",
							"                    function myfunction_add_user_to_waiting_to_add_to_team(value)\r",
							"                    {\r",
							"                        const teamname=value.value;\r",
							"                        let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                        let this_team;\r",
							"\r",
							"                        if (this_team_index<0) \r",
							"                            {\r",
							"                                this_team = {\"teamname\"  : teamname,\r",
							"                                            \"need_to_read\": true,\r",
							"                                            \"displayname\": \"\",\r",
							"                                            \"meta\"       : \"\",\r",
							"                                            \"members\"    : [],\r",
							"                                            \"roles\"      : [],\r",
							"                                            \"users_chunk_size\" : 0,\r",
							"                                            \"roles_chunk_size\" : 0,\r",
							"                                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                                array_of_teams.push(this_team);\r",
							"                                this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                            }\r",
							"                        else\r",
							"                            {\r",
							"                                this_team = array_of_teams[this_team_index];\r",
							"                            }\r",
							"                        ;  // end team index\r",
							"\r",
							"                        let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                        let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                        if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                        if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"\r",
							"                        if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === userid) )  // user_found_in_add_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' already added to add list. No action needed (UA1)');\r",
							"                        }\r",
							"                        else if (users_waiting_to_be_removed_in_this_batch.find(element => element.value === userid))  // user_found_in_remove_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+' User '+userid+' found in remove list, will remove user from remove list (UA2)');\r",
							"                            const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === userid);\r",
							"                            users_waiting_to_be_removed_in_this_batch.splice(userindex,1)\r",
							"                        }\r",
							"                        else if ( target_teams_array.find(element => element.value === teamname))\r",
							"                        {\r",
							"                            // the user is already a member of the team so we have nothing to do\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' already a member of team. Taking no action (UA3)');\r",
							"                        }\r",
							"                        else\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' being added to team ' +this_team.teamname+ ' add list (UA4)');\r",
							"                            const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                            newentry.value  = userid;\r",
							"                            newentry.$ref   = \"/api/v1/scim/Users/\".concat(userid);\r",
							"                            users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"                        }; // end if\r",
							"                        \r",
							"                    }; // end function\r",
							"\r",
							"                } // end if team action is add\r",
							"                else if (teams_action===\"remove\")\r",
							"                {\r",
							"                    source_teams_array.forEach( myfunction_add_user_to_waiting_to_remove_from_team);\r",
							"\r",
							"                    function myfunction_add_user_to_waiting_to_remove_from_team(value)\r",
							"                    {\r",
							"                        const teamname=value.value;\r",
							"                        let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                        let this_team;\r",
							"\r",
							"                        if (this_team_index<0) \r",
							"                            {\r",
							"                                this_team = {\"teamname\"  : teamname,\r",
							"                                            \"need_to_read\": true,\r",
							"                                            \"displayname\": \"\",\r",
							"                                            \"meta\"       : \"\",\r",
							"                                            \"members\"    : [],\r",
							"                                            \"roles\"      : [],\r",
							"                                            \"users_chunk_size\" : 0,\r",
							"                                            \"roles_chunk_size\" : 0,\r",
							"                                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                                array_of_teams.push(this_team);\r",
							"                                this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                            }\r",
							"                        else\r",
							"                            {\r",
							"                                this_team = array_of_teams[this_team_index];\r",
							"                            }\r",
							"                        ;  // end team index\r",
							"\r",
							"                        let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                        let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                        if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                        if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"\r",
							"                        \r",
							"                        if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === userid) ) // user_found_in_remove_list \r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' already in remove list. No action needed (UR1)');\r",
							"                        }\r",
							"                        else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === userid) )  // user_found_in_add_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' already will be removed from add list (UR2)');\r",
							"                            const userindex = users_waiting_to_be_added_in_this_batch.findIndex(element => element.value === userid);\r",
							"                            users_waiting_to_be_added_in_this_batch.splice(userindex,1);\r",
							"                        }\r",
							"                        else if ( target_teams_array.find(element => element.value === teamname) ) // user_found_in_existing_team_membership\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' added to the remove list (UR3)');\r",
							"                            const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                            newentry.value  = userid;\r",
							"                            newentry.$ref   = \"/api/v1/scim/Users/\".concat(userid);\r",
							"                            users_waiting_to_be_removed_in_this_batch.push(newentry);\r",
							"                        }\r",
							"                        else // user not found\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' now a member of team '+teamname+' (UR4)');\r",
							"                        }\r",
							"                        ; // end if  \r",
							"                    }; // end function\r",
							"\r",
							"                } // end if team action is remove\r",
							"                else if (teams_action===\"replace\")\r",
							"                {\r",
							"                    source_teams_array.forEach( myfunction_add_users_from_replace_list_to_add_list);\r",
							"\r",
							"                    function myfunction_add_users_from_replace_list_to_add_list(value)\r",
							"                    {\r",
							"                        const teamname=value.value;\r",
							"                        let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                        let this_team;\r",
							"\r",
							"                        if (this_team_index<0) \r",
							"                            {\r",
							"                                this_team = {\"teamname\"  : teamname,\r",
							"                                            \"need_to_read\": true,\r",
							"                                            \"displayname\": \"\",\r",
							"                                            \"meta\"       : \"\",\r",
							"                                            \"members\"    : [],\r",
							"                                            \"roles\"      : [],\r",
							"                                            \"users_chunk_size\" : 0,\r",
							"                                            \"roles_chunk_size\" : 0,\r",
							"                                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                                array_of_teams.push(this_team);\r",
							"                                this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                            }\r",
							"                        else\r",
							"                            {\r",
							"                                this_team = array_of_teams[this_team_index];\r",
							"                            }\r",
							"                        ;  // end team index\r",
							"\r",
							"                        let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                        let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                        if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                        if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"                        if ( target_teams_array.find(element => element.value === teamname) ) // \r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' already member of team (US1/US3)');\r",
							"                        }\r",
							"                        else // user not found\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' needs to be added to team (US2)');\r",
							"                            const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                            newentry.value  = userid;\r",
							"                            newentry.$ref   = \"/api/v1/scim/Users/\".concat(userid);\r",
							"                            users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"                        }\r",
							"                        ; // end if \r",
							"                    }; // end function\r",
							"\r",
							"\r",
							"                    target_teams.forEach( myfunction_add_users_from_existing_team_to_remove_list );\r",
							"                    function myfunction_add_users_from_existing_team_to_remove_list(value)\r",
							"                    {   \r",
							"                        const teamname=value.value;\r",
							"                        let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                        let this_team;\r",
							"\r",
							"                        if (this_team_index<0) \r",
							"                            {\r",
							"                                this_team = {\"teamname\"  : teamname,\r",
							"                                            \"need_to_read\": true,\r",
							"                                            \"displayname\": \"\",\r",
							"                                            \"meta\"       : \"\",\r",
							"                                            \"members\"    : [],\r",
							"                                            \"roles\"      : [],\r",
							"                                            \"users_chunk_size\" : 0,\r",
							"                                            \"roles_chunk_size\" : 0,\r",
							"                                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                                array_of_teams.push(this_team);\r",
							"                                this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                            }\r",
							"                        else\r",
							"                            {\r",
							"                                this_team = array_of_teams[this_team_index];\r",
							"                            }\r",
							"                        ;  // end team index\r",
							"\r",
							"                        let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                        let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                        if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                        if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"                        if ( source_teams_array.find(element => element.value === teamname) ) // \r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' already member of team (US3/US1)');\r",
							"                        }\r",
							"                        else // user not found\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid+' removed (US4)');\r",
							"                            const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                            newentry.value  = userid;\r",
							"                            newentry.$ref   = \"/api/v1/scim/Users/\".concat(userid);\r",
							"                            users_waiting_to_be_removed_in_this_batch.push(newentry);\r",
							"                        }\r",
							"                        ; // end if \r",
							"                    };  // end function\r",
							"\r",
							"                } // end if team action is replace\r",
							"                else if (roles_action===\"keep\")\r",
							"                {\r",
							"                    // nothing to do\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid teams action (supported actions: add, remove, replace, keep): '+ roles_action);\r",
							"                } // end roles_action\r",
							"\r",
							"\r",
							"                pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"                const userupdaterequired = (   (target_email                        != source_email )\r",
							"                                            || (target_preferredLanguage            != source_preferredLanguage)\r",
							"                                            || (target_active                       != source_active)\r",
							"                                            || (target_photos                       != source_photos)\r",
							"                                            || (target_dataAccessLanguage           !=source_dataAccessLanguage )\r",
							"                                            || (target_dateFormatting               != source_dateFormatting)\r",
							"                                            || (target_timeFormatting               != source_timeFormatting)\r",
							"                                            || (target_numberFormatting             !=source_numberFormatting )\r",
							"                                            || (target_cleanUpNotificationsNumberOfDays != source_cleanUpNotificationsNumberOfDays )\r",
							"                                            || (target_systemNotificationsEmailOptIn != source_systemNotificationsEmailOptIn)\r",
							"                                            || (target_marketingEmailOptIn          !=source_marketingEmailOptIn)\r",
							"                                            || (target_isconcurrent                 != source_isconcurrent)\r",
							"                                            || (target_managerid                    != source_managerid)\r",
							"                                            || (roles_update_required)\r",
							"                                            || (update_username)                 );\r",
							"                \r",
							"                // updaterequries will be true or false. It will be true if the values are different, false otherwise\r",
							"                if (userupdaterequired)  // update required of the user. A team update may still be needed.\r",
							"                    {\r",
							"                        pm.variables.set(\"readbody\", readbody)\r",
							"                        postman.setNextRequest(); // let Postman run the next call to UPDATE user\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        console.info(pm.info.requestName+' '+pm.info.eventName+': Target user '+ pm.iterationData.get(\"file_userid\")+' already set correctly');\r",
							"                        \r",
							"\r",
							"                        let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"                        array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"                            function Users_to_add_for_this_team(team)\r",
							"                            {\r",
							"                                total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                                    +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                                    +team.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                                                    +team.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                                                    +team.arrayofroles_waiting_to_be_removed_in_this_batch.length;\r",
							"                            };\r",
							"\r",
							"\r",
							"                        // update_based_on_entries_read_so_far will be true every 100 records have been read from the file, i.e. every 500 users\r",
							"                        const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"                        // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"                        const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"                        const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"                        //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"                        //\r",
							"                        // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"                        // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"                        //\r",
							"                        // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"                        if ( update_teams_now )\r",
							"                        {\r",
							"                            // the row in the file we are processing *is* the last row and so we must now update the teams.\r",
							"                            // lets first find a team that needs to be read and that also needs to be updated at all\r",
							"                            const first_team_to_read_index = array_of_teams.findIndex(element => \r",
							"                                                    (  element.need_to_read === true  )    \r",
							"                                                    && (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                        + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                                        + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                                        + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 )    );\r",
							"\r",
							"                            if ( first_team_to_read_index >= 0 )\r",
							"                            {\r",
							"                                pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"                                postman.setNextRequest(\"READ target team\");\r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"                                // this setNextRequest can now be UPDATE team, since we don't need to re-read the team\r",
							"                                const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                                                (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                    + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                                    + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                                    + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"                                if (first_team_to_update_index >= 0)\r",
							"                                {\r",
							"                                    // there is a team that needs to be updated\r",
							"                                    pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                                    postman.setNextRequest(\"UPDATE target team\");\r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                                    console.log(pm.info.requestName+' '+pm.info.eventName+': There are no team require updating');\r",
							"                                    postman.setNextRequest(null);\r",
							"                                };\r",
							"                            };\r",
							"                        }\r",
							"                        else \r",
							"                        {\r",
							"                            // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"                            // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams needing an update');\r",
							"                            postman.setNextRequest(null);\r",
							"                        };\r",
							"\r",
							"\r",
							"                    }\r",
							"                 ; // end if updated needed\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schmea version and it could corrupt your user. Aborting!');\r",
							"                postman.setNextRequest(null);\r",
							"            }\r",
							"        ;  // end if validschema\r",
							"    }  // end if response === 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{Target-accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{Target-x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{Target-SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{Target-SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE target user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating target user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"// reading the source user definition\r",
							"const current_source_user       =pm.variables.get(\"current_source_user\");\r",
							"\r",
							"// we shall then perform a full update of all the properties of the user so we are 'setting' or 'replacing' all the values of the target user with the values from the source user\r",
							"const readbody            =pm.variables.get(\"readbody\"); // reading the response body of the previous call that read the user, this is the target user\r",
							"const preferredlanguage   =current_source_user.preferredLanguage;\r",
							"//const preferredlanguage   =readbody.preferredLanguage;  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"const meta                =readbody.meta;    // changes to the meta isn't allowed\r",
							"const name                =readbody.name;    // changes to the name isn't allowed\r",
							"const displayname         =readbody.displayName; // string value\r",
							"const active              =current_source_user.active\r",
							"const emails              =readbody.emails; // JSON array of 'value','type','primary'\r",
							"emails[0].value           =current_source_user.emails[0].value;\r",
							"const photos              =current_source_user.photos;\r",
							"let   roles               =readbody.roles;  // JSON array of SAC roles\r",
							"const groups              =readbody.groups; // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                          //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"const source_customparams =current_source_user[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"const dataaccesslanguage  =source_customparams.dataAccessLanguage; // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"const dateformatting      =source_customparams.dateFormatting;     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"const timeformatting      =source_customparams.timeFormatting;     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"const numberformatting    =source_customparams.numberFormatting;   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"const cleanupnotificationsnumberofdays=source_customparams.cleanUpNotificationsNumberOfDays; // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin=source_customparams.systemNotificationsEmailOptIn; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin =source_customparams.marketingEmailOptIn;                    // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const isconcurrent        =source_customparams.isConcurrent;  // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE' \r",
							"const source_enterpriseproperties = current_source_user[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"const manager             =source_enterpriseproperties.manager; // JSON array\r",
							"\r",
							"//\r",
							"// if you wish to make simple modifications to this script, do so only by changing the code ***ABOVE*** this line and keep the code ***BELOW*** unchanged.\r",
							"//\r",
							"\r",
							"// we need to manage the userName property if using SAML SSO mapping on email address and custom\r",
							"let   username            ='';\r",
							"switch (pm.variables.get(\"Target-SAMLSSO\"))\r",
							"{\r",
							"    case 'email':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on email. When we update the email, we must also update the userName.\r",
							"        username=emails[0].value;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        // the target userName property (for when the target has a 'custom' SSO setup) will be different depending on how the source is configured.\r",
							"        // if the source is based on email, then the custom property is probably best set to be the SAC userid\r",
							"        // otherwise we should respect the existing userName property.\r",
							"        switch (pm.variables.get(\"Source-SAMLSSO\"))\r",
							"        {\r",
							"            case 'email':\r",
							"            {\r",
							"                username = current_source_user.id;\r",
							"                break;\r",
							"            }\r",
							"            default:\r",
							"            {\r",
							"                username = current_source_user.userName;\r",
							"                break;\r",
							"            }\r",
							"        }\r",
							"    }\r",
							"\r",
							"    default: \r",
							"    {\r",
							"        // i.e. SAP Analytics Cloud is using the default IdP or using a custom IdP Mapping on UserID. When this is the case, the userName can NOT be updated.\r",
							"        username = current_source_user.userName;\r",
							"        break;\r",
							"    }\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"\r",
							"\r",
							"let source_roles_array = current_source_user.roles;\r",
							"if (!source_roles_array) { source_roles_array=[] };\r",
							"\r",
							"const roles_action =pm.iterationData.get(\"file_roles_action\");\r",
							"if (roles_action===\"add\")\r",
							"{\r",
							"    source_roles_array.forEach( myfunction_add_role_from_file_to_user );\r",
							"\r",
							"    function myfunction_add_role_from_file_to_user(value)\r",
							"    {\r",
							"        if ( roles.find(element => element === value) )  \r",
							"        {\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': User already a member of Role '+value+'. No action needed (RA1)')\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': User not yet a member of Role '+value+' (RA4)');\r",
							"            roles.push(value);\r",
							"        }; // end if \r",
							"    };  // end function\r",
							"}\r",
							"else if (roles_action===\"keep\")\r",
							"{\r",
							"    // nothing to do\r",
							"}\r",
							"else if (roles_action===\"remove\")\r",
							"{\r",
							"    source_roles_array.forEach( myfunction_remove_role_from_file_from_user );\r",
							"\r",
							"    function myfunction_remove_role_from_file_from_user(value)\r",
							"    {\r",
							"        if ( roles.find(element => element === value) ) \r",
							"        {\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': User will be removed from role '+value+' membership (RR1)');\r",
							"            const roleindex = roles.findIndex(element => element === value);\r",
							"            roles.splice(roleindex,1);\r",
							"        }\r",
							"        else // role not found\r",
							"        {\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': User not a member of Role '+value+'. No action needed (R4)');\r",
							"        }\r",
							"        ; // end if \r",
							"    };  // end function\r",
							"}\r",
							"else if (roles_action===\"replace\")\r",
							"{\r",
							"    roles=source_roles_array;\r",
							"}\r",
							"else\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid roles action (supported actions: add, remove, replace, keep): '+ roles_action);\r",
							"} // end roles_action\r",
							"\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"id\",readbody.id);\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"meta\",JSON.stringify(meta));\r",
							"pm.variables.set(\"name\",JSON.stringify(name));     // JSON array of givenName and familyName\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"active\",active);                 // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"emails\",JSON.stringify(emails)); // JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"photos\",JSON.stringify(photos)); // JSON array\r",
							"pm.variables.set(\"roles\",JSON.stringify(roles));   // JSON array of SAC roles\r",
							"pm.variables.set(\"groups\",JSON.stringify(groups)); // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                                             //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"manager\",JSON.stringify(manager)); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"let possible_teams_update_required = false;\r",
							"let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET target accesstoken\");        \r",
							"        // as this is non-GET call, we shall set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"recovery\",\"READ target user\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ target user\");\r",
							"        postman.setNextRequest(\"GET target accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 400)\r",
							"    {\r",
							"        // the user exists because of the previous READ user request. However we can't update the user, most likely due to a conflict of email address\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to update user '+ pm.iterationData.get(\"file_userid\") +' probably due to email conflict with another user. Response: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"        possible_teams_update_required=true;\r",
							"    }\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we updated the user so we can now proceed to the next row in the file. \r",
							"        // we don't need to let Postman run to GET accesstoken\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User '+ pm.iterationData.get(\"file_userid\") +' updated');\r",
							"\r",
							"        possible_teams_update_required=true;\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"            possible_teams_update_required=true;\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";\r",
							"\r",
							"\r",
							"if (possible_teams_update_required)\r",
							"{\r",
							"    let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"    array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"        function Users_to_add_for_this_team(team)\r",
							"        {\r",
							"            total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                +team.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                                +team.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                                +team.arrayofroles_waiting_to_be_removed_in_this_batch.length;\r",
							"        };\r",
							"\r",
							"\r",
							"    // update_based_on_entries_read_so_far will be true every 100 records have been read from the file, i.e. every 500 users\r",
							"    const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"    // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"    const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"    const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"    //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"    //\r",
							"    // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"    // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"    //\r",
							"    // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"    if ( update_teams_now )\r",
							"    {\r",
							"        // the row in the file we are processing *is* the last row and so we must now update the teams.\r",
							"        // lets first find a team that needs to be read and that also needs to be updated at all\r",
							"        const first_team_to_read_index = array_of_teams.findIndex(element => \r",
							"                                (  element.need_to_read === true  )    \r",
							"                                && (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                    + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                    + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                    + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 )    );\r",
							"\r",
							"        if ( first_team_to_read_index >= 0 )\r",
							"        {\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"            postman.setNextRequest(\"READ target team\");\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"            // this setNextRequest can now be UPDATE team, since we don't need to re-read the team\r",
							"            const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                            (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"            if (first_team_to_update_index >= 0)\r",
							"            {\r",
							"                // there is a team that needs to be updated\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                postman.setNextRequest(\"UPDATE target team\");\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update');\r",
							"                postman.setNextRequest(null);\r",
							"            };\r",
							"        };\r",
							"    }\r",
							"    else \r",
							"    {\r",
							"        // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"        // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"        //console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams needing an update');\r",
							"        postman.setNextRequest(null);\r",
							"    };\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{Target-accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{Target-x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n    \"userName\": \"{{username}}\",\r\n    \"id\": \"{{id}}\",\r\n    \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n    \"meta\": {{meta}},\r\n    \"name\": {{name}},\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"active\": {{active}},\r\n    \"emails\": {{emails}},\r\n    \"photos\": {{photos}},\r\n    \"roles\": {{roles}},\r\n    \"groups\": {{groups}},\r\n    \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n        \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n        \"dateFormatting\": \"{{dateformatting}}\",\r\n        \"timeFormatting\": \"{{timeformatting}}\",\r\n        \"numberFormatting\": \"{{numberformatting}}\",\r\n        \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n        \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n        \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n        \"isConcurrent\": {{isconcurrent}}\r\n    },\r\n    \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n        \"manager\": {{manager}}\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{Target-SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{Target-SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE target user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating target user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"// reading the source user definition\r",
							"const current_source_user       =pm.variables.get(\"current_source_user\");\r",
							"\r",
							"// we shall then perform a full update of all the properties of the user so we are 'setting' or 'replacing' all the values of the target user with the values from the source user\r",
							"const preferredlanguage   =current_source_user.preferredLanguage;\r",
							"const givenname           =current_source_user.name.givenName;\r",
							"const familyname          =current_source_user.name.familyName;\r",
							"const displayname         =current_source_user.displayName;\r",
							"const active              =current_source_user.active\r",
							"const email               =current_source_user.emails[0].value;\r",
							"const photos              =current_source_user.photos;\r",
							"let   roles               =[];  // JSON array of SAC roles\r",
							"const source_customparams =current_source_user[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"const dataaccesslanguage  =source_customparams.dataAccessLanguage; // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"const dateformatting      =source_customparams.dateFormatting;     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"const timeformatting      =source_customparams.timeFormatting;     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"const numberformatting    =source_customparams.numberFormatting;   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"const cleanupnotificationsnumberofdays=source_customparams.cleanUpNotificationsNumberOfDays; // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin=source_customparams.systemNotificationsEmailOptIn; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin =source_customparams.marketingEmailOptIn;                    // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const isconcurrent        =source_customparams.isConcurrent;  // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE' \r",
							"const source_enterpriseproperties = current_source_user[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"const managerid           =source_enterpriseproperties.manager.managerId;\r",
							"\r",
							"// we need to manage the userName property if using SAML SSO mapping on email address and custom\r",
							"let   username            ='';\r",
							"switch (pm.variables.get(\"Target-SAMLSSO\"))\r",
							"{\r",
							"    case 'email':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on email. When we create the user the username must be the email address\r",
							"        username=email;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        // the target userName property (for when the target has a 'custom' SSO setup) will be different depending on how the source is configured.\r",
							"        // if the source is based on email, then the custom property is probably best set to be the SAC userid\r",
							"        // otherwise we should respect the existing userName property.\r",
							"        switch (pm.variables.get(\"Source-SAMLSSO\"))\r",
							"        {\r",
							"            case 'email':\r",
							"            {\r",
							"                // if the source is an email address and the target is custom, then we shall map the source id to the target userName (SAML mapping)\r",
							"                username = current_source_user.id;\r",
							"                break;\r",
							"            }\r",
							"            case 'custom':\r",
							"            {\r",
							"                // the new user should have the SAC userid of the source\r",
							"                // this could be a problem as the source userid could be different from this new target user id. \r",
							"                // it would mean that the source userName becomes the target userID. To avoid this problem, use sample script 933 instead.\r",
							"                // you could change this to username = current_source_user.id; and then later update the userName for when the userName is not the same as id.\r",
							"                // OR just use script 933 and it will do that for you.\r",
							"                username = current_source_user.userName;\r",
							"                break;\r",
							"            }\r",
							"            default:\r",
							"            {\r",
							"                username = current_source_user.userName;\r",
							"                break;\r",
							"            }\r",
							"        }\r",
							"    }\r",
							"\r",
							"    default: \r",
							"    {\r",
							"        // i.e. SAP Analytics Cloud is using the default IdP or using a custom IdP Mapping on UserID. When this is the case, the userName can NOT be updated.\r",
							"        username = current_source_user.userName;\r",
							"        break;\r",
							"    }\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"const roles_action =pm.iterationData.get(\"file_roles_action\");\r",
							"if ( (roles_action===\"add\") || (roles_action===\"replace\") )\r",
							"{\r",
							"    // we will only assign roles to new users if the roles action is either add or replace, otherwise the user will not be assigned to any roles\r",
							"    roles=current_source_user.roles;\r",
							"}\r",
							"\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"givenname\",givenname);\r",
							"pm.variables.set(\"familyname\",familyname);\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"active\",active);                 // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"email\",email);                   // string that is used inside a JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"roles\",JSON.stringify(roles));   // JSON array of SAC roles\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"managerid\",managerid); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE target user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,201,401,403,502])\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new target access token');\r",
							"        postman.setNextRequest(\"GET target accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        // as this is non-GET call, but we don#t need to set NeedGetToBeAuthorised to true as we can just re-read this user to obtain the authorisation needed.\r",
							"        // We shall set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"recovery\",\"READ target user\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ target user\");\r",
							"        postman.setNextRequest(\"GET target accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if ( pm.response.code === 502)\r",
							"{\r",
							"    // we received a 502 which suggests the user was created but we can't be 100% sure.\r",
							"    // we shall thus go and read the user again, as its likely the user was created.\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Possible error when creating target user '+pm.variables.get(\"userid\")+'. Assuming user created ok and re-reading target user. Response: '+responseBody);\r",
							"    postman.setNextRequest(\"READ target user\");\r",
							"}\r",
							"else if ( (pm.response.code === 200) || (pm.response.code === 201) || (pm.response.code === 409) )\r",
							"{\r",
							"    // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"    pm.variables.set(\"ContinuousErrors\",0);\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"    if (pm.response.code === 409)\r",
							"    {\r",
							"        // there is a conflict and so the user must already exist\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Failed to create target user '+pm.variables.get(\"username\")+'. Possible email conflict with another user. Response: '+responseBody);\r",
							"    }\r",
							"    else\r",
							"    {   // the user was created ok\r",
							"        \r",
							"        const readbody             =JSON.parse(responseBody);\r",
							"        const userid_created_in_SAC=readbody.id;\r",
							"        const current_source_user  =pm.variables.get(\"current_source_user\");\r",
							"        const requested_userid     =current_source_user.id;\r",
							"        if (userid_created_in_SAC===requested_userid)\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Target user created: '+userid_created_in_SAC);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            if ( (pm.variables.get(\"Target-SAMLSSO\")==='custom') && (pm.variables.get(\"Source-SAMLSSO\")='custom'))\r",
							"            {\r",
							"                console.warn(pm.info.requestName+' '+pm.info.eventName+': Target user created but with different ID than source user. Source was: '+requested_userid+' but created: '+userid_created_in_SAC+' userName may also not be correct! You will not be able to use this sample to update the user, better to use sample 933 to create the user with the correct user id');\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Target user created but with different ID than source user. Source was: '+current_source_user.id+' but created: '+userid_created_in_SAC+'. You will not be able to use this sample to update the user, better to use sample 933 to create the user with the correct user id');\r",
							"            }\r",
							"        };\r",
							"\r",
							"        \r",
							"\r",
							"        // we shall need to add the user to the team, but only if the teams action is add or replace. If the team action is remove, then we shouldn't add the user to any teams\r",
							"        const teams_action =pm.iterationData.get(\"file_teams_action\");\r",
							"\r",
							"\r",
							"        if ( (teams_action===\"add\") || (teams_action===\"replace\") )\r",
							"        {\r",
							"\r",
							"            // we must add this user to any teams specified in the file. The user won't exist in any team, since we just created it!\r",
							"            // it means we know we don't need to check the user is already in a team, or is in any list to be added or removed.\r",
							"            let file_teams_array =current_source_user.groups;\r",
							"            if (!file_teams_array) { file_teams_array=[] };\r",
							"            file_teams_array.forEach( myfunction_add_user_to_waiting_to_add_to_team);\r",
							"            function myfunction_add_user_to_waiting_to_add_to_team(value)\r",
							"            {\r",
							"                const teamname=value.value;\r",
							"                let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                let this_team;\r",
							"\r",
							"                if (this_team_index<0) \r",
							"                    {\r",
							"                        this_team = {\"teamname\"  : teamname,\r",
							"                                    \"need_to_read\": true,\r",
							"                                    \"displayname\": \"\",\r",
							"                                    \"meta\"       : \"\",\r",
							"                                    \"members\"    : [],\r",
							"                                    \"roles\"      : [],\r",
							"                                    \"users_chunk_size\" : 0,\r",
							"                                    \"roles_chunk_size\" : 0,\r",
							"                                    \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                    \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                                    \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                    \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                        array_of_teams.push(this_team);\r",
							"                        this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        this_team = array_of_teams[this_team_index];\r",
							"                    }\r",
							"                ;  // end team index\r",
							"\r",
							"                let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"\r",
							"                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+userid_created_in_SAC+' being added to team ' +this_team.teamname+ ' add list (UA4)');\r",
							"                const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                newentry.value  = userid_created_in_SAC;\r",
							"                newentry.$ref   = \"/api/v1/scim/Users/\".concat(userid_created_in_SAC);\r",
							"                users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"\r",
							"            }; // end function\r",
							"        }; // end if teams action is add or replace\r",
							"        \r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"    }; //end if response.code != 409\r",
							"\r",
							"    let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"    array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"        function Users_to_add_for_this_team(team)\r",
							"        {\r",
							"            total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                +team.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                                +team.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                                +team.arrayofroles_waiting_to_be_removed_in_this_batch.length;\r",
							"        };\r",
							"\r",
							"\r",
							"    // update_based_on_entries_read_so_far will be true every 100 records have been read from the file, i.e. every 500 users\r",
							"    const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"    // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"    const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"    const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"    //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"    //\r",
							"    // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"    // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"    //\r",
							"    // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"    if ( update_teams_now )\r",
							"    {\r",
							"        // the row in the file we are processing *is* the last row and so we must now update the teams.\r",
							"        // lets first find a team that needs to be read and that also needs to be updated at all\r",
							"        const first_team_to_read_index = array_of_teams.findIndex(element => \r",
							"                                (  element.need_to_read === true  )    \r",
							"                                && (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                        + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                        + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                        + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 )    );\r",
							"\r",
							"        if ( first_team_to_read_index >= 0 )\r",
							"        {\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"            postman.setNextRequest(\"READ target team\");\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"            // this setNextRequest can now be UPDATE team, since we don't need to re-read the team\r",
							"            const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                            (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"            if (first_team_to_update_index >= 0)\r",
							"            {\r",
							"                // there is a team that needs to be updated\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                postman.setNextRequest(\"UPDATE target team\");\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update');\r",
							"                postman.setNextRequest(null);\r",
							"            };\r",
							"        };\r",
							"    }\r",
							"    else \r",
							"    {\r",
							"        // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"        // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"        //console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams needing an update');\r",
							"        postman.setNextRequest(null);\r",
							"    };\r",
							"\r",
							"\r",
							"}\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{Target-accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{Target-x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\":[\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n  \"userName\": \"{{username}}\",\r\n  \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n  \"name\": {\r\n     \"givenName\":\"{{givenname}}\",\r\n     \"familyName\":\"{{familyname}}\"\r\n  },\r\n  \"displayName\": \"{{displayname}}\",\r\n  \"active\": {{active}},\r\n  \"emails\": [\r\n    {\r\n      \"value\": \"{{email}}\",\r\n      \"type\": \"work\",\r\n      \"primary\": true\r\n    }\r\n  ],\r\n  \"roles\": {{roles}},\r\n  \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n    \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n    \"dateFormatting\": \"{{dateformatting}}\",\r\n    \"timeFormatting\": \"{{timeformatting}}\",\r\n    \"numberFormatting\": \"{{numberformatting}}\",\r\n    \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n    \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n    \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n    \"isConcurrent\": {{isconcurrent}}\r\n  },\r\n  \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n    \"manager\": {\r\n      \"managerId\": \"{{managerid}}\"\r\n    }\r\n  }\r\n}"
				},
				"url": {
					"raw": "https://{{Target-SACserviceFQDN}}/api/v1/scim/Users",
					"protocol": "https",
					"host": [
						"{{Target-SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ target team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ target team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"Target-x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        \r",
							"        {\r",
							"            pm.environment.set(\"Target-x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new target access token');\r",
							"        postman.setNextRequest(\"GET target accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Team not found, we need to create it.\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false); // we have now authorised this session, albeit with a 404 not found!\r",
							"        const team_in_current_team_array= pm.variables.get(\"currentteam\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Target team not found. Creating new target team '+ team_in_current_team_array);\r",
							"        pm.variables.set(\"currentteam\",team_in_current_team_array);\r",
							"        postman.setNextRequest('CREATE target team');\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New target session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        postman.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (   schemas.includes('urn:ietf:params:scim:schemas:core:2.0:Group') );\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"            {\r",
							"                pm.expect(validschema);\r",
							"            }\r",
							"        );\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"        const team_in_current_team_array= pm.variables.get(\"currentteam\");\r",
							"        \r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === team_in_current_team_array);\r",
							"        const this_team = array_of_teams[this_team_index];\r",
							"\r",
							"        this_team.need_to_read  =false;\r",
							"        this_team.displayname   =readbody.displayName;\r",
							"        this_team.meta          =readbody.meta;\r",
							"        this_team.members       =readbody.members;\r",
							"        this_team.roles         =readbody.roles;\r",
							"        this_team.users_chunk_size= Math.round(((42-(42-21.85714))*210) - (readbody.members.length * 0.14));\r",
							"        if (this_team.users_chunk_size<1) { this_team.users_chunk_size = 1};\r",
							"        if ( readbody.members.length > 0)\r",
							"        {\r",
							"            this_team.roles_chunk_size= Math.round((210/(readbody.members.length*46/210))*10);  //210 is the target duration in seconds, 46 is the average rate of users/role/second\r",
							"            if (this_team.roles_chunk_size<1) { this_team.roles_chunk_size = 1};\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            this_team.roles_chunk_size= 50;\r",
							"        };\r",
							"\r",
							"\r",
							"        array_of_teams[this_team_index]=this_team;\r",
							"        \r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"        postman.setNextRequest();\r",
							"        \r",
							"        if (!validschema)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schema version and it could corrupt your team. Aborting!');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"    }  // end response is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);  // repeat this call and re-attempt it\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);  // repeat this call and re-attempt it\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading target team '+pm.variables.get(\"currentteam\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{Target-accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{Target-x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{Target-SACserviceFQDN}}/api/v1/scim/Groups/{{currentteam}}",
					"protocol": "https",
					"host": [
						"{{Target-SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{currentteam}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE target team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const currentteam = pm.variables.get(\"currentteam\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating target team '+currentteam);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const array_of_teams  = pm.variables.get(\"array_of_teams\");\r",
							"    var this_team_index = array_of_teams.findIndex(element => element.teamname === currentteam);\r",
							"    var this_team       = array_of_teams[this_team_index];\r",
							"    const displayname     = this_team.displayname;\r",
							"    const meta            = this_team.meta;\r",
							"    const users_chucksize       = this_team.users_chunk_size;\r",
							"    const roles_chunksize       = this_team.roles_chunk_size;\r",
							"    const users_in_this_team_update =this_team.members;\r",
							"    const roles_in_this_team_update =this_team.roles;\r",
							"    const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"    const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"    const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"    const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"\r",
							"    if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_added_in_this_batch)   { roles_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"    \r",
							"\r",
							"    let number_of_users_that_can_change_in_this_chunk;\r",
							"    if ((users_waiting_to_be_added_in_this_batch.length+users_waiting_to_be_removed_in_this_batch.length)>=users_chucksize)\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_chucksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=(users_waiting_to_be_added_in_this_batch.length + users_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"\r",
							"    let number_of_users_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_users_that_can_be_added_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_added_in_this_chunk =0;\r",
							"\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length > number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (users_waiting_to_be_removed_in_this_batch.length<=number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk-number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (users_waiting_to_be_added_in_this_batch.length<number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=users_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    const max_users_in_single_PUT_request = 32767;\r",
							"    if ((this_team.members.length+number_of_users_that_can_be_added_in_this_chunk) > max_users_in_single_PUT_request)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Maximum number of users reached '+max_users_in_single_PUT_request);\r",
							"        number_of_users_that_can_be_added_in_this_chunk=max_users_in_single_PUT_request-this_team.members.length\r",
							"    }\r",
							"\r",
							"\r",
							"\r",
							"    let number_of_roles_that_can_change_in_this_chunk;\r",
							"    if ((roles_waiting_to_be_added_in_this_batch.length+roles_waiting_to_be_removed_in_this_batch.length)>=roles_chunksize)\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=roles_chunksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=(roles_waiting_to_be_added_in_this_batch.length + roles_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"    \r",
							"    if (roles_waiting_to_be_removed_in_this_batch.length > number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_removed_in_this_batch.length<=number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=roles_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk-number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_added_in_this_batch.length<number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=roles_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    if (number_of_users_that_can_be_removed_in_this_chunk > 0)\r",
							"    {\r",
							"        // if we can remove users, then we should remove all users before adding or removing any roles\r",
							"        // we have disabled the ability for any roles to be added or removed under this condition\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        // but if we have any roles to add or remove then we must also prevent any new user from being added in this chunk\r",
							"        // since it is possible users will be removed and added within the same chunk, hence...\r",
							"        if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"        {\r",
							"            // we have now disabled the ability for new users to be added when users can be removed AND when there are role changes\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"        }\r",
							"    }\r",
							"    else if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"    {\r",
							"            // this is when there are users that can be added and there are changed needed to roles.\r",
							"            // in this condition we need to prevent new users from being added until all the role changes have been made.\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    };\r",
							"\r",
							"    let number_of_users_removed = 0;\r",
							"    let number_of_users_added   = 0;\r",
							"\r",
							"    const users_removed_in_this_chunk = [];\r",
							"    while (number_of_users_removed < number_of_users_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_user=users_waiting_to_be_removed_in_this_batch.shift();\r",
							"        users_removed_in_this_chunk.push(removing_user);\r",
							"        \r",
							"        let removing_user_index = users_in_this_team_update.findIndex(element => element.value === removing_user.value);\r",
							"        users_in_this_team_update.splice(removing_user_index,1);\r",
							"        number_of_users_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofusers_removed_in_this_chunk\",users_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_users_added < number_of_users_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        users_in_this_team_update.push(users_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_users_added++;\r",
							"    };\r",
							"\r",
							"\r",
							"    let number_of_roles_removed = 0;\r",
							"    let number_of_roles_added   = 0;\r",
							"\r",
							"    const roles_removed_in_this_chunk = [];\r",
							"    while (number_of_roles_removed < number_of_roles_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_role=roles_waiting_to_be_removed_in_this_batch.shift();\r",
							"        roles_removed_in_this_chunk.push(removing_role);\r",
							"        \r",
							"        let removing_role_index = roles_in_this_team_update.findIndex(element => element === removing_role);\r",
							"        roles_in_this_team_update.splice(removing_role_index,1);\r",
							"        number_of_roles_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofroles_removed_in_this_chunk\",roles_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_roles_added < number_of_roles_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        roles_in_this_team_update.push(roles_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_roles_added++;\r",
							"    };\r",
							"\r",
							"    // pm.variables.set(\"arrayofusers_waiting_to_be_added_in_this_batch\",users_waiting_to_be_added_in_this_batch);\r",
							"    // pm.variables.set(\"arrayofusers_waiting_to_be_removed_in_this_batch\",users_waiting_to_be_removed_in_this_batch);\r",
							"\r",
							"    const number_of_users_actually_changed = number_of_users_that_can_be_added_in_this_chunk + number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    const number_of_roles_actually_changed = number_of_roles_that_can_be_added_in_this_chunk + number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    pm.variables.set(\"number_of_users_in_this_chunk\",number_of_users_actually_changed);\r",
							"    pm.variables.set(\"number_of_roles_in_this_chunk\",number_of_roles_actually_changed);\r",
							"    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"    pm.variables.set(\"displayname\",displayname);\r",
							"    pm.variables.set(\"meta\",   JSON.stringify(meta));\r",
							"    pm.variables.set(\"members\",JSON.stringify(users_in_this_team_update));\r",
							"    pm.variables.set(\"roles\",  JSON.stringify(roles_in_this_team_update));\r",
							"    pm.variables.set(\"expected_user_count\",users_in_this_team_update.length);\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName\r",
							"                +': Updating target team: '+currentteam+': adding '+number_of_users_that_can_be_added_in_this_chunk\r",
							"                +' users, removing '+number_of_users_that_can_be_removed_in_this_chunk\r",
							"                +' users, adding '+number_of_roles_that_can_be_added_in_this_chunk\r",
							"                +' roles, removing '+number_of_roles_that_can_be_removed_in_this_chunk\r",
							"                +' roles');\r",
							"\r",
							"}  // end if errors"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE target team\", () => {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"});\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new target access token');\r",
							"        postman.setNextRequest(\"GET target accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"        postman.setNextRequest(\"GET target accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody            = JSON.parse(responseBody);\r",
							"        const expected_user_count = pm.variables.get(\"expected_user_count\");\r",
							"        const actual_user_count   = readbody.members.length;\r",
							"        const previouserrors=pm.variables.get(\"ContinuousErrors\");  // errors holds the number of previous errors before this sucessful event. We need to know this so not to adjust the chunk size.\r",
							"                                                            // adjusting the chunk size after a previous error could be because the previous error was resolved by a repeated call. \r",
							"                                                            // and that repeated call could had taken a fraction of the normal processing time because it had already partly processed it beforehand.\r",
							"        \r",
							"        if (expected_user_count === actual_user_count)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in team as expected');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in the team, however '+ expected_user_count+' where expected');\r",
							"        };\r",
							"\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === pm.variables.get(\"currentteam\"));\r",
							"        const this_team = array_of_teams[this_team_index];\r",
							"        \r",
							"        const number_of_user_changes_in_the_last_update=pm.variables.get(\"number_of_users_in_this_chunk\");\r",
							"        if (number_of_user_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const users_per_second = Math.round((number_of_user_changes_in_the_last_update/(pm.response.responseTime/1000))*10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+users_per_second+' users/second');\r",
							"\r",
							"            const users_in_last_request= JSON.parse(pm.variables.get(\"members\"));\r",
							"            users_in_last_request.forEach( myfunction_find_missing_users );\r",
							"            function myfunction_find_missing_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (S3/S1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' was not found in the target team, but was expected to be present');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const users_that_should_had_been_removed =pm.variables.get(\"arrayofusers_removed_in_this_chunk\");\r",
							"            users_that_should_had_been_removed.forEach( myfunction_find_not_removed_users );\r",
							"            function myfunction_find_not_removed_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' should had been removed, but was not');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"        \r",
							"        const number_of_roles_changes_in_the_last_update=pm.variables.get(\"number_of_roles_in_this_chunk\");\r",
							"        if (number_of_roles_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const roles_per_second = Math.round((number_of_roles_changes_in_the_last_update/(pm.response.responseTime/1000))*100)/100;\r",
							"            const users_per_role_per_second = Math.round( ((this_team.members.length*number_of_roles_changes_in_the_last_update)/(pm.response.responseTime/1000)) *10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+roles_per_second+' roles/second, '+users_per_role_per_second+' users/role/second');\r",
							"\r",
							"            const roles_in_last_request= JSON.parse(pm.variables.get(\"roles\"));\r",
							"            roles_in_last_request.forEach( myfunction_find_missing_roles );\r",
							"            function myfunction_find_missing_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team, already a member of '+value+' role (R3/R1)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Team not a member of role '+value+' but was expected to be');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const roles_that_should_had_been_removed =pm.variables.get(\"arrayofroles_removed_in_this_chunk\");\r",
							"            roles_that_should_had_been_removed.forEach( myfunction_find_not_removed_roles );\r",
							"            function myfunction_find_not_removed_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Role '+value.value+' should no longer contain this team, but does');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"\r",
							"        const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"        const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"        const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"        const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"        if( (users_waiting_to_be_added_in_this_batch.length\r",
							"            +users_waiting_to_be_removed_in_this_batch.length\r",
							"            +roles_waiting_to_be_added_in_this_batch.length\r",
							"            +roles_waiting_to_be_removed_in_this_batch.length) >0 ) \r",
							"        {\r",
							"            this_team.members=readbody.members;  // we need to reload the members that are actually in the team into our members list so the current list is accurate\r",
							"            this_team.roles  =readbody.roles;\r",
							"\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Target team '+this_team.teamname+' users: '+this_team.members.length+' (yet to add: '+users_waiting_to_be_added_in_this_batch.length+' & remove: '+users_waiting_to_be_removed_in_this_batch.length+') member of: '+this_team.roles.length+' roles (yet to be added to: '+roles_waiting_to_be_added_in_this_batch.length+' & removed from: '+roles_waiting_to_be_removed_in_this_batch.length+')');\r",
							"            // need to test if chucksize is too large, if so we need to reduce it\r",
							"\r",
							"            if (number_of_user_changes_in_the_last_update>0) \r",
							"            {\r",
							"                // then our last update was for adding or removing users, so we need to change the chunk size accordingly\r",
							"                // however, there is a condition where we are removing users to allow updates to roles to be made, before we then start adding users in.\r",
							"                // it means that a chunk update may not have been 'full' of users, this in turn means the last update could had been very quick and we need to\r",
							"                // only adjust the chunk size when the last update was 'full'.\r",
							"\r",
							"                const max_users_in_single_PUT_request = 32767;\r",
							"                if (readbody.members.length>=max_users_in_single_PUT_request)\r",
							"                {\r",
							"                    postman.setNextRequest(null);\r",
							"                }\r",
							"                else if ( (number_of_user_changes_in_the_last_update === this_team.users_chunk_size) && (previouserrors ===0 ) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.users_chunk_size;\r",
							"                    if (pm.response.responseTime>270000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.6);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime>210000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.8);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 2);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<120000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 1.75);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 2 mins. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.users_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                    postman.setNextRequest(pm.info.requestName); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    postman.setNextRequest(pm.info.requestName); \r",
							"                };\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // our last update was for adding or removing roles, so we need to change the chunk size accordingly \r",
							"                // however we may only remove roles before adding them, so we need to check the chunk was 'full'\r",
							"                if ( (number_of_roles_changes_in_the_last_update === this_team.roles_chunk_size) && (previouserrors === 0) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.roles_chunk_size;\r",
							"                    if ( (pm.response.responseTime>270000)  && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if ( (pm.response.responseTime>210000) && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<20000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 20 secs. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<80000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min 30 secs. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.roles_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                };\r",
							"                postman.setNextRequest(pm.info.requestName); \r",
							"            };\r",
							"        }\r",
							"        else // the current team has been processed\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Target team '+this_team.teamname+' update complete it has '+readbody.members.length+' users and is a member of '+readbody.roles.length+' roles');\r",
							"            // we could delete the team if there's nothing in the team that needs to be updated, but we should only do that if we're at the end of the file\r",
							"            // since having the team in memory could prevent a re-read of the team later when processing the same file\r",
							"            \r",
							"            if ((pm.info.iteration===(pm.info.iterationCount-1)))\r",
							"   //         if (true)     // set this to true if you wanted to completely disable 'batch' mode, that is to delete the team for every user that is read from the file, only to potentially need to \r",
							"                            // re-read the team again for a different user. \r",
							"            {\r",
							"                // the current team has been processed, so we should now remove it from the array_of_teams\r",
							"                array_of_teams.splice(this_team_index,1);\r",
							"                pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"            };\r",
							"\r",
							"            // the code below is duplicated to the '400' if statement of 'CREATE team', so any changes made here will need to be duplicated there.\r",
							"            //\r",
							"            // we shall look at each team, held in the array, and see if any have users waiting to the added. Some teams may exist in memory without users waiting to be added (or removed from them),\r",
							"            // these teams are held in memory so we don't need to re-read the team just because that team has been updated.\r",
							"            let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"            array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"                function Users_to_add_for_this_team(team)\r",
							"                {\r",
							"                    total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                        +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                        +team.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                                        +team.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                                        +team.arrayofroles_waiting_to_be_removed_in_this_batch.length;\r",
							"                };\r",
							"\r",
							"\r",
							"            // update_based_on_entries_read_so_far will be true every 500 records have been read from the file, i.e. every 500 users\r",
							"            const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"            // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"            const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"            const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"            //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"            //\r",
							"            // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"            // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"            //\r",
							"            // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"            if ( update_teams_now )\r",
							"            {\r",
							"                // the row in the file we are processing *is* the last row and so we must now update the teams.\r",
							"                // lets first find a team that needs to be read and that also needs to be updated at all\r",
							"                const first_team_to_read_index = array_of_teams.findIndex(element => \r",
							"                                        (  element.need_to_read === true  )    \r",
							"                                        && (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                              + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                              + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                              + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 )    );\r",
							"\r",
							"                if ( first_team_to_read_index >= 0 )\r",
							"                {\r",
							"                    pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"                    postman.setNextRequest(\"READ target team\");\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"                    // this setNextRequest can now be UPDATE team, since we don't need to re-read the team\r",
							"                    const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                                    (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                        + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                        + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                        + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"                    if (first_team_to_update_index >= 0)\r",
							"                    {\r",
							"                        // there is a team that needs to be updated\r",
							"                        pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                        postman.setNextRequest(\"UPDATE target team\");\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update');\r",
							"                        postman.setNextRequest(null);\r",
							"                    };\r",
							"                };\r",
							"            }\r",
							"            else \r",
							"            {\r",
							"                // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"                // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"                //console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams needing an update');\r",
							"                postman.setNextRequest(null);\r",
							"            };\r",
							"\r",
							"        }\r",
							"    }  // end reponse is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }  // end if else\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{Target-accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{Target-x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],\r\n    \"id\": \"{{currentteam}}\",\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"meta\": {{meta}},\r\n    \"members\": {{members}},\r\n    \"roles\": {{roles}}\r\n}"
				},
				"url": {
					"raw": "https://{{Target-SACserviceFQDN}}/api/v1/scim/Groups/{{currentteam}}",
					"protocol": "https",
					"host": [
						"{{Target-SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{currentteam}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE target team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating target team '+pm.variables.get(\"currentteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE target team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new target access token');\r",
							"        postman.setNextRequest(\"GET target accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"        postman.setNextRequest(\"GET target accesstoken\");\r",
							"    }  //end if response is 403    \r",
							"else if (pm.response.code === 201)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated so skip to next user\r",
							"        postman.setNextRequest('READ target team');\r",
							"    }\r",
							"else if ((pm.response.code === 400) || (pm.response.code === 409))\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Can not create target team '+pm.variables.get(\"currenteam\")+' due to conflict, likely team folder already exists. Delete the team folder first. Login to SAP Analytics Cloud and select Menu-Files-System, then delete the folder matching the team name. This team will now be ignored and the user(s) will not be added to its membership. Teams cannot be created when the team or the team folder already exists. Team folder names are CaSe sensitive, as are team names when reading a team, but unlike team names when creating a team! This means reading a team (which is case sensitive) may not find a team, but when trying to create a team of the same name (which isn\\'t case sensitive), the team creation fails!  Response: '+ responseBody);\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === pm.variables.get(\"currentteam\"));\r",
							"        array_of_teams.splice(this_team_index,1)\r",
							"\r",
							"        // the code below is duplicated from the 'UPDATE team tests', so any changes made here will need to be duplicated there.\r",
							"        //\r",
							"        // we shall look at each team, held in the array, and see if any have users waiting to the added. Some teams may exist in memory without users waiting to be added (or removed from them),\r",
							"        // these teams are held in memory so we don't need to re-read the team just because that team has been updated.\r",
							"        let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"        array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"            function Users_to_add_for_this_team(team)\r",
							"            {\r",
							"                total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                    +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                    +team.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                                    +team.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                                    +team.arrayofroles_waiting_to_be_removed_in_this_batch.length;\r",
							"            };\r",
							"\r",
							"\r",
							"        \r",
							"        // update_based_on_entries_read_so_far will be true every 100 records have been read from the file, i.e. every 500 users\r",
							"        const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"        // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"        const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"        const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"        //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"        //\r",
							"        // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"        // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"        //\r",
							"        // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"        if ( update_teams_now )\r",
							"        {\r",
							"            // the row in the file we are processing *is* the last row and so we must now update the team.\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(element => element.need_to_read === true);\r",
							"\r",
							"            if ( first_team_to_read_index >= 0 )\r",
							"            {\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"                postman.setNextRequest(\"READ target team\");\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"                const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                                (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                    + element.arrayofusers_waiting_to_be_removed_in_this_batch.length\r",
							"                                    + element.arrayofroles_waiting_to_be_added_in_this_batch.length\r",
							"                                    + element.arrayofroles_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"                if (first_team_to_update_index >= 0)\r",
							"                {\r",
							"                    // there is a team that needs to be updated\r",
							"                    pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                    postman.setNextRequest(\"UPDATE target team\");\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update');\r",
							"                    postman.setNextRequest(null);\r",
							"                };\r",
							"            };\r",
							"        }\r",
							"        else \r",
							"        {\r",
							"            // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"            // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams needing an update');\r",
							"            postman.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{Target-accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{Target-x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\": [\r\n    \"urn:ietf:params:scim:schemas:core:2.0:Group\"\r\n  ],\r\n  \"id\": \"{{currentteam}}\",\r\n  \"displayName\": \"{{currentteam}} with Team Folder\"\r\n}"
				},
				"url": {
					"raw": "https://{{Target-SACserviceFQDN}}/api/v1/scim/Groups",
					"protocol": "https",
					"host": [
						"{{Target-SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET source accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting source access token');\r",
							"const SAC_platform = pm.variables.get(\"Source-SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"Source-oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"Source-oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET source accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(responseBody);\r",
							"        pm.environment.set(\"Source-accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"Source-x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        postman.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid source username or password: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ responseBody);\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=3;  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    postman.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "password",
							"value": "{{Source-Password}}",
							"type": "string"
						},
						{
							"key": "username",
							"value": "{{Source-Username}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{Source-SACtokenFQDN}}{{Source-oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{Source-SACtokenFQDN}}{{Source-oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "GET target accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting target access token');\r",
							"const SAC_platform = pm.variables.get(\"Target-SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"Target-oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"Target-oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET target accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(responseBody);\r",
							"        pm.environment.set(\"Target-accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"Target-x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        postman.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid target username or password: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ responseBody);\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=3;  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    postman.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "password",
							"value": "{{Target-Password}}",
							"type": "string"
						},
						{
							"key": "username",
							"value": "{{Target-Username}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{Target-SACtokenFQDN}}{{Target-oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{Target-SACtokenFQDN}}{{Target-oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}