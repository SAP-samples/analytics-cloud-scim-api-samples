{
	"info": {
		"_postman_id": "e04ae7e5-8d3a-4daf-bbeb-adba1885b8fd",
		"name": "SCIM 1131-U-CU-CUlem-Fcj-Es-SAML Create/update users (no roles, no teams)",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-e04ae7e5-8d3a-4daf-bbeb-adba1885b8fd?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "CREATE user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"\r",
							"\r",
							"//  Important! Be sure to create users correctly. Its far better to set them correctly at the time of creation rather than having to update users later\r",
							"//             You can either hard-code the values here (but then you have to repeat these changes everytime you use a new version of this sample script)\r",
							"//             So, it's better to spend time now to carefully set the values correctly in the Postman Environment.\r",
							"//             Sample '021 Update New User Default Setting' will set all these Environment values for you.\r",
							"//             That script will read a user (you provide the userid) and the values for that user are then used as the default values for all new users created.\r",
							"//             It means you don't need to edit any code :-) If you need different sets of users to be created with different default values, you can either use a different \r",
							"//             environment for different 'default values' or just re-run sample 021 to update the defaults with differnet values between creating different sets of users.\r",
							"\r",
							"const preferredlanguage                 =pm.environment.get(\"SCIM_NewUserDefault_preferredlanguage\");  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"\r",
							"// the active property is read-only and we can not set it via the API, so we shall ignore this property\r",
							"const dataaccesslanguage                =pm.environment.get(\"SCIM_NewUserDefault_dataaccesslanguage\"); // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"const dateformatting                    =pm.environment.get(\"SCIM_NewUserDefault_dateformatting\");     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"const timeformatting                    =pm.environment.get(\"SCIM_NewUserDefault_timeformatting\");     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"const numberformatting                  =pm.environment.get(\"SCIM_NewUserDefault_numberformatting\");   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"const cleanupnotificationsnumberofdays  =pm.environment.get(\"SCIM_NewUserDefault_cleanupnotificationsnumberofdays\"); // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin     =pm.environment.get(\"SCIM_NewUserDefault_systemnotificationsemailoptin\"); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin               =pm.environment.get(\"SCIM_NewUserDefault_marketingemailoptin\");                    // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"\r",
							"\r",
							"\r",
							"// In general do not edit below this line unless you want to 'fix' these values and ignore whats in the file.\r",
							"// You could remove the column/value from the file and fix the value here.\r",
							"// Any changes you make here are for 'new' users and so you will probably need to update the code in the 'READ user tests' and 'UPDATE user pre-request' for updating existing users\r",
							"const isconcurrent        =pm.iterationData.get(\"file_isconcurrent\");  // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE' \r",
							"const managerid           =pm.iterationData.get(\"file_managerid\");\r",
							"const displayname         =pm.iterationData.get(\"file_displayname\");\r",
							"const givenname           =pm.iterationData.get(\"file_givenname\");\r",
							"const familyname          =pm.iterationData.get(\"file_familyname\");\r",
							"// if you wish to make simple modifications to this script, do so only by changing the code ***ABOVE*** this line and keep the code ***BELOW*** unchanged.\r",
							"const userid              =pm.iterationData.get(\"file_userid\");\r",
							"const desiredemail        =pm.iterationData.get(\"file_email\");\r",
							"const domainname          =desiredemail.substr(desiredemail.search(\"@\"));\r",
							"const email               =userid.concat(domainname);\r",
							"let   username            ='';\r",
							"\r",
							"\r",
							"const corrected_roles_array = [];\r",
							"const corrected_teams_array = [];\r",
							"\r",
							"\r",
							"switch (pm.variables.get(\"SAMLSSO\"))\r",
							"{\r",
							"    case 'email':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on email. The 'email' value here is the userid@domainname. It means the userid created will be derived\r",
							"        // from the userid part which is what we want to achieve with this SAML variant of the sample scripts. \r",
							"        username=email;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on custom property. It means the userName (SAML Mapping) can be independent for the SAC userid and the email\r",
							"        // here we are setting the username to be the userid as specified in the data file (file_userid). This means the userid email and userName can all be different.\r",
							"        // the username will be updated later in the UPDATE user request later.\r",
							"        username   =userid;\r",
							"        // You could decide you do not want to specify the file_userid and instead use just the file_samlmapping. This is ok, but it will only work if the userid is in\r",
							"        // UPPER case and only has the support characters allowed for that userid field (unlike the userName SAML mapping which support more characters and is case sensitive.)\r",
							"        // if you wanted to do this, comment out the line above 'username=userid' and uncomment the next line:\r",
							"        // username   =pm.iterationData.get(\"file_samlmapping\");\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'userid':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on userid property. This means we must not use the email in the userName as an error will be returned.\r",
							"        // instead we will specify the userid alone\r",
							"        username   =userid;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default: \r",
							"    {\r",
							"        // i.e. SAP Analytics Cloud is using the default IdP, which means the username can be the email or just the userid. If an email address is used, the @domain is dropped\r",
							"        // from ther userName when the user is created.\r",
							"        username   =userid;\r",
							"        break;\r",
							"    }\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"\r",
							"\r",
							"pm.variables.set(\"userid\",userid);\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"givenname\",givenname);\r",
							"pm.variables.set(\"familyname\",familyname);\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"email\",email);                   // string that is used inside a JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"roles\",JSON.stringify(corrected_roles_array));   // JSON array of SAC roles\r",
							"// pm.variables.set(\"groups\",JSON.stringify(corrected_teams_array)); // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                                             //             This entry will be ignored until then but its set here, albeit commented out, so it will work when supported.\r",
							"                                                             //             Once SAP Analytics Cloud supports assigning groups (teams) upon user creation, this line will need to un-commented\r",
							"                                                             //             and an entry into the Body will need to be added:  \"groups\": {{groups}},\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"managerid\",managerid); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,201,401,403,409])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 409)\r",
							"{\r",
							"    // there is a conflict and so the user must already exist\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': User already exists. Will now attempt to update user: '+pm.variables.get(\"userid\"));\r",
							"    pm.execution.setNextRequest(\"READ user\");\r",
							"}\r",
							"else if ( (pm.response.code === 200) || (pm.response.code === 201) )\r",
							"{\r",
							"    // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"    pm.variables.set(\"ContinuousErrors\",0);\r",
							"    pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"    const readbody    = JSON.parse(pm.response.text());\r",
							"    const userid_created_in_SAC=readbody.id;\r",
							"    const requested_userid=pm.variables.get(\"userid\");\r",
							"\r",
							"    switch (pm.variables.get(\"SAMLSSO\"))\r",
							"    {\r",
							"\r",
							"        default:\r",
							"        {\r",
							"            if (userid_created_in_SAC===requested_userid)\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': User created: '+userid_created_in_SAC);\r",
							"                pm.execution.setNextRequest(\"READ user\");  // this is necessary so the email gets updated to the correct email address\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': User created but with different user id than requested. This can occur when a different e-mail is specified for same user id. Will now delete this duplicate user and attempt to update the email address. Requested: '+requested_userid+' but created a duplicate: '+userid_created_in_SAC);\r",
							"                pm.variables.set(\"DuplicateUser\",userid_created_in_SAC)\r",
							"                pm.execution.setNextRequest(\"DELETE duplicate user\");\r",
							"            };   \r",
							"        }\r",
							"    };\r",
							"\r",
							"\r",
							" \r",
							"}\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        const requested_userid=pm.variables.get(\"userid\");\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors when creating user '+requested_userid+'. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected when creating user '+requested_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error when creating user '+requested_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\":[\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n  \"userName\": \"{{username}}\",\r\n  \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n  \"name\": {\r\n     \"givenName\":\"{{givenname}}\",\r\n     \"familyName\":\"{{familyname}}\"\r\n  },\r\n  \"displayName\": \"{{displayname}}\",\r\n  \"active\": true,\r\n  \"emails\": [\r\n    {\r\n      \"value\": \"{{email}}\",\r\n      \"type\": \"work\",\r\n      \"primary\": true\r\n    }\r\n  ],\r\n  \"roles\": {{roles}},\r\n  \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n    \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n    \"dateFormatting\": \"{{dateformatting}}\",\r\n    \"timeFormatting\": \"{{timeformatting}}\",\r\n    \"numberFormatting\": \"{{numberformatting}}\",\r\n    \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n    \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n    \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n    \"isConcurrent\": {{isconcurrent}}\r\n  },\r\n  \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n    \"manager\": {\r\n      \"managerId\": \"{{managerid}}\"\r\n    }\r\n  }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users"
					]
				}
			},
			"response": []
		},
		{
			"name": "DELETE duplicate user",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"DELETE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([204,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if ( pm.response.code === 404 )\r",
							"{\r",
							"    // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"    pm.variables.set(\"ContinuousErrors\",0);\r",
							"    pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Duplicate user already deleted: '+pm.variables.get(\"DuplicateUser\"));\r",
							"    pm.execution.setNextRequest(\"READ user\");\r",
							"}\r",
							"else if ( pm.response.code === 204 )\r",
							"{\r",
							"    // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"    pm.variables.set(\"ContinuousErrors\",0);\r",
							"    pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Duplicate user deleted: '+pm.variables.get(\"DuplicateUser\"));\r",
							"    pm.execution.setNextRequest(\"READ user\");\r",
							"}\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Deleting user: '+ pm.variables.get(\"DuplicateUser\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "DELETE",
				"header": [
					{
						"key": "id",
						"value": "I049477V3",
						"type": "text",
						"disabled": true
					},
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Authorization",
						"value": "Bearer ",
						"type": "text",
						"disabled": true
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/{{DuplicateUser}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{DuplicateUser}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // No user so we can't update the user. Abort this entry\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to update user '+pm.iterationData.get(\"file_userid\")+'. This means the previous 409 was caused by a conflict of email address, not because the user already exists');\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated and the user does exist so we can now read the properties that make up this user\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (schemas.includes('urn:ietf:params:scim:schemas:core:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:enterprise:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0')\r",
							"                          );  // the schema read must contain these definitions, otherwise we could be PUTting back missing properties\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"        {\r",
							"            pm.expect(validschema);\r",
							"        }\r",
							"        );\r",
							"\r",
							"        if (validschema)\r",
							"            {            \r",
							"                // reading the current user value of the user properties held in SAP Analytics Cloud. \r",
							"                const SACvalueemail  = readbody.emails[0].value;  // we assume there is only 1 email address in the array and the one we want is the first listed.\r",
							"                // need to grab the user custom parameters next...\r",
							"                const customparams   = readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"                // .. then we can get the current value and turn it to a String to allow a comparision with the desired setting\r",
							"                const SACvalueisconcurrent     = customparams.isConcurrent.toString(); // we need to change this boolean value to a string so the compare works\r",
							"                const SACenterpriseproperties  = readbody[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"                const SACvaluemanagerid        = SACenterpriseproperties.manager.managerId;\r",
							"\r",
							"                // read the desired values\r",
							"                // we can not update the givenname, familyname or displayname\r",
							"                // this script can not update the email address, since the CREATE user request is made before this, and that request would have created a new user if the email\r",
							"                // was different from the username.\r",
							"                // it means this script can only update the isConcurrent and the managerId\r",
							"                const file_isconcurrent        =pm.iterationData.get(\"file_isconcurrent\").toString(); // the desired value from the file. \r",
							"                                                                                                // we need to change this boolean value to a string so the compare works\r",
							"                const file_email               =pm.iterationData.get(\"file_email\");\r",
							"                const file_managerid           =pm.iterationData.get(\"file_managerid\");\r",
							"                \r",
							"                let updaterequired = false;\r",
							"                switch (pm.variables.get(\"SAMLSSO\"))\r",
							"                {   \r",
							"\r",
							"                    case 'userid':\r",
							"                    // As we are using custom saml mapping then we need to additionally check if the userName property needs to be updated compared with the file_samlmapping property\r",
							"                    // importantly we do NOT check for email, as email is not updatable when SAML SSO is userid\r",
							"                    {\r",
							"                        updaterequired = ( (SACvalueisconcurrent  != file_isconcurrent)\r",
							"                                        || (SACvaluemanagerid     != file_managerid)     );\r",
							"                        break;\r",
							"                    }\r",
							"\r",
							"                    case 'email':\r",
							"                    // As we are using custom saml mapping then we need to additionally check if the userName property needs to be updated compared with the file_samlmapping property\r",
							"                    {\r",
							"                        updaterequired = ( (SACvalueisconcurrent  != file_isconcurrent)\r",
							"                                        || (SACvalueemail         != file_email)\r",
							"                                        || (SACvaluemanagerid     != file_managerid)     );\r",
							"                        break;\r",
							"                    }\r",
							"\r",
							"                    case 'custom':\r",
							"                    // As we are using custom saml mapping then we need to additionally check if the userName property needs to be updated compared with the file_samlmapping property\r",
							"                    // importantly we do NOT check for email, as email is not updatable when SAML SSO is custom\r",
							"                    {\r",
							"                        const file_samlmapping =pm.iterationData.get(\"file_samlmapping\");\r",
							"                        const SACcaluesamlmapping = readbody.userName;\r",
							"\r",
							"                        updaterequired = ( (SACvalueisconcurrent  != file_isconcurrent)\r",
							"                                        || (SACvaluemanagerid     != file_managerid)\r",
							"                                        || (SACcaluesamlmapping   != file_samlmapping)     );\r",
							"                        break;\r",
							"                    }\r",
							"\r",
							"                    default:\r",
							"                    // we don't need to check the saml mapping property\r",
							"                    {\r",
							"                        updaterequired = ( (SACvalueisconcurrent  != file_isconcurrent)\r",
							"                                        || (SACvalueemail         != file_email)\r",
							"                                        || (SACvaluemanagerid     != file_managerid)     );\r",
							"                        break;\r",
							"                    }\r",
							"                } \r",
							"                // updaterequries will be true or false. It will be true if the values are different, false otherwise\r",
							"                if (updaterequired)\r",
							"                    {\r",
							"                        pm.variables.set(\"readbody\", readbody)\r",
							"                        pm.execution.setNextRequest(); // let Postman run the next call to UPDATE user\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': User already set correctly. Skipping user '+ pm.iterationData.get(\"file_userid\"));\r",
							"                        pm.execution.setNextRequest(null); // skip this row in the file and read the next row\r",
							"                    }\r",
							"                 ;\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schema version and it could corrupt your user. Aborting!');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            }\r",
							"        ;  // end if validschema\r",
							"    }  // end if response === 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"// we need to read the current properties of the user,\r",
							"// change the properties we want to and *then* we can PUT back all the user properties correctly having only changed the properties we need to change\r",
							"const readbody            =pm.variables.get(\"readbody\"); // reading the response body of the previous call that read the user\r",
							"\r",
							"const preferredlanguage   =readbody.preferredLanguage;  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"\r",
							"const meta                =readbody.meta;    // changes to the meta isn't allowed\r",
							"const name                =readbody.name;    // changes to the name isn't allowed\r",
							"const displayname         =readbody.displayName; // string value\r",
							"const active              =readbody.active; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const emails              =readbody.emails; // JSON array of 'value','type','primary'\r",
							"emails[0].value           =pm.iterationData.get(\"file_email\");\r",
							"const photos              =readbody.photos; // JSON array\r",
							"const roles               =readbody.roles;  // JSON array of SAC roles\r",
							"const groups              =readbody.groups; // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                          //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"const customparams        =readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"const dataaccesslanguage  =customparams.dataAccessLanguage; // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"const dateformatting      =customparams.dateFormatting;     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"const timeformatting      =customparams.timeFormatting;     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"const numberformatting    =customparams.numberFormatting;   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"const cleanupnotificationsnumberofdays=customparams.cleanUpNotificationsNumberOfDays; // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin=customparams.systemNotificationsEmailOptIn; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin =customparams.marketingEmailOptIn;                    // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const isconcurrent        =pm.iterationData.get(\"file_isconcurrent\");  // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE' \r",
							"const extension           =readbody[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"const manager             =extension.manager; // JSON array\r",
							"manager.managerId         =pm.iterationData.get(\"file_managerid\");\r",
							"\r",
							"// we need to manage the userName property if using SAML SSO mapping on email address and custom\r",
							"let   username            ='';\r",
							"switch (pm.variables.get(\"SAMLSSO\"))\r",
							"{\r",
							"    case 'email':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on email. When we update the email, we must also update the userName.\r",
							"        username=emails[0].value;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        // We are using custom SAML SSO mapping so we must read the custom value from the data file\r",
							"        username   =pm.iterationData.get(\"file_samlmapping\");\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default: \r",
							"    {\r",
							"        // i.e. SAP Analytics Cloud is using the default IdP or using a custom IdP Mapping on UserID. When this is the case, the userName can NOT be updated.\r",
							"        username = readbody.userName\r",
							"        break;\r",
							"    }\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"//\r",
							"// if you wish to make simple modifications to this script, do so only by changing the code ***ABOVE*** this line and keep the code ***BELOW*** unchanged.\r",
							"//\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"id\",readbody.id);\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"meta\",JSON.stringify(meta));\r",
							"pm.variables.set(\"name\",JSON.stringify(name));     // JSON array of givenName and familyName\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"active\",active);                 // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"emails\",JSON.stringify(emails)); // JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"photos\",JSON.stringify(photos)); // JSON array\r",
							"pm.variables.set(\"roles\",JSON.stringify(roles));   // JSON array of SAC roles\r",
							"pm.variables.set(\"groups\",JSON.stringify(groups)); // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                                             //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"manager\",JSON.stringify(manager)); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 400)\r",
							"    {\r",
							"        // A bad request was made and this is a very rare event but it will occur when:\r",
							"        //    The user exists but has a different email than specified in the data file (i.e the email needs to be updated)\r",
							"        //    The initial CREATE user (POST /Users) returned a 502 (Which was actually sucessful, but it created a duplicate user because the userid and email didn't match)\r",
							"        //    This mismatch wasn't (and can't be) picked up by the 502 response.\r",
							"        //    The CREATE user request was repeated and this returned a 409 because the userid and email clash (but its clashing with a duplicate userid, not the right userid)\r",
							"        //    Then upon attempting to update the 'right' user with the new email, it returns a 400, because it can't update the 'right' users email with the same email as the\r",
							"        //    duplicated user. So we now need to go and search for that duplicated user, delete it, and then return here to update it\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User '+ pm.iterationData.get(\"file_userid\") +' could not be updated. Assuming clash of email with a duplicated user caused by a repeated CREATE user request')\r",
							"        pm.execution.setNextRequest(\"SEARCH duplicate user\");\r",
							"        //    Confusingly, there is also another condition where a 400 can occur. This is when there is not a clash of email, but a clash of userName.\r",
							"        //    This can occur when the SAML SSO is set to custom (since when anything else, the userName is either the same as the userID, or the email)\r",
							"        //    This condition is tested and captured in the 'search duplicate user' tests.\r",
							"    }  //end if response is 400\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we updated the user so we can now proceed to the next row in the file. \r",
							"        // we don't need to let Postman run to GET accesstoken\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User '+ pm.iterationData.get(\"file_userid\") +' updated');\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n    \"userName\": \"{{username}}\",\r\n    \"id\": \"{{id}}\",\r\n    \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n    \"meta\": {{meta}},\r\n    \"name\": {{name}},\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"active\": {{active}},\r\n    \"emails\": {{emails}},\r\n    \"photos\": {{photos}},\r\n    \"roles\": {{roles}},\r\n    \"groups\": {{groups}},\r\n    \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n        \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n        \"dateFormatting\": \"{{dateformatting}}\",\r\n        \"timeFormatting\": \"{{timeformatting}}\",\r\n        \"numberFormatting\": \"{{numberformatting}}\",\r\n        \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n        \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n        \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n        \"isConcurrent\": {{isconcurrent}}\r\n    },\r\n    \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n        \"manager\": {{manager}}\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "SEARCH duplicate user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const desired_email = pm.iterationData.get(\"file_email\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Searching for duplicate user with email: '+desired_email);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"pm.variables.set(\"desired_email\",desired_email);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"SEARCH duplicate user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        const readbody      = JSON.parse(pm.response.text());\r",
							"        const total_results = readbody.totalResults;\r",
							"        const desired_email = pm.variables.get(\"desired_email\");\r",
							"        if (total_results>0)\r",
							"        {\r",
							"            const userid_found_by_email = readbody.Resources[0].id;\r",
							"            const desired_userid        = pm.iterationData.get(\"file_userid\");\r",
							"            if  (userid_found_by_email != desired_userid)\r",
							"            {\r",
							"                // then we have found the user that was created as a duplicate.\r",
							"                // the user was created as a duplicate because the CREATE user (POST to /Users) was made with a userid and an email that did not match, i.e. the email was different\r",
							"                // but the user was still created, albeit with a different userid than we requested.\r",
							"                // So we have now found the user id of the desired email (the user that was created)\r",
							"                pm.variables.set(\"ContinuousErrors\",0);\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': Duplicated user found identified by email: '+userid_found_by_email+' '+desired_email+'. Will now attempt to delete this duplicate user allowing the correct users email address can be updated: '+desired_userid);\r",
							"                pm.variables.set(\"DuplicateUser\",userid_found_by_email);\r",
							"                pm.execution.setNextRequest(\"DELETE duplicate user\");\r",
							"            }\r",
							"            else //we have more than 0 results but the first user is the same as the desired user, we don't want to delete this user\r",
							"            {\r",
							"                if ( (total_results===1) && (pm.variables.get(\"SAMLSSO\")==='custom') )\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': A single user has been found by searching on the email: '+desired_email+'. This means the previous failure to update the user was likely to be a clash of userName (SAML mapping) with another user and not a clash of email. It is likely this user now has a null value for userName. userName is: '+readbody.Resources[0].userName);\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': The user could not be found by searching on the email: '+desired_email+'. Users found having this email: '+total_results);\r",
							"                }\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"        }\r",
							"        else  // results are 0\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': The user could not be found by searching on the email: '+desired_email+'. Users found having this email: '+total_results);\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\r\n     \"filter\": \r\n     \"email eq \\\"{{desired_email}}\\\"\", \r\n     \"startIndex\": 1,\r\n     \"count\": 1\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/.search",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						".search"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"   pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "READ users for authorisation",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading users to obtain authorisation');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Authorised\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"if ( (pm.response.code === 200) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        const total_users_in_this_SAC_service= readbody.totalResults;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised. This SAP Analytics Cloud Service has '+total_users_in_this_SAC_service+' users');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        pm.execution.setNextRequest(\"CREATE user\");\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/?startIndex=1&count=1",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						""
					],
					"query": [
						{
							"key": "startIndex",
							"value": "1"
						},
						{
							"key": "count",
							"value": "1"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}