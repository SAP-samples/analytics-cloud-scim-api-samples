{
	"info": {
		"_postman_id": "46569e2f-2406-4c6d-8d85-25d892fe11bc",
		"name": "SCIM 1456-TU-U-Upddtn-Fj-Es-Update User DateTimeNumFormat DataAccessLang",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-46569e2f-2406-4c6d-8d85-25d892fe11bc?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "READ team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team: '+ pm.iterationData.get(\"file_team\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401])\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // No user so we can't update the user. Abort this entry\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Team not found '+pm.iterationData.get(\"file_team\"));\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // Team is found so we can read the team members and then call READ user for each member of the team\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        \r",
							"        // the team might be empty in which case we can't update any members and we should proceed with the next entry in the file\r",
							"        if (!readbody.members.length)\r",
							"        {      \r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': No team members found in this team '+pm.iterationData.get(\"file_team\"));\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+readbody.members.length+ ' users found in team '+pm.iterationData.get(\"file_team\"));\r",
							"            // the team has members so we can set 'currentuser' to the first value in the JSON array of members\r",
							"            // and store the remaining team members in teammembers\r",
							"            const currentuser = readbody.members.shift();\r",
							"            const currentuserref = currentuser[\"$ref\"];\r",
							"            pm.variables.set(\"currentuserref\",currentuserref);\r",
							"            pm.variables.set(\"teammembers\",readbody.members);\r",
							"            pm.execution.setNextRequest();\r",
							"        }\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading user: '+ pm.variables.get(\"currentuserref\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        \r",
							"        // No user so we can't update the user. Abort this entry\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': User not found '+pm.variables.get(\"currentuserref\"));\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false); // we have now authorised this session, albeit with a 404 not found!\r",
							"        const members = pm.variables.get(\"teammembers\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Users left to process in this team '+ members.length);\r",
							"        if (members.length>0) \r",
							"            {\r",
							"                const currentuser = members.shift();\r",
							"                const currentuserref = currentuser[\"$ref\"];\r",
							"                pm.variables.set(\"currentuserref\",currentuserref);\r",
							"                pm.variables.set(\"teammembers\", members);\r",
							"                pm.execution.setNextRequest(pm.info.requestName); // repeat the call, but now with the next user\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': All users in team '+ pm.iterationData.get(\"file_team\") + ' processed');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            }\r",
							"        ; // end if any members left to process\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        pm.execution.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated and the user does exist so we can now read the properties that make up this user\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (schemas.includes('urn:ietf:params:scim:schemas:core:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:enterprise:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0')\r",
							"                          );  // the schema read must contain these definitions, otherwise we could be PUTting back missing properties\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"        {\r",
							"            pm.expect(validschema);\r",
							"        }\r",
							"        );\r",
							"\r",
							"        if (validschema)\r",
							"            {            \r",
							"                // reading the current user value of the user properties held in SAP Analytics Cloud. \r",
							"                const SACvaluepreferredlanguage = readbody.preferredLanguage;\r",
							"                // need to grab the user custom parameters next...\r",
							"                const customparams   = readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"                // .. then we can get the current value and turn it to a String to allow a comparision with the desired setting\r",
							"                const SACvaluedataaccesslanguage = customparams.dataAccessLanguage;\r",
							"                const SACvaluedateformatting = customparams.dateFormatting;\r",
							"                const SACvaluetimeformatting = customparams.timeFormatting;\r",
							"                const SACvaluenumberformatting = customparams.numberFormatting;\r",
							"                const file_preferredlanguage = pm.iterationData.get(\"file_preferredlanguage\");  // the desired value from the file\r",
							"                const file_dataaccesslanguage = pm.iterationData.get(\"file_dataaccesslanguage\");// the desired value from the file\r",
							"                const file_dateformatting = pm.iterationData.get(\"file_dateformatting\");        // the desired value from the file\r",
							"                const file_timeformatting = pm.iterationData.get(\"file_timeformatting\");        // the desired value from the file\r",
							"                const file_numberformatting = pm.iterationData.get(\"file_numberformatting\");    // the desired value from the file\r",
							"                const updaterequired = ( (SACvaluepreferredlanguage != file_preferredlanguage)  \r",
							"                                    || (SACvaluedataaccesslanguage  != file_dataaccesslanguage) \r",
							"                                    || (SACvaluedateformatting      != file_dateformatting) \r",
							"                                    || (SACvaluetimeformatting      != file_timeformatting) \r",
							"                                    || (SACvaluenumberformatting    != file_numberformatting) );\r",
							"                // updaterequries will be true or false. It will be true if the values are different, false otherwise\r",
							"                if (updaterequired)\r",
							"                    {\r",
							"                        pm.variables.set(\"readbody\", readbody)\r",
							"                        pm.execution.setNextRequest(); // let Postman run the next call to UPDATE user license type\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': User already set correctly. Skipping user '+ pm.variables.get(\"currentuserref\"));\r",
							"                        const members = pm.variables.get(\"teammembers\");\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Users left to process in this team '+ members.length);\r",
							"                        if (members.length>0) \r",
							"                            {\r",
							"                                const currentuser = members.shift();\r",
							"                                const currentuserref = currentuser[\"$ref\"];\r",
							"                                pm.variables.set(\"currentuserref\",currentuserref);\r",
							"                                pm.variables.set(\"teammembers\", members);\r",
							"                                pm.execution.setNextRequest(pm.info.requestName); // repeat the call, but now with the next user\r",
							"                            }\r",
							"                        else\r",
							"                            {\r",
							"                                console.log(pm.info.requestName+' '+pm.info.eventName+': All users in team '+ pm.iterationData.get(\"file_team\") + ' processed');\r",
							"                                pm.execution.setNextRequest(null);\r",
							"                            }\r",
							"                        ; // end if any members left to process\r",
							"                    }\r",
							"                 ; // end if updaterequired\r",
							"            }\r",
							"        else  // not a valid schema\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schema version and it could corrupt your user. Aborting!');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            }\r",
							"        ;  // end if validschema\r",
							"    }  // end if response === 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"            pm.variables.set(\"ContinuousErrors\",0);\r",
							"            const members = pm.variables.get(\"teammembers\");\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Users left to process in this team '+ members.length);\r",
							"            if (members.length>0) \r",
							"                {\r",
							"                    const currentuser = members.shift();\r",
							"                    const currentuserref = currentuser[\"$ref\"];\r",
							"                    pm.variables.set(\"currentuserref\",currentuserref);\r",
							"                    pm.variables.set(\"teammembers\", members);\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); // repeat the call, but now with the next user\r",
							"                }\r",
							"            else\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': All users in team '+ pm.iterationData.get(\"file_team\") + ' processed');\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }\r",
							"            ; // end if any members left to process\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;  // end of errors >= maxerrors\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}{{currentuserref}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}{{currentuserref}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE user formats language",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating user: '+ pm.variables.get(\"currentuserref\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"// we need to read the current properties of the user,\r",
							"// change the properties we want to and *then* we can PUT back all the user properties correctly having only changed the properties we need to change\r",
							"const readbody            =pm.variables.get(\"readbody\"); // reading the response body of the previous call that read the user\r",
							"const username            =readbody.userName; // changes to the username isn't allowed unless using custom SAML SSO mapping on email or custom mapping\r",
							"\r",
							"const preferredlanguage   =pm.iterationData.get(\"file_preferredlanguage\");  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"//    this script is updating the preferredLanguage property so we are setting it here to be the value from the file in the column file_preferredlanguage\r",
							"//    however, if we wanted to keep the existing preferredLanguage property value then the code would be:\r",
							"//var preferredlanguage   =readbody.preferredLanguage;  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"//    you'd need to un-comment the line above to keep the existing preferredLanguage property value. Handy if you wanted to update this script to update a different property!\r",
							"\r",
							"\r",
							"const meta                =readbody.meta;    // changes to the meta isn't allowed\r",
							"const name                =readbody.name;    // changes to the name isn't allowed\r",
							"const displayname         =readbody.displayName; // string value\r",
							"const active              =readbody.active; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const emails              =readbody.emails; // JSON array of 'value','type','primary'\r",
							"const photos              =readbody.photos; // JSON array\r",
							"const roles               =readbody.roles;  // JSON array of SAC roles\r",
							"const groups              =readbody.groups; // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                          //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"const customparams        =readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"\r",
							"const dataaccesslanguage  =pm.iterationData.get(\"file_dataaccesslanguage\"); // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"//    this script is updating the dataaccesslanguage property so we are setting it here to be the value from the file in the column file_dataaccesslanguage\r",
							"//    however, if we wanted to keep the existing dataaccesslanguage property value then the code would be:\r",
							"//const dataaccesslanguage  =customparams.dataAccessLanguage; // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"//    you'd need to un-comment the line above to keep the existing dataaccesslanguage property value. Handy if you wanted to update this script to update a different property!\r",
							"\r",
							"const dateformatting      =pm.iterationData.get(\"file_dateformatting\");     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"//    this script is updating the dateformatting property so we are setting it here to be the value from the file in the column file_dateformatting\r",
							"//    however, if we wanted to keep the existing dateformatting property value then the code would be:\r",
							"//const dateformatting      =customparams.dateFormatting;     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"//    you'd need to un-comment the line above to keep the existing dateformatting property value. Handy if you wanted to update this script to update a different property!\r",
							"\r",
							"const timeformatting      =pm.iterationData.get(\"file_timeformatting\");     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"//    this script is updating the file_timeformatting property so we are setting it here to be the value from the file in the column file_timeformatting\r",
							"//    however, if we wanted to keep the existing file_timeformatting property value then the code would be:\r",
							"//const timeformatting      =customparams.timeFormatting;     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"//    you'd need to un-comment the line above to keep the existing file_timeformatting property value. Handy if you wanted to update this script to update a different property!\r",
							"\r",
							"const numberformatting    =pm.iterationData.get(\"file_numberformatting\");   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"//    this script is updating the file_numberformatting property so we are setting it here to be the value from the file in the column file_numberformatting\r",
							"//    however, if we wanted to keep the existing file_numberformatting property value then the code would be:\r",
							"//const numberformatting    =customparams.numberFormatting;   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"//    you'd need to un-comment the line above to keep the existing file_numberformatting property value. Handy if you wanted to update this script to update a different property!\r",
							"\r",
							"\r",
							"const cleanupnotificationsnumberofdays=customparams.cleanUpNotificationsNumberOfDays; // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin=customparams.systemNotificationsEmailOptIn; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin =customparams.marketingEmailOptIn;                    // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const isconcurrent        =customparams.isConcurrent;                           // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"\r",
							"const extension           =readbody[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"const manager             =extension.manager; // JSON array\r",
							"\r",
							"//\r",
							"// if you wish to make simple modifications to this script, do so only by changing the code ***ABOVE*** this line and keep the code ***BELOW*** unchanged.\r",
							"//\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"id\",readbody.id);\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"meta\",JSON.stringify(meta));\r",
							"pm.variables.set(\"name\",JSON.stringify(name));     // JSON array of givenName and familyName\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"active\",active);                 // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"emails\",JSON.stringify(emails)); // JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"photos\",JSON.stringify(photos)); // JSON array\r",
							"pm.variables.set(\"roles\",JSON.stringify(roles));   // JSON array of SAC roles\r",
							"pm.variables.set(\"groups\",JSON.stringify(groups)); // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                                             //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"manager\",JSON.stringify(manager)); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ user\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        \r",
							"        // we updated the user so we can now proceed to the next user in the list if we have any users left! \r",
							"        // otherwise, when we have no users left in the list, we should move to the next entry in the file. \r",
							"        // we don't need to let Postman run to GET accesstoken\r",
							"\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User '+ pm.variables.get(\"currentuserref\") +' updated');\r",
							"\r",
							"        const members = pm.variables.get(\"teammembers\");\r",
							"\r",
							"        if (members.length>0) \r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Users left to process in this team '+ members.length);\r",
							"                const currentuser = members.shift();\r",
							"                const currentuserref = currentuser[\"$ref\"];\r",
							"                pm.variables.set(\"currentuserref\",currentuserref);\r",
							"                pm.variables.set(\"teammembers\", members);\r",
							"                pm.execution.setNextRequest(\"READ user\"); // repeat the call, but now with the next user\r",
							"                                                     // Postman isn't really designed for thousands and thousands of requests within a single iteration\r",
							"                                                     // it means Postman may crash and this typically happens when a team has about 5000 users or more.\r",
							"                                                     // You will then need to either make the team smaller, or revert to the sample script that reads a row per user\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': All users in team '+ pm.iterationData.get(\"file_team\") + ' processed');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            }\r",
							"        ; //end if any members left to process\r",
							"    }  // end if response === 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        const members = pm.variables.get(\"teammembers\");\r",
							"        if (members.length>0) \r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Users left to process in this team '+ members.length);\r",
							"                const currentuser = members.shift();\r",
							"                const currentuserref = currentuser[\"$ref\"];\r",
							"                pm.variables.set(\"currentuserref\",currentuserref);\r",
							"                pm.variables.set(\"teammembers\", members);\r",
							"                pm.execution.setNextRequest(\"READ user\"); // repeat the call, but now with the next user\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': All users in team '+ pm.iterationData.get(\"file_team\") + ' processed');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            }\r",
							"        ;\r",
							"   }  // end if else\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n    \"userName\": \"{{username}}\",\r\n    \"id\": \"{{id}}\",\r\n    \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n    \"meta\": {{meta}},\r\n    \"name\": {{name}},\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"active\": {{active}},\r\n    \"emails\": {{emails}},\r\n    \"photos\": {{photos}},\r\n    \"roles\": {{roles}},\r\n    \"groups\": {{groups}},\r\n    \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n        \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n        \"dateFormatting\": \"{{dateformatting}}\",\r\n        \"timeFormatting\": \"{{timeformatting}}\",\r\n        \"numberFormatting\": \"{{numberformatting}}\",\r\n        \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n        \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n        \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n        \"isConcurrent\": {{isconcurrent}}\r\n    },\r\n    \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n        \"manager\": {{manager}}\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}{{currentuserref}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}{{currentuserref}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		}
	]
}