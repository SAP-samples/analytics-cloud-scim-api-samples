{
	"info": {
		"_postman_id": "ac02ad51-5a41-4fe6-a4dd-5242e97e2609",
		"name": "SCIM 2452-TU-U-Ua-Fcj-Es-Update Team Active status",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-ac02ad51-5a41-4fe6-a4dd-5242e97e2609?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "READ team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    \r",
							"    let  UsersNeedToBeUpdated       = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"    if (!UsersNeedToBeUpdated)      {UsersNeedToBeUpdated = []};\r",
							"    const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"    if (UsersNeedToBeUpdated.length>0)\r",
							"    {\r",
							"        if (use_scim_bulk_operations)\r",
							"        {\r",
							"            return \"UPDATE user active status (Bulk)\";\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            return \"UPDATE user active status\";\r",
							"        }\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new tokens: accesstoken & x-csrf-token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const team_displayName  = pm.iterationData.get(\"file_team\");\r",
							"        const readbody          = JSON.parse(pm.response.text());\r",
							"        const totalResults      = readbody.totalResults;\r",
							"\r",
							"        switch (totalResults)\r",
							"        {\r",
							"            case 0:\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+\": Could not find a team named \"+team_displayName+\". Aborting this team.\");\r",
							"                pm.execution.setNextRequest(null);\r",
							"                break;\r",
							"            }\r",
							"            case 1:\r",
							"            {\r",
							"                const team  =readbody.Resources.filter( team => team.displayName===team_displayName )[0];\r",
							"                let number_of_team_members = ((team.members === null) || (!team.members)) ? 0 : team.members.length;\r",
							"                if (number_of_team_members===0)\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+\": Team \"+team_displayName+\" found but there are no members in this team, so no users can be updated. Aborting this team.\");\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+\": Team \"+team_displayName+\" found. It has \"+number_of_team_members+\" members.\");\r",
							"                    pm.variables.set(\"UsersNeedToBeUpdated\",team.members);\r",
							"                    pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                }\r",
							"                \r",
							"                break;\r",
							"            }\r",
							"            default:\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+\": There is more than one team with the same name, \"+team_displayName+\", which means it's uncertain which team should be updated. Aborting this team.\");\r",
							"                pm.execution.setNextRequest(null);\r",
							"                break;\r",
							"            }\r",
							"        }\r",
							"        break;\r",
							"    }   // end case response is 200\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"}; // end swtich pm.response.code"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const team_displayName    = pm.iterationData.get(\"file_team\");\r",
							"\r",
							"pm.variables.set(\"filter_for_team\",\r",
							"      \"displayName eq \\\\\\\"\"\r",
							"    + team_displayName \r",
							"    + \"\\\\\\\" \" );\r",
							"\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team '+team_displayName);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n     \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\r\n     \"filter\":\r\n        \"{{filter_for_team}}\"\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Groups/.search",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Groups",
						".search"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE user active status",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const active               = pm.iterationData.get(\"file_active\"); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"    const UsersNeedToBeUpdated = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"    const user_needing_update  = UsersNeedToBeUpdated.slice(0,1)[0];\r",
							"    const active_status        = (active.toString() === 'true') ? 'activated' : 'deactivated';\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Updating user '+user_needing_update.value+' \\''+user_needing_update.display+'\\' to be '+active_status);\r",
							"\r",
							"    const Operations=new Array();\r",
							"\r",
							"    Operations.push({\r",
							"        \"op\": \"replace\",\r",
							"        \"path\": \"active\",\r",
							"        \"value\": active\r",
							"    });\r",
							"\r",
							"    const user_patch_request=\r",
							"    {\r",
							"        \"schemas\": [\r",
							"            \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\r",
							"        ],\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"    pm.variables.set(\"user_uuid\",user_needing_update.value);\r",
							"    pm.variables.set(\"user_request_body\",JSON.stringify(user_patch_request));\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user active status\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429,400])\r",
							"    }\r",
							");\r",
							"\r",
							"const active         = pm.iterationData.get(\"file_active\"); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const active_status  = (active.toString() === 'true') ? 'activated' : 'deactivated';\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"    \r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 400:\r",
							"    {\r",
							"        // \r",
							"        // we are trapping a condition here when the PATCH request returns a 400 typically with a pm.response.text():\r",
							"        //  {\"schemas\":[\"urn:ietf:params:scim:api:messages:2.0:Error\"],\"status\":\"400\",\"scimType\":\"invalidValue\",\"detail\":\"Request is unparsable, syntactically incorrect, or violates schema.\"}\r",
							"        // this will occur when:\r",
							"        //    1 ) the users email is not 100% the same when compared between the emails[0].value and the idpUserId AND when the SAML SSO is either default or email.\r",
							"        //    2 ) the users idpUserId value is not 100% the same when compared between the userName and the idpUserId AND when the SAML SSO is userid\r",
							"        //\r",
							" \r",
							"        pm.variables.set(\"ContinuousErrors\",0); // seems odd perhaps that we are not adding to the error count, but we are managing this error by capturing the error in the users entry\r",
							"                                                // in UsersNeedingNewManager, and then repairing the user, before then trying again. If we spot the user entry in UsersNeedingNewManager\r",
							"                                                // has already captured an error we will skip the user.\r",
							"        const UsersNeedToBeUpdated = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"        const this_user            = UsersNeedToBeUpdated.splice(0,1)[0];\r",
							"        pm.variables.set(\"UsersNeedToBeUpdated\",UsersNeedToBeUpdated);\r",
							"        const previouserror        = (this_user.previouserror!==undefined) ? this_user.previouserror : 0;\r",
							"\r",
							"        switch (previouserror)\r",
							"        {\r",
							"            case 0:\r",
							"            {\r",
							"                // no previous error\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': Update for user '+this_user.value+' \\''+this_user.display+'\\' failed. To resolve this error, the user will now be repaired, and a subsequent update will then be re-attempted. Response code: '+pm.response.code+' '+pm.response.text());\r",
							"                UsersNeedToBeUpdated.splice(0,0,{...this_user, \"previouserror\": pm.response.code}); // add user to beginning of the array so its processed first\r",
							"                pm.variables.set(\"UsersNeedToBeUpdated\",UsersNeedToBeUpdated);\r",
							"\r",
							"                pm.variables.set(\"repair_user\",this_user);\r",
							"                pm.variables.set(\"recovery_from_repair\",pm.info.requestName);\r",
							"                pm.execution.setNextRequest(\"READ user for repair\");\r",
							"                user_needs_repair=true;  // needed so we later skip the pm.execution.setNextRequest setting later that would ignore the line above this\r",
							"                break;\r",
							"            }\r",
							"            default:\r",
							"            {\r",
							"                // there was a previous error\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Update for user '+this_user.value+' \\''+this_user.display+'\\' failed for the second time and after a possible repair of that user. This user could not be '+active_status+'. It might be because the user is the System Owner.  Response code: '+pm.response.code+' '+pm.response.text());\r",
							"                pm.test('Update user active status '+this_user.value+' '+this_user.display,function() { throw new Error( this_user.value+' '+this_user.display) });\r",
							"                \r",
							"                \r",
							"                if (UsersNeedToBeUpdated.length>0) \r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedToBeUpdated.length+' users remain to be updated.');\r",
							"                    pm.execution.setNextRequest(pm.info.requestName);\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': All users '+active_status+'.');\r",
							"                    pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                };\r",
							"\r",
							"            } // end default case\r",
							"        } // end previouserror switch\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 428:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const UsersNeedToBeUpdated   = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"        const this_user              = UsersNeedToBeUpdated.splice(0,1)[0];\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': '+this_user.value+' \\''+this_user.display+'\\' could not be '+active_status+' due to insufficient licenses. Response code: '+pm.response.code+' '+pm.response.text());\r",
							"        pm.variables.set(\"UsersNeedToBeUpdated\",UsersNeedToBeUpdated);\r",
							"        if (UsersNeedToBeUpdated.length>0) \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedToBeUpdated.length+' users remain to be updated.');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': All users '+active_status+'.');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"        break;\r",
							"    } // end 428\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const UsersNeedToBeUpdated   = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"        const this_user              = UsersNeedToBeUpdated.splice(0,1)[0];\r",
							"        const UserAfterUpdate = JSON.parse(pm.response.text());\r",
							"\r",
							"        function UserNeedsUpdating( user )\r",
							"        {\r",
							"            return (!user.active===(active.toString()==='true'))\r",
							"        }\r",
							"\r",
							"        if (UserNeedsUpdating( UserAfterUpdate ))\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': '+UserAfterUpdate.userName+' \\''+UserAfterUpdate.displayName+'\\' was not updated as expected. Active status remains '+UserAfterUpdate.active+'.');\r",
							"            pm.test('Update user active status '+UserAfterUpdate.userName,function() { throw new Error( UserAfterUpdate.userName ) });\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+UserAfterUpdate.userName+' \\''+UserAfterUpdate.displayName+'\\' now '+active_status+'.');\r",
							"        }\r",
							"\r",
							"        pm.variables.set(\"UsersNeedToBeUpdated\",UsersNeedToBeUpdated);\r",
							"        if (UsersNeedToBeUpdated.length>0) \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedToBeUpdated.length+' users remain to be updated.');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': All users '+active_status+'.');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"        break;\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            const UsersNeedToBeUpdated   = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"            UsersNeedToBeUpdated.splice(0,1);\r",
							"            pm.variables.set(\"UsersNeedToBeUpdated\",UsersNeedToBeUpdated);\r",
							"            if (UsersNeedToBeUpdated.length>0) \r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedToBeUpdated.length+' users remain to be updated.');\r",
							"                pm.execution.setNextRequest(pm.info.requestName);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': All users '+active_status+'.');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE user active status (Bulk)",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const active                    = pm.iterationData.get(\"file_active\"); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"    const active_status              = (active.toString() === 'true') ? 'activated' : 'deactivated';\r",
							"    const UsersNeedToBeUpdated      = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"    const bulk_maxOperations        = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"    const OperationsInThisUpdate    = (UsersNeedToBeUpdated.length<bulk_maxOperations) ? UsersNeedToBeUpdated.length : bulk_maxOperations;\r",
							"    const UsersInThisBulkUpdate     = UsersNeedToBeUpdated.slice(0,OperationsInThisUpdate);\r",
							"    const Operations                = UsersInThisBulkUpdate.map( user => {\r",
							"        return {\r",
							"            \"method\": \"PATCH\",\r",
							"            \"path\": \"/Users/\".concat(user.value),\r",
							"            \"data\": {\r",
							"                \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                \"Operations\":\r",
							"                [\r",
							"                    {\r",
							"                        \"op\": \"replace\",\r",
							"                        \"path\": \"active\",\r",
							"                        \"value\": active\r",
							"                    }\r",
							"                ]\r",
							"            }\r",
							"        }});\r",
							"\r",
							"    const bulk_request=\r",
							"    {\r",
							"        \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:BulkRequest\"],\r",
							"        \"failOnErrors\":1,\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Bulk updating '+OperationsInThisUpdate+' users to be '+active_status+'.' );\r",
							"    pm.variables.set(\"bulk_request_body\",JSON.stringify(bulk_request));\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user active status (bulk)\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"    \r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const active                     = pm.iterationData.get(\"file_active\"); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"        const active_status              = (active.toString() === 'true') ? 'activated' : 'deactivated';\r",
							"        const UsersNeedToBeUpdated       = pm.variables.get(\"UsersNeedToBeUpdated\");\r",
							"        const bulk_maxOperations         = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"        const OperationsInThisUpdate     = (UsersNeedToBeUpdated.length<bulk_maxOperations) ? UsersNeedToBeUpdated.length : bulk_maxOperations;\r",
							"        const UsersInThisBulkUpdate      = UsersNeedToBeUpdated.splice(0,OperationsInThisUpdate);\r",
							"        const OperationsResponse = JSON.parse(pm.response.text()).Operations.map( (operationresponse, index) =>\r",
							"        { \r",
							"            let status=(operationresponse.status!==undefined) ? parseInt(operationresponse.status) : parseInt(operationresponse.response.status);\r",
							"            let detail=''\r",
							"            try {\r",
							"                detail=operationresponse.response.detail\r",
							"            }\r",
							"            catch(err)\r",
							"            {\r",
							"                detail='';\r",
							"            }\r",
							"            let previouserror=(UsersInThisBulkUpdate[index].previouserror!==undefined) ? UsersInThisBulkUpdate[index].previouserror : 0;\r",
							"            \r",
							"            return {\"value\": UsersInThisBulkUpdate[index].value, \"display\": UsersInThisBulkUpdate[index].display, \"status\": status, \"detail\": detail, \"previouserror\": previouserror}\r",
							"        });\r",
							"\r",
							"\r",
							"        const total_users_not_processed  = UsersInThisBulkUpdate.length - OperationsResponse.length;\r",
							"        const valid_response_status      = [200];\r",
							"        const users_successfully_updated = OperationsResponse.filter( (response) => {return  valid_response_status.includes(response.status)} );\r",
							"        const users_not_updated          = OperationsResponse.filter( (response) => {return !valid_response_status.includes(response.status)} );\r",
							"        const users_not_processed        = UsersInThisBulkUpdate.slice( UsersInThisBulkUpdate.length - total_users_not_processed )\r",
							"        let   user_needs_repair          = false;\r",
							"\r",
							"        users_successfully_updated.forEach( (user) =>\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+user.value+' \\''+user.display+'\\' is now '+active_status);\r",
							"        } );\r",
							"\r",
							"        users_not_updated.forEach( (user) =>\r",
							"        {\r",
							"            switch (user.status)\r",
							"            {\r",
							"            case 403:\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' \\''+user.display+'\\' update will be re-attempted as it appears the session timed out mid-operation.');\r",
							"                    UsersNeedToBeUpdated.splice(0,0,user);;\r",
							"                    break;\r",
							"                }\r",
							"            case 428:\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' \\''+user.display+'\\' update failed due to insufficient licenses. Response code: '+user.status+' '+user.detail);\r",
							"                    break;\r",
							"                }\r",
							"            default:\r",
							"                {\r",
							"                    switch (user.previouserror)\r",
							"                    {\r",
							"                        case 0:\r",
							"                        {\r",
							"                            // no previous error\r",
							"                            console.info(pm.info.requestName+' '+pm.info.eventName+': Update for user '+user.value+' \\''+user.display+'\\' has failed. A repair of the user will now be attempted to try and resolve this error. Response code: '+user.status+' '+user.detail);\r",
							"\r",
							"                            user.previouserror = user.status;\r",
							"                            UsersNeedToBeUpdated.splice(0,0,user); // add to the start of the array so it is processed first\r",
							"                            pm.variables.set(\"repair_user\",user);\r",
							"                            pm.variables.set(\"recovery_from_repair\",pm.info.requestName);\r",
							"                            pm.execution.setNextRequest(\"READ user for repair\");\r",
							"                            user_needs_repair=true;  // needed so we later skip the pm.execution.  setting later that would ignore the line above this\r",
							"                            break;\r",
							"                        }\r",
							"                        default:\r",
							"                        {\r",
							"                            // there was a previous error\r",
							"                            console.error(pm.info.requestName+' '+pm.info.eventName+': Update for user '+user.value+' \\''+user.display+'\\' failed for the second time and after a possible repair of that user. This user could not be '+active_status+'. It might be because the user is the System Owner.  Response code: '+user.status+' '+user.detail);\r",
							"                            pm.test('Update user active status '+user.value+' '+user.display,function() { throw new Error( user.value+' '+user.display) });\r",
							"                        }\r",
							"                    }\r",
							"                }\r",
							"            } // end swtich user.status\r",
							"        } );\r",
							"        \r",
							"\r",
							"        users_not_processed.forEach( (user) =>\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' \\''+user.display+'\\' was not processed in the bulk request. User update will be re-attempted.');\r",
							"            UsersNeedToBeUpdated.push(user); // add to the end of the array\r",
							"        } );\r",
							"\r",
							"\r",
							"        if (user_needs_repair===false) // if the user needs repair the pm.execution.setNextRequest has already been set correctly.\r",
							"            {\r",
							"            if (UsersNeedToBeUpdated.length>0) \r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedToBeUpdated.length+' users remain to be updated.');\r",
							"                pm.execution.setNextRequest(pm.info.requestName);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': All users '+active_status+'.');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"        };\r",
							"        pm.variables.set(\"UsersNeedToBeUpdated\",UsersNeedToBeUpdated);\r",
							"        break;\r",
							"\r",
							"\r",
							"\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{bulk_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Bulk",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Bulk"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ user for repair",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ user for repair\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"function email_is_valid( user )\r",
							"{\r",
							"    switch (pm.variables.get(\"SAMLSSO\"))\r",
							"    {\r",
							"        case 'custom':\r",
							"        {\r",
							"            return (  (user.emails[0].value===user.emails[0].value.toLowerCase())  );\r",
							"            break;\r",
							"        }\r",
							"        case 'email':\r",
							"        case 'default':\r",
							"        {\r",
							"            // we test if the email is in lowercase or not, and we also test if the email stored in idpUserId matches the email address as seen in the user interface.\r",
							"            return (  (user.emails[0].value===user.emails[0].value.toLowerCase()) \r",
							"                    &&(user.emails[0].value===user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId)\r",
							"            )\r",
							"            break;\r",
							"        }\r",
							"        default:\r",
							"        {\r",
							"            return true;\r",
							"            break;\r",
							"        }\r",
							"    }\r",
							"}\r",
							"\r",
							"function UserIsValid( user )\r",
							"{\r",
							"    return (email_is_valid( user ));\r",
							"}\r",
							"\r",
							"function UserIsSystemOwner( user )\r",
							"{\r",
							"    return ((user.roles) && (user.roles.find( role => {return role.value==='PROFILE:sap.epm:System_Owner'})));\r",
							"}\r",
							"\r",
							"function ConsoleErrorLogUser( user, error )\r",
							"{\r",
							"    console.error(\"User is inconsistent: uuid(id):\"+user.id+\" id(userName):\"+user.userName+\" email(emails.value):\"+user.emails[0].value+\" SAMLmapping(idpUserId):\"+user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId+\" Error:\"+error)\r",
							"}\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end case response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // we will NOT reset the errors to 0 as it could result in an endless loop.\r",
							"        const repair_user=(JSON.parse(pm.response.text()));\r",
							"\r",
							"        if (UserIsSystemOwner( repair_user ))\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+\": This user is the System Owner and can not be updated via the API. Please expect updates to this user to fail: \"+repair_user.userName);\r",
							"        }\r",
							"\r",
							"        if (!UserIsValid(repair_user))\r",
							"        {\r",
							"            ConsoleErrorLogUser( repair_user, \"e-mail inconsistent, or not lowercase\");\r",
							"            if (UserIsSystemOwner( repair_user ))\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+\": Can not repair System Owner as the System Owner can not be updated via the API: \"+repair_user.userName);\r",
							"                pm.execution.setNextRequest(pm.variables.get(\"recovery_from_repair\"));\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+\": Attempting to repair user \"+repair_user.userName);\r",
							"                pm.variables.set(\"repair_user\",repair_user);\r",
							"                pm.execution.setNextRequest(\"REPAIR user\");\r",
							"            }\r",
							"        }\r",
							"        else if (UserIsSystemOwner( repair_user ))\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+\": User definition seems consistent, however this is the System Owner. The System Owner can not be updated via the API: \"+repair_user.userName);\r",
							"            pm.execution.setNextRequest(pm.variables.get(\"recovery_from_repair\"));\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': User definition seems consistent: '+repair_user.userName);\r",
							"            pm.execution.setNextRequest(pm.variables.get(\"recovery_from_repair\"));\r",
							"        }\r",
							"        \r",
							"        \r",
							"        break;\r",
							"    }\r",
							"    default:  // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"    };\r",
							"\r",
							"} // end switch response code"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const repair_user = pm.variables.get(\"repair_user\");\r",
							"pm.variables.set(\"user_uuid\",repair_user.value);\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading user for repair: '+ repair_user.value+' '+repair_user.display );"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "REPAIR user",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"REPAIR user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end case response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const repair_user=pm.variables.get(\"repair_user\");\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User repaired successfully: '+repair_user.userName);\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery_from_repair\"));\r",
							"        break;\r",
							"    }\r",
							"    default:  // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"    };\r",
							"\r",
							"} // end switch response code"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const repair_user=pm.variables.get(\"repair_user\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Repairing user: '+ repair_user.userName );\r",
							"\r",
							"const target_user_request= {};\r",
							"const elements_to_remove = ['meta','id'];\r",
							"\r",
							"Object.keys(repair_user).forEach( key => {  if (!elements_to_remove.includes(key)) { target_user_request[key]=repair_user[key] }} );\r",
							"\r",
							"\r",
							"switch (pm.variables.get(\"SAMLSSO\"))\r",
							"{\r",
							"    case 'default':\r",
							"    {\r",
							"        // the next line is important. There's a problem (which may now have been resolved) with the default authentication and creating users with a mixed CaSe of email.\r",
							"        // the problem is/was, that if the idpUserId that contains the email along with the emails[0].value must always be the same for this authenticaiton method (and also when SAML SSO is mapped on email)\r",
							"        // however, when the user is created via the SCIM API, the idpUserId email case is lowered. It means the email is the same email, but in a different case to emails[0].value\r",
							"        // this difference means that PATCH requests will fail. Its gets complicated, because a user could be created manually and then this issue doesn't occur. However, we then have another problem,\r",
							"        // which is the case of these users could also be mixed.  So we shall prevent these problems, by setting the email into lowercase. We shall use the emails[0].value value as the 'source' email as this\r",
							"        // is the one seen, and editable, within the user interface\r",
							"        target_user_request.emails[0].value=target_user_request.emails[0].value.toLowerCase();\r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_user_request.emails[0].value;\r",
							"\r",
							"        // the next line should remain commented-out, because this will copy the idpUserId to the email which is typically not desired\r",
							"        // target_user_request.emails[0].value=target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId;\r",
							"        break;\r",
							"    }\r",
							"    case 'email':\r",
							"    {\r",
							"        //target_user_request.emails[0].value=target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId;\r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_user_request.emails[0].value;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        // nothing to do\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'userid':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on userid property. \r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_userid;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"\r",
							"pm.variables.set(\"user_request_body\",JSON.stringify(target_user_request));\r",
							"pm.variables.set(\"user_uuid\",repair_user.id);\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 200:\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.execution.setNextRequest();                                   // we will now get a new x-csrf-token\r",
							"        break;\r",
							"    }\r",
							"    case 401:\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }; //end if \r",
							"        break;\r",
							"    }\r",
							"}; // switch case\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}/oauth/token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}"
					],
					"path": [
						"oauth",
						"token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "FETCH csrf token",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new x-csrf-token');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Fetch x-csrf-token\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"    case 200:\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetched a new x-csrf-token');\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"    } // end switch pm.response.code\r",
							"};\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "fetch",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/csrf",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"csrf"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "use_scim_bulk_operations",
			"value": "true",
			"type": "string"
		},
		{
			"key": "bulk_maxOperations",
			"value": "30",
			"type": "string"
		}
	]
}