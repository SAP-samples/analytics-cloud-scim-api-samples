{
	"info": {
		"_postman_id": "219b51a0-746a-4b2c-80d0-d3b8f74bdbce",
		"name": "SCIM 1403-U-U-Ut-Fj-Es-Update user team membership",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660"
	},
	"item": [
		{
			"name": "READ user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading user: '+ pm.iterationData.get(\"file_userid\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // No user so we can't update the user. Abort this entry\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': User not found '+pm.iterationData.get(\"file_userid\"));\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        pm.execution.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authenticated and the user does exist so we can now read the properties that make up this user\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (schemas.includes('urn:ietf:params:scim:schemas:core:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:enterprise:2.0:User')\r",
							"                        && schemas.includes('urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0')\r",
							"                          );  // the schema read must contain these definitions, otherwise we could be PUTting back missing properties\r",
							"        \r",
							"        // reading the current user value of the user properties held in SAP Analytics Cloud. \r",
							"        const SACteams       = readbody.groups;\r",
							"        // need the desired values\r",
							"        const file_teams_array         =pm.iterationData.get(\"file_JSON_teams\");\r",
							"        // We shall now process the team requirements for this user and store them in an array for processing when the end of the file is reached, thus 'batching' up all\r",
							"        // requests, so that a team can be updated with potentially just 1 PUT rather than a PUT for each and every user update. Remember we can't (yet) update a user\r",
							"        // to be a member of a team on a user basis, though this is planned in the roadmap.\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"        const username         = readbody.userName;\r",
							"                        \r",
							"        const teams_action =pm.iterationData.get(\"file_teams_action\");\r",
							"        if (teams_action===\"add\")\r",
							"        {\r",
							"            file_teams_array.forEach( myfunction_add_user_to_waiting_to_add_to_team);\r",
							"\r",
							"            function myfunction_add_user_to_waiting_to_add_to_team(value)\r",
							"            {\r",
							"                const teamname=value.value;\r",
							"                let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                let this_team;\r",
							"\r",
							"                if (this_team_index<0) \r",
							"                    {\r",
							"                        this_team = {\"teamname\"  : teamname,\r",
							"                                    \"need_to_read\": true,\r",
							"                                    \"displayname\": \"\",\r",
							"                                    \"meta\"       : \"\",\r",
							"                                    \"members\"    : [],\r",
							"                                    \"roles\"      : [],\r",
							"                                    \"users_chunk_size\" : 0,\r",
							"                                    \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                    \"arrayofusers_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                        array_of_teams.push(this_team);\r",
							"                        this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        this_team = array_of_teams[this_team_index];\r",
							"                    }\r",
							"                ;  // end team index\r",
							"\r",
							"                let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"\r",
							"                if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === username) )  // user_found_in_add_list\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' already added to add list. No action needed (UA1)');\r",
							"                }\r",
							"                else if (users_waiting_to_be_removed_in_this_batch.find(element => element.value === username))  // user_found_in_remove_list\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+' User '+username+' found in remove list, will remove user from remove list (UA2)');\r",
							"                    const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === username);\r",
							"                    users_waiting_to_be_removed_in_this_batch.splice(userindex,1)\r",
							"                }\r",
							"                else if ( SACteams.find(element => element.value === teamname))\r",
							"                {\r",
							"                    // the user is already a member of the team so we have nothing to do\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' already a member of team. Taking no action (UA3)');\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' being added to team ' +this_team.teamname+ ' add list (UA4)');\r",
							"                    const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                    newentry.value  = username;\r",
							"                    newentry.$ref   = \"/api/v1/scim/Users/\".concat(username);\r",
							"                    users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"                }; // end if\r",
							"                \r",
							"            }; // end function\r",
							"\r",
							"        } // end if team action is add\r",
							"        else if (teams_action===\"remove\")\r",
							"        {\r",
							"            file_teams_array.forEach( myfunction_add_user_to_waiting_to_remove_from_team);\r",
							"\r",
							"            function myfunction_add_user_to_waiting_to_remove_from_team(value)\r",
							"            {\r",
							"                const teamname=value.value;\r",
							"                let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                let this_team;\r",
							"\r",
							"                if (this_team_index<0) \r",
							"                    {\r",
							"                        this_team = {\"teamname\"  : teamname,\r",
							"                                    \"need_to_read\": true,\r",
							"                                    \"displayname\": \"\",\r",
							"                                    \"meta\"       : \"\",\r",
							"                                    \"members\"    : [],\r",
							"                                    \"roles\"      : [],\r",
							"                                    \"users_chunk_size\" : 0,\r",
							"                                    \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                    \"arrayofusers_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                        array_of_teams.push(this_team);\r",
							"                        this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        this_team = array_of_teams[this_team_index];\r",
							"                    }\r",
							"                ;  // end team index\r",
							"\r",
							"                let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"\r",
							"                \r",
							"                if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === username) ) // user_found_in_remove_list \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' already in remove list. No action needed (UR1)');\r",
							"                }\r",
							"                else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === username) )  // user_found_in_add_list\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' already will be removed from add list (UR2)');\r",
							"                    const userindex = users_waiting_to_be_added_in_this_batch.findIndex(element => element.value === username);\r",
							"                    users_waiting_to_be_added_in_this_batch.splice(userindex,1);\r",
							"                }\r",
							"                else if ( SACteams.find(element => element.value === teamname) ) // user_found_in_existing_team_membership\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' added to the remove list (UR3)');\r",
							"                    const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                    newentry.value  = username;\r",
							"                    newentry.$ref   = \"/api/v1/scim/Users/\".concat(username);\r",
							"                    users_waiting_to_be_removed_in_this_batch.push(newentry);\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' now a member of team '+teamname+' (UR4)');\r",
							"                }\r",
							"                ; // end if  \r",
							"            }; // end function\r",
							"\r",
							"        } // end if team action is remove\r",
							"        else if (teams_action===\"replace\")\r",
							"        {\r",
							"            file_teams_array.forEach( myfunction_add_users_from_replace_list_to_add_list);\r",
							"\r",
							"            function myfunction_add_users_from_replace_list_to_add_list(value)\r",
							"            {\r",
							"                const teamname=value.value;\r",
							"                let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                let this_team;\r",
							"\r",
							"                if (this_team_index<0) \r",
							"                    {\r",
							"                        this_team = {\"teamname\"  : teamname,\r",
							"                                    \"need_to_read\": true,\r",
							"                                    \"displayname\": \"\",\r",
							"                                    \"meta\"       : \"\",\r",
							"                                    \"members\"    : [],\r",
							"                                    \"roles\"      : [],\r",
							"                                    \"users_chunk_size\" : 0,\r",
							"                                    \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                    \"arrayofusers_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                        array_of_teams.push(this_team);\r",
							"                        this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        this_team = array_of_teams[this_team_index];\r",
							"                    }\r",
							"                ;  // end team index\r",
							"\r",
							"                let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"                if ( SACteams.find(element => element.value === teamname) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' already member of team (US1/US3)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' needs to be added to team (US2)');\r",
							"                    const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                    newentry.value  = username;\r",
							"                    newentry.$ref   = \"/api/v1/scim/Users/\".concat(username);\r",
							"                    users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"                }\r",
							"                ; // end if \r",
							"            }; // end function\r",
							"\r",
							"\r",
							"            SACteams.forEach( myfunction_add_users_from_existing_team_to_remove_list );\r",
							"            function myfunction_add_users_from_existing_team_to_remove_list(value)\r",
							"            {   \r",
							"                const teamname=value.value;\r",
							"                let this_team_index = array_of_teams.findIndex(element => element.teamname === teamname);\r",
							"                let this_team;\r",
							"\r",
							"                if (this_team_index<0) \r",
							"                    {\r",
							"                        this_team = {\"teamname\"  : teamname,\r",
							"                                    \"need_to_read\": true,\r",
							"                                    \"displayname\": \"\",\r",
							"                                    \"meta\"       : \"\",\r",
							"                                    \"members\"    : [],\r",
							"                                    \"roles\"      : [],\r",
							"                                    \"users_chunk_size\" : 0,\r",
							"                                    \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                                    \"arrayofusers_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                        array_of_teams.push(this_team);\r",
							"                        this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"                    }\r",
							"                else\r",
							"                    {\r",
							"                        this_team = array_of_teams[this_team_index];\r",
							"                    }\r",
							"                ;  // end team index\r",
							"\r",
							"                let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"                let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"                if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"                if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"                if ( file_teams_array.find(element => element.value === teamname) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' already member of team (US3/US1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+username+' removed (US4)');\r",
							"                    const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                    newentry.value  = username;\r",
							"                    newentry.$ref   = \"/api/v1/scim/Users/\".concat(username);\r",
							"                    users_waiting_to_be_removed_in_this_batch.push(newentry);\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        }; // end if team action is replace\r",
							"\r",
							"\r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"        let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"        array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"            function Users_to_add_for_this_team(team)\r",
							"            {\r",
							"                total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                    +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                    +team.arrayofusers_waiting_to_be_removed_in_this_batch.length;\r",
							"            };\r",
							"\r",
							"\r",
							"        // update_based_on_entries_read_so_far will be true every 100 records have been read from the file, i.e. every 500 users\r",
							"        const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"        // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"        const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"        const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"        //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"        //\r",
							"        // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"        // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"        //\r",
							"        // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"        if ( update_teams_now )\r",
							"        {\r",
							"            // the row in the file we are processing *is* the last row and so we must now update the teams.\r",
							"            // lets first find a team that needs to be read and that also needs to be updated at all\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(element => \r",
							"                                    (  element.need_to_read === true  )    \r",
							"                                    && (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                        + element.arrayofusers_waiting_to_be_removed_in_this_batch.length) >0 )    );\r",
							"\r",
							"            if ( first_team_to_read_index >= 0 )\r",
							"            {\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"                pm.execution.setNextRequest(\"READ team\");\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"                // this setNextRequest can now be UPDATE team, since we don't need to re-read the team\r",
							"                const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                                (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                    + element.arrayofusers_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"                if (first_team_to_update_index >= 0)\r",
							"                {\r",
							"                    // there is a team that needs to be updated\r",
							"                    pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                    pm.execution.setNextRequest(\"UPDATE team\");\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                    if ( pm.info.iteration===(pm.info.iterationCount-1) ) { console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update') };\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                };\r",
							"            };\r",
							"        }\r",
							"        else \r",
							"        {\r",
							"            // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"            // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"            if ( pm.info.iteration===(pm.info.iterationCount-1) ) { console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update') };\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"    }  // end if response === 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/{{file_userid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{file_userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        \r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Team not found, we need to create it.\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false); // we have now authorised this session, albeit with a 404 not found!\r",
							"        const team_in_current_team_array= pm.variables.get(\"currentteam\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Team not found. Creating new team '+ team_in_current_team_array);\r",
							"        pm.variables.set(\"currentteam\",team_in_current_team_array);\r",
							"        const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"        if (SAC_platform==='NEO')\r",
							"        {\r",
							"            // NEO does not supoort the scim2 API, only the scim2 API allows teams to be created without a team folder\r",
							"            pm.execution.setNextRequest('CREATE team');\r",
							"        }\r",
							"        else  // we are on a Cloud Foundary Platform\r",
							"        {\r",
							"            pm.execution.setNextRequest('CREATE team without folder');\r",
							"        };\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        pm.execution.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (   schemas.includes('urn:ietf:params:scim:schemas:core:2.0:Group') );\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"            {\r",
							"                pm.expect(validschema);\r",
							"            }\r",
							"        );\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"        const team_in_current_team_array= pm.variables.get(\"currentteam\");\r",
							"        \r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === team_in_current_team_array);\r",
							"        const this_team = array_of_teams[this_team_index];\r",
							"\r",
							"        this_team.need_to_read  =false;\r",
							"        this_team.displayname   =readbody.displayName;\r",
							"        this_team.meta          =readbody.meta;\r",
							"        this_team.members       =readbody.members;\r",
							"        this_team.roles         =readbody.roles;\r",
							"        this_team.users_chunk_size= Math.round(((42-(42-21.85714))*210) - (readbody.members.length * 0.14));\r",
							"        if (this_team.users_chunk_size<1) { this_team.users_chunk_size = 1};\r",
							"\r",
							"        array_of_teams[this_team_index]=this_team;\r",
							"        \r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"        pm.execution.setNextRequest();\r",
							"        \r",
							"        if (!validschema)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': SCIM schemas have changed. This script is not written for this schema version and it could corrupt your team. Aborting!');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"    }  // end response is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);  // repeat this call and re-attempt it\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);  // repeat this call and re-attempt it\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team '+pm.variables.get(\"currentteam\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{currentteam}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{currentteam}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const currentteam = pm.variables.get(\"currentteam\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+currentteam);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const array_of_teams  = pm.variables.get(\"array_of_teams\");\r",
							"    const this_team_index   = array_of_teams.findIndex(element => element.teamname === currentteam);\r",
							"    const this_team         = array_of_teams[this_team_index];\r",
							"    const displayname     = this_team.displayname;\r",
							"    const meta            = this_team.meta;\r",
							"    const users_chucksize           = this_team.users_chunk_size;\r",
							"    const users_in_this_team_update = this_team.members;\r",
							"    const roles_in_this_team_update = this_team.roles;\r",
							"    const users_waiting_to_be_added_in_this_batch  = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"    const users_waiting_to_be_removed_in_this_batch= this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"\r",
							"\r",
							"    if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"    \r",
							"\r",
							"    let number_of_users_that_can_change_in_this_chunk;\r",
							"    if ((users_waiting_to_be_added_in_this_batch.length+users_waiting_to_be_removed_in_this_batch.length)>=users_chucksize)\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_chucksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=(users_waiting_to_be_added_in_this_batch.length + users_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"\r",
							"    let number_of_users_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_users_that_can_be_added_in_this_chunk =0;\r",
							"\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length > number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (users_waiting_to_be_removed_in_this_batch.length<=number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk-number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (users_waiting_to_be_added_in_this_batch.length<number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=users_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    const max_users_in_single_PUT_request = 32767;\r",
							"    if ((this_team.members.length+number_of_users_that_can_be_added_in_this_chunk) > max_users_in_single_PUT_request)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Maximum number of users reached '+max_users_in_single_PUT_request);\r",
							"        number_of_users_that_can_be_added_in_this_chunk=max_users_in_single_PUT_request-this_team.members.length\r",
							"    }\r",
							"\r",
							"\r",
							"    \r",
							"\r",
							"    let number_of_users_removed = 0;\r",
							"    let number_of_users_added   = 0;\r",
							"\r",
							"    const users_removed_in_this_chunk = [];\r",
							"    while (number_of_users_removed < number_of_users_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_user=users_waiting_to_be_removed_in_this_batch.shift();\r",
							"        users_removed_in_this_chunk.push(removing_user);\r",
							"        \r",
							"        let removing_user_index = users_in_this_team_update.findIndex(element => element.value === removing_user.value);\r",
							"        users_in_this_team_update.splice(removing_user_index,1);\r",
							"        number_of_users_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofusers_removed_in_this_chunk\",users_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_users_added < number_of_users_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        users_in_this_team_update.push(users_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_users_added++;\r",
							"    };\r",
							"\r",
							"\r",
							"\r",
							"    const number_of_users_actually_changed = number_of_users_that_can_be_added_in_this_chunk + number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    pm.variables.set(\"number_of_users_in_this_chunk\",number_of_users_actually_changed);\r",
							"    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"    pm.variables.set(\"displayname\",displayname);\r",
							"    pm.variables.set(\"meta\",   JSON.stringify(meta));\r",
							"    pm.variables.set(\"members\",JSON.stringify(users_in_this_team_update));\r",
							"    pm.variables.set(\"roles\",  JSON.stringify(roles_in_this_team_update));\r",
							"    pm.variables.set(\"expected_user_count\",users_in_this_team_update.length);\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName\r",
							"                +': Updating team: '+currentteam+': adding '+number_of_users_that_can_be_added_in_this_chunk\r",
							"                +' users, removing '+number_of_users_that_can_be_removed_in_this_chunk\r",
							"                +' users');\r",
							"\r",
							"}  // end if errors"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE team\", () => {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"});\r",
							"\r",
							"if ( (pm.response.code === 200) )\r",
							"    {\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"    }\r",
							";  // end if response is 200\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        const readbody            = JSON.parse(pm.response.text());\r",
							"        const expected_user_count = pm.variables.get(\"expected_user_count\");\r",
							"        const actual_user_count   = readbody.members.length;\r",
							"        const previouserrors=pm.variables.get(\"ContinuousErrors\");  // errors holds the number of previous errors before this sucessful event. We need to know this so not to adjust the chunk size.\r",
							"                                                            // adjusting the chunk size after a previous error could be because the previous error was resolved by a repeated call. \r",
							"                                                            // and that repeated call could had taken a fraction of the normal processing time because it had already partly processed it beforehand.\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"                \r",
							"        if (expected_user_count === actual_user_count)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in team as expected');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in the team, however '+ expected_user_count+' where expected');\r",
							"        };\r",
							"\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === pm.variables.get(\"currentteam\"));\r",
							"        const this_team = array_of_teams[this_team_index];\r",
							"        \r",
							"        const number_of_user_changes_in_the_last_update=pm.variables.get(\"number_of_users_in_this_chunk\");\r",
							"        if (number_of_user_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const users_per_second = Math.round((number_of_user_changes_in_the_last_update/(pm.response.responseTime/1000))*10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+users_per_second+' users/second');\r",
							"\r",
							"            const users_in_last_request= JSON.parse(pm.variables.get(\"members\"));\r",
							"            users_in_last_request.forEach( myfunction_find_missing_users );\r",
							"            function myfunction_find_missing_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (S3/S1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' was not found in the team, but was expected to be present');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const users_that_should_had_been_removed =pm.variables.get(\"arrayofusers_removed_in_this_chunk\");\r",
							"            users_that_should_had_been_removed.forEach( myfunction_find_not_removed_users );\r",
							"            function myfunction_find_not_removed_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' should had been removed, but was not');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"        \r",
							"       \r",
							"        const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"        const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"\r",
							"        if( (users_waiting_to_be_added_in_this_batch.length\r",
							"            +users_waiting_to_be_removed_in_this_batch.lengthh) >0 ) \r",
							"        {\r",
							"            this_team.members=readbody.members;  // we need to reload the members that are actually in the team into our members list so the current list is accurate\r",
							"            this_team.roles  =readbody.roles;\r",
							"\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' users: '+this_team.members.length+' (yet to add: '+users_waiting_to_be_added_in_this_batch.length+' & remove: '+users_waiting_to_be_removed_in_this_batch.length+') member of: '+this_team.roles.length+' roles');\r",
							"            // need to test if chucksize is too large, if so we need to reduce it\r",
							"\r",
							"            if (number_of_user_changes_in_the_last_update>0) \r",
							"            {\r",
							"                // then our last update was for adding or removing users, so we need to change the chunk size accordingly\r",
							"                // however, there is a condition where we are removing users to allow updates to roles to be made, before we then start adding users in.\r",
							"                // it means that a chunk update may not have been 'full' of users, this in turn means the last update could had been very quick and we need to\r",
							"                // only adjust the chunk size when the last update was 'full'.\r",
							"\r",
							"                const max_users_in_single_PUT_request = 32767;\r",
							"                if (readbody.members.length>=max_users_in_single_PUT_request)\r",
							"                {\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }\r",
							"                else if ( (number_of_user_changes_in_the_last_update === this_team.users_chunk_size) && (previouserrors ===0 ) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.users_chunk_size;\r",
							"                    if (pm.response.responseTime>270000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.6);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime>210000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.8);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 2);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<120000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 1.75);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 2 mins. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.users_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                };\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                pm.execution.setNextRequest(pm.info.requestName); \r",
							"            };\r",
							"            \r",
							"        }\r",
							"        else // the current team has been processed\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' update complete it has '+readbody.members.length+' users and is a member of '+readbody.roles.length+' roles');\r",
							"            // we could delete the team if there's nothing in the team that needs to be updated, but we should only do that if we're at the end of the file\r",
							"            // since having the team in memory could prevent a re-read of the team later when processing the same file\r",
							"            \r",
							"            if ((pm.info.iteration===(pm.info.iterationCount-1)))\r",
							"   //         if (true)     // set this to true if you wanted to completely disable 'batch' mode, that is to delete the team for every user that is read from the file, only to potentially need to \r",
							"                            // re-read the team again for a different user. \r",
							"            {\r",
							"                // the current team has been processed, so we should now remove it from the array_of_teams\r",
							"                array_of_teams.splice(this_team_index,1);\r",
							"                pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"            };\r",
							"\r",
							"            // the code below is duplicated to the '400' if statement of 'CREATE team', so any changes made here will need to be duplicated there.\r",
							"            //\r",
							"            // we shall look at each team, held in the array, and see if any have users waiting to the added. Some teams may exist in memory without users waiting to be added (or removed from them),\r",
							"            // these teams are held in memory so we don't need to re-read the team just because that team has been updated.\r",
							"            let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"            array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"                function Users_to_add_for_this_team(team)\r",
							"                {\r",
							"                    total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                        +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                        +team.arrayofusers_waiting_to_be_removed_in_this_batch.length;\r",
							"                };\r",
							"\r",
							"\r",
							"            // update_based_on_entries_read_so_far will be true every 100 records have been read from the file, i.e. every 500 users\r",
							"            const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"            // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"            const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"            const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"            //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"            //\r",
							"            // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"            // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"            //\r",
							"            // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"            if ( update_teams_now )\r",
							"            {\r",
							"                // the row in the file we are processing *is* the last row and so we must now update the teams.\r",
							"                // lets first find a team that needs to be read and that also needs to be updated at all\r",
							"                const first_team_to_read_index = array_of_teams.findIndex(element => \r",
							"                                        (  element.need_to_read === true  )    \r",
							"                                        && (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                              + element.arrayofusers_waiting_to_be_removed_in_this_batch.length) >0 )    );\r",
							"\r",
							"                if ( first_team_to_read_index >= 0 )\r",
							"                {\r",
							"                    pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"                    pm.execution.setNextRequest(\"READ team\");\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"                    // this setNextRequest can now be UPDATE team, since we don't need to re-read the team\r",
							"                    const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                                    (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                        + element.arrayofusers_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"                    if (first_team_to_update_index >= 0)\r",
							"                    {\r",
							"                        // there is a team that needs to be updated\r",
							"                        pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                        pm.execution.setNextRequest(\"UPDATE team\");\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                        if ( pm.info.iteration===(pm.info.iterationCount-1) ) { console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update') };\r",
							"                        pm.execution.setNextRequest(null);\r",
							"                    };\r",
							"                };\r",
							"            }\r",
							"            else \r",
							"            {\r",
							"                // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"                // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"                if ( pm.info.iteration===(pm.info.iterationCount-1) ) { console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update') };\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"\r",
							"        }\r",
							"    }  // end reponse is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }  // end if else\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],\r\n    \"id\": \"{{currentteam}}\",\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"meta\": {{meta}},\r\n    \"members\": {{members}},\r\n    \"roles\": {{roles}}\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{currentteam}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{currentteam}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating team '+pm.variables.get(\"currentteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403    \r",
							"else if (pm.response.code === 201)\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"\r",
							"        // we are authenticated so skip to next user\r",
							"        pm.execution.setNextRequest('READ team');\r",
							"    }\r",
							"else if ((pm.response.code === 400) || (pm.response.code === 409))\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Can not create target team '+pm.variables.get(\"currenteam\")+' due to conflict, likely team folder already exists. Delete the team folder first. Login to SAP Analytics Cloud and select Menu-Files-System, then delete the folder matching the team name. This team will now be ignored and the user(s) will not be added to its membership. Teams cannot be created when the team or the team folder already exists. Team folder names are CaSe sensitive, as are team names when reading a team, but unlike team names when creating a team! This means reading a team (which is case sensitive) may not find a team, but when trying to create a team of the same name (which isn\\'t case sensitive), the team creation fails!  Response: '+ pm.response.text());\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === pm.variables.get(\"currentteam\"));\r",
							"        array_of_teams.splice(this_team_index,1)\r",
							"\r",
							"        // the code below is duplicated from the 'UPDATE team tests', so any changes made here will need to be duplicated there.\r",
							"        //\r",
							"        // we shall look at each team, held in the array, and see if any have users waiting to the added. Some teams may exist in memory without users waiting to be added (or removed from them),\r",
							"        // these teams are held in memory so we don't need to re-read the team just because that team has been updated.\r",
							"        let total_users_roles_in_teams_yet_to_be_updated = 0;\r",
							"        array_of_teams.forEach( Users_to_add_for_this_team );\r",
							"            function Users_to_add_for_this_team(team)\r",
							"            {\r",
							"                total_users_roles_in_teams_yet_to_be_updated=total_users_roles_in_teams_yet_to_be_updated\r",
							"                                                    +team.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                                    +team.arrayofusers_waiting_to_be_removed_in_this_batch.length;\r",
							"            };\r",
							"\r",
							"\r",
							"        \r",
							"        // update_based_on_entries_read_so_far will be true every 100 records have been read from the file, i.e. every 500 users\r",
							"        const update_based_on_entries_read_so_far = ( ( ( (pm.info.iteration+1) % 500 ) ===0  ) && (total_users_roles_in_teams_yet_to_be_updated>0));\r",
							"        // update_because_on_last_file_entry will be true if we're on the last entry of the file and there's at least 1 team that needs to be updated\r",
							"        const update_because_on_last_file_entry   = ( (pm.info.iteration===(pm.info.iterationCount-1)) && (total_users_roles_in_teams_yet_to_be_updated>0) );\r",
							"        const update_teams_now = (  update_because_on_last_file_entry || update_based_on_entries_read_so_far );\r",
							"        //const update_teams_now=(total_users_roles_in_teams_yet_to_be_updated>0);\r",
							"        //\r",
							"        // if you want to update each team on a row by row basis and not 'batch' requests together then ensure 'update_teams_now' is always true!\r",
							"        // the forumula determines if the iteration of the file is the last row or not. If it is the last row, then the updates will occur only at that time.\r",
							"        //\r",
							"        // by setting update_teams_now to true will force this scipt to update the team on every entry of the JSON file.\r",
							"\r",
							"        if ( update_teams_now )\r",
							"        {\r",
							"            // the row in the file we are processing *is* the last row and so we must now update the team.\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(element => element.need_to_read === true);\r",
							"\r",
							"            if ( first_team_to_read_index >= 0 )\r",
							"            {\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].teamname);\r",
							"                pm.execution.setNextRequest(\"READ team\");\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // all teams have been read, so we now need to determine which team needs to be updated since some teams may not need any updates to be made to them\r",
							"                const first_team_to_update_index = array_of_teams.findIndex(element =>\r",
							"                                (  ( element.arrayofusers_waiting_to_be_added_in_this_batch.length\r",
							"                                    + element.arrayofusers_waiting_to_be_removed_in_this_batch.length) >0 ) );\r",
							"                if (first_team_to_update_index >= 0)\r",
							"                {\r",
							"                    // there is a team that needs to be updated\r",
							"                    pm.variables.set(\"currentteam\", array_of_teams[first_team_to_update_index].teamname);\r",
							"                    pm.execution.setNextRequest(\"UPDATE team\");\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // there isn't a team that needs to be updated so we should skip to the next entry in the file (if there is one)\r",
							"                    if ( pm.info.iteration===(pm.info.iterationCount-1) ) { console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update') };\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                };\r",
							"            };\r",
							"        }\r",
							"        else \r",
							"        {\r",
							"            // the row in the file we are processing is not the last row, so we can proceed to read the next row(team) to 'batch' as many \r",
							"            // users together as we can. We need to do this to reduce the number of calls to update the Team as possible.\r",
							"            if ( pm.info.iteration===(pm.info.iterationCount-1) ) { console.log(pm.info.requestName+' '+pm.info.eventName+': There are no teams requiring an update') };\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\": [\r\n    \"urn:ietf:params:scim:schemas:core:2.0:Group\"\r\n  ],\r\n  \"id\": \"{{currentteam}}\",\r\n  \"displayName\": \"{{currentteam}} with Team Folder\"\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE team without folder",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating team '+pm.variables.get(\"currentteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new accesstoken');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ team\");\r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 201: \r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // the team was created ok, so we can go to re-read the team.\r",
							"        pm.execution.setNextRequest('READ team');\r",
							"        break;\r",
							"    }  // end case 201\r",
							"\r",
							"    case 400: // same as 409\r",
							"    case 409:\r",
							"    {\r",
							"        // although we obtained an unexpected result, this is handled so we shall set the errors to 0.\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        try {\r",
							"            if ( JSON.parse(pm.response.text()).scimType ==='uniqueness')\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create the team '+pm.variables.get(\"currentteam\")+' using the scim2 endpoint /api/v1/scim2/Groups. This is probably because a team with the same name already exists. Teams created with the scim2 endpoint /api/v1/scim2/Groups will not be readable or updatable using the scim1 /api/v1/scim/Groups/'+pm.variables.get(\"currentteam\")+' endpoint until the System Administration setting \\'Ignore Content Namespace for Teams\\' has been turned ON. Please turn this setting to ON now, and re-run this sample. If this setting is already enabled, but the scim1 /api/v1/scim/Groups/'+pm.variables.get(\"currentteam\")+' endpoint is unable to read the team (a GET request returns a 404), please contact SAP Support. Aborting this team.  Response: '+ pm.response.text());\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team.  Aborting this team.  Response: '+ pm.response.text());\r",
							"            }\r",
							"        }\r",
							"\t\tcatch (error)\r",
							"        { \r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team.  Aborting this team.  Response: '+ pm.response.text());\r",
							"        }\r",
							"        pm.execution.setNextRequest(null);\r",
							"\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";\r",
							"}; // end switch pm.response.code"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "x-sap-sac-create-team-folder",
						"value": "false",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:Group\",\r\n        \"urn:sap:params:scim:schemas:extension:sac:2.0:group-custom-parameters\"\r\n    ],\r\n    \"displayName\": \"{{currentteam}}\",\r\n    \"members\": [],\r\n    \"urn:sap:params:scim:schemas:extension:sac:2.0:group-custom-parameters\": {\r\n        \"description\": \"{{currentteam}}\"\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Groups",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}