{
	"info": {
		"_postman_id": "04b6cdb2-b349-4405-a654-a215c5d02d4b",
		"name": "SCIM 1429-U-U-Um-Fcj-Es-Update SAML Mapping (by email)",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-04b6cdb2-b349-4405-a654-a215c5d02d4b?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "READ user by email",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const email = pm.iterationData.get(\"file_email\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading user with email: '+email);\r",
							"pm.variables.set(\"email\",email);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ user by email\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403]);\r",
							"        if (pm.response.code === 200) {pm.expect(pm.response.json().totalResults).to.eql(1)};\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 403:\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    }  //end if response is 403\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const email = pm.variables.get(\"email\");\r",
							"        const desired_username = pm.iterationData.get(\"file_samlmapping\");\r",
							"        const readbody      = JSON.parse(responseBody);\r",
							"        const total_results = readbody.totalResults;\r",
							"        if (total_results===1)\r",
							"        {\r",
							"            const user_found_by_email = readbody.Resources[0];\r",
							"            if  (user_found_by_email.userName != desired_username)\r",
							"            {\r",
							"                pm.variables.set(\"userid\",user_found_by_email.id);\r",
							"                pm.variables.set(\"readbody\",user_found_by_email);\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Updating User with ID: '+ user_found_by_email.id +' having existing SAML Mapping: '+user_found_by_email.userName);\r",
							"                postman.setNextRequest(); // let Postman run the next call to UPDATE user\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': User already set correctly. Skipping user '+ user_found_by_email.id+ ' with email '+email+' which has SAML Mapping: '+user_found_by_email.userName);\r",
							"                postman.setNextRequest(null); // skip this row in the file and read the next row\r",
							"            };\r",
							"        }\r",
							"        else  // results are 0\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': The user could not be found by searching on the email: '+email+'. Users found having this email: '+total_results);\r",
							"            postman.setNextRequest(null); // skip this row in the file and read the next row\r",
							"        };\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"            possible_teams_update_required=true;\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							"}; // end switch case"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\r\n     \"filter\": \r\n     \"email eq \\\"{{email}}\\\"\", \r\n     \"startIndex\": 1,\r\n     \"count\": 1\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/.search",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						".search"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE username",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const userid= pm.variables.get(\"userid\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating user: '+ userid );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"// we need to read the current properties of the user,\r",
							"// change the properties we want to and *then* we can PUT back all the user properties correctly having only changed the properties we need to change\r",
							"const readbody            =pm.variables.get(\"readbody\"); // reading the response body of the previous call that read the user\r",
							"const username            =pm.iterationData.get(\"file_samlmapping\"); // changes to the username isn't allowed unless using custom SAML SSO mapping on email or custom mapping when using default IdP or SSO mapping on userid.\r",
							"const preferredlanguage   =readbody.preferredLanguage;  // possible values: 'ar', 'bg', 'zh-CN', 'zh-TW', 'hr', 'ca', 'cs', 'cy', 'nl', 'da', 'en', 'en-GB', 'fi', 'fr', 'fr-CA', 'de', 'de-CH', 'el', 'he', 'hi', 'hu', 'id', 'it', 'ja', 'ko', 'ms', 'no', 'pl', 'pt', 'pt-PT', 'ro', 'ru', 'sh', 'sk', 'sl', 'es', 'es-MX', 'sv', 'th', 'tr', 'uk', 'vi', 'en-US-sappsd' and possibly more will be added over time!\r",
							"const meta                =readbody.meta;    // changes to the meta isn't allowed\r",
							"const name                =readbody.name;    // changes to the name isn't allowed\r",
							"const displayname         =readbody.displayName; // string value\r",
							"const active              =readbody.active; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const emails              =readbody.emails; // JSON array of 'value','type','primary'\r",
							"const photos              =readbody.photos; // JSON array\r",
							"const roles               =readbody.roles;  // JSON array of SAC roles\r",
							"const groups              =readbody.groups; // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                          //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"const customparams        =readbody[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"];\r",
							"const dataaccesslanguage  =customparams.dataAccessLanguage; // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"const dateformatting      =customparams.dateFormatting;     // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"const timeformatting      =customparams.timeFormatting;     // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"const numberformatting    =customparams.numberFormatting;   // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"const cleanupnotificationsnumberofdays=customparams.cleanUpNotificationsNumberOfDays; // possible values: 0, 1, 2, etc..\r",
							"const systemnotificationsemailoptin=customparams.systemNotificationsEmailOptIn; // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const marketingemailoptin =customparams.marketingEmailOptIn;                    // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const isconcurrent        =customparams.isConcurrent;                           // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"const extension           =readbody[\"urn:scim:schemas:extension:enterprise:1.0\"];\r",
							"const manager             =extension.manager; // JSON array\r",
							"\r",
							"switch (pm.variables.get(\"SAMLSSO\"))\r",
							"{\r",
							"    case 'email':\r",
							"    {\r",
							"        emails[0].value           =username;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default:  // i.e. 'default' or 'userid'\r",
							"    {\r",
							"        // nothing to do. the email does NOT need to be updated or match the email address when a non-email SAML SSO is set.\r",
							"        break;\r",
							"    }\r",
							"};\r",
							"\r",
							"//\r",
							"// if you wish to make simple modifications to this script, do so only by changing the code ***ABOVE*** this line and keep the code ***BELOW*** unchanged.\r",
							"//\r",
							"\r",
							"\r",
							"\r",
							"pm.variables.set(\"username\",username);\r",
							"pm.variables.set(\"id\",readbody.id);\r",
							"pm.variables.set(\"preferredlanguage\",preferredlanguage);  // possible values: 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"meta\",JSON.stringify(meta));\r",
							"pm.variables.set(\"name\",JSON.stringify(name));     // JSON array of givenName and familyName\r",
							"pm.variables.set(\"displayname\",displayname);       // string value\r",
							"pm.variables.set(\"active\",active);                 // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"emails\",JSON.stringify(emails)); // JSON array of 'value','type','primary'\r",
							"pm.variables.set(\"photos\",JSON.stringify(photos)); // JSON array\r",
							"pm.variables.set(\"roles\",JSON.stringify(roles));   // JSON array of SAC roles\r",
							"pm.variables.set(\"groups\",JSON.stringify(groups)); // JSON array. Need to use /Groups endpoint until SAC SCIM API support setting groups on a per user basis.\r",
							"                                                             //             This entry will be ignored until then but its set here so it will work when supported.\r",
							"pm.variables.set(\"dataaccesslanguage\",dataaccesslanguage);   // possible values: 'zz' (default), 'af', 'ar', 'bg',  ... many more as shown above in preferredlanguage.\r",
							"pm.variables.set(\"dateformatting\",dateformatting);  // possible values include: 'MMM d, yyyy', 'dd/MM/yyyy', 'MM.dd.yyyy', ... many more!\r",
							"pm.variables.set(\"timeformatting\",timeformatting);  // possible values include: 'H:mm:ss' (24H), 'h:mm:ss A' (12H)\r",
							"pm.variables.set(\"numberformatting\",numberformatting);  // possible values include: '1,234.56', '1.234,56', '1 234,56'\r",
							"pm.variables.set(\"cleanupnotificationsnumberofdays\",cleanupnotificationsnumberofdays); // possible values: 0, 1, 2, etc..\r",
							"pm.variables.set(\"systemnotificationsemailoptin\",systemnotificationsemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"marketingemailoptin\",marketingemailoptin); // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"isconcurrent\",isconcurrent);       // possible values: 'true' or 'false' are valid, unlike 'TRUE' or 'FALSE'\r",
							"pm.variables.set(\"manager\",JSON.stringify(manager)); // JSON array"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE username\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403]);\r",
							"        pm.expect(pm.response.json().userName).to.eql(pm.variables.get(\"username\"));\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 403:\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"recovery\",\"READ users for authorisation\");\r",
							"        postman.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    }  //end if response is 403\r",
							"\r",
							"    case 400:\r",
							"    {\r",
							"        // its very likley that SSO is not set to be custom or email\r",
							"        // we can only update the username (SAML mapping) when the SSO is set for custom or email\r",
							"\r",
							"        switch (pm.variables.get(\"SAMLSSO\"))\r",
							"        {\r",
							"            case 'custom':\r",
							"            case 'email':\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to update SAML mapping (user property userName). Likley another user already has this mapping. This user is now likley to have a \\'null\\' value for the SAML mapping. Aborting. Response: '+ responseBody);\r",
							"                pm.variables.set(\"ContinuousErrors\",0); \r",
							"                postman.setNextRequest(null);\r",
							"                break;\r",
							"            }\r",
							"\r",
							"            default:\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to update SAML mapping (user property userName). This is only updatable when SAML SSO is setup for custom or email. Aborting. Response: '+ responseBody);\r",
							"                pm.variables.set(\"ContinuousErrors\",0); \r",
							"                postman.setNextRequest(null);\r",
							"                break;\r",
							"            }\r",
							"        }\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const readbody          = JSON.parse(responseBody);\r",
							"        const requested_userid=pm.variables.get(\"username\");\r",
							"        const userid            =pm.variables.get(\"id\");\r",
							"        const actual_username   =readbody.userName;\r",
							"        if (actual_username===requested_userid)\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': User updated. User ID: '+userid+' with new SAML Mapping: '+actual_username);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': '+userid+' did not update SAML Mapping! Requested: '+requested_userid+' still has: '+actual_username+'   SAML Mapping (userName) is not updatable when using 1) the default IdP or 2) your own IdP with SSO mapped on User ID');\r",
							"        };\r",
							"        postman.setNextRequest(null);\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							"}; // end switch case"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User\",\r\n        \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"\r\n    ],\r\n    \"userName\": \"{{username}}\",\r\n    \"id\": \"{{id}}\",\r\n    \"preferredLanguage\": \"{{preferredlanguage}}\",\r\n    \"meta\": {{meta}},\r\n    \"name\": {{name}},\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"active\": {{active}},\r\n    \"emails\": {{emails}},\r\n    \"photos\": {{photos}},\r\n    \"roles\": {{roles}},\r\n    \"groups\": {{groups}},\r\n    \"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\": {\r\n        \"dataAccessLanguage\": \"{{dataaccesslanguage}}\",\r\n        \"dateFormatting\": \"{{dateformatting}}\",\r\n        \"timeFormatting\": \"{{timeformatting}}\",\r\n        \"numberFormatting\": \"{{numberformatting}}\",\r\n        \"cleanUpNotificationsNumberOfDays\": {{cleanupnotificationsnumberofdays}},\r\n        \"systemNotificationsEmailOptIn\": {{systemnotificationsemailoptin}},\r\n        \"marketingEmailOptIn\": {{marketingemailoptin}},\r\n        \"isConcurrent\": {{isconcurrent}}\r\n    },\r\n    \"urn:scim:schemas:extension:enterprise:1.0\": {\r\n        \"manager\": {{manager}}\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/{{userid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						"{{userid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(responseBody);\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        postman.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ responseBody);\r",
							"        postman.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ responseBody);\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    postman.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "READ users for authorisation",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading users to obtain authorisation');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Authorised\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",postman.getResponseHeader(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        postman.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        const readbody    = JSON.parse(responseBody);\r",
							"        const total_users_in_this_SAC_service= readbody.totalResults;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised. This SAP Analytics Cloud Service has '+total_users_in_this_SAC_service+' users');\r",
							"         // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        postman.setNextRequest(\"READ user by email\");\r",
							"    }\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ responseBody);\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            postman.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ responseBody);\r",
							"            postman.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"type": "text",
						"value": "{{x-csrf-token}}"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"type": "text",
						"value": "true"
					},
					{
						"key": "Content-Type",
						"name": "Content-Type",
						"type": "text",
						"value": "application/json"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/?startIndex=1&count=1",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						""
					],
					"query": [
						{
							"key": "startIndex",
							"value": "1"
						},
						{
							"key": "count",
							"value": "1"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}