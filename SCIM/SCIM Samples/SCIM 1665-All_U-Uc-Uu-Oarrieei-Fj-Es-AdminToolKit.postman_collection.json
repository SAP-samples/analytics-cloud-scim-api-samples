{
	"info": {
		"_postman_id": "28a422b5-58da-41b1-8a49-4344ba04301b",
		"name": "SCIM 1665-All_U-Uc-Uu-Oarrieei-Fj-Es-AdminToolKit",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-28a422b5-58da-41b1-8a49-4344ba04301b?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "READ team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        break;\r",
							"    } // end case response is 401\r",
							"\r",
							"    case 404:\r",
							"    {\r",
							"        // Team not found, we need to create it.\r",
							"        const team_in_current_file_row=pm.iterationData.get(\"file_team\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Team not found. Creating new team '+ team_in_current_file_row);\r",
							"        pm.variables.set(\"currentteam\",team_in_current_file_row);\r",
							"        const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"        if (SAC_platform==='NEO')\r",
							"        {\r",
							"            // NEO does not supoort the scim2 API, only the scim2 API allows teams to be created without a team folder\r",
							"            pm.execution.setNextRequest('CREATE team');\r",
							"        }\r",
							"        else  // we are on a Cloud Foundary Platform\r",
							"        {\r",
							"            pm.execution.setNextRequest('CREATE team without folder');\r",
							"        };\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"        const team_in_current_file_row= pm.iterationData.get(\"file_team\");\r",
							"        let this_team_index = array_of_teams.findIndex(element => element.teamname === team_in_current_file_row);\r",
							"        let this_team;\r",
							"        if (this_team_index<0) \r",
							"            {           \r",
							"                this_team = {\"teamname\"  : team_in_current_file_row,\r",
							"                            \"displayname\": readbody.displayName,\r",
							"                            \"meta\"       : readbody.meta,\r",
							"                            \"members\"    : readbody.members,\r",
							"                            \"roles\"      : readbody.roles,\r",
							"                            \"users_chunk_size\" : 0,\r",
							"                            \"roles_chunk_size\" : 0,\r",
							"                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                this_team.users_chunk_size= Math.round( ((42-(42-21.85714))*210) - (readbody.members.length * 0.14));\r",
							"                if (this_team.users_chunk_size<1) { this_team.users_chunk_size = 1};\r",
							"                if ( readbody.members.length > 0)\r",
							"                {\r",
							"                    this_team.roles_chunk_size= Math.round((210/(readbody.members.length*46/210))*10);  //210 is the target duration in seconds, 46 is the average rate of users/role/second\r",
							"                    if (this_team.roles_chunk_size<1) { this_team.roles_chunk_size = 1};\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    this_team.roles_chunk_size= 50;\r",
							"                };\r",
							"                array_of_teams.push(this_team);\r",
							"                this_team_index=array_of_teams.findIndex(element => element.teamname === this_team.teamname);\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                this_team = array_of_teams[this_team_index];\r",
							"            }\r",
							"        ;  // end team index\r",
							"\r",
							"        \r",
							"        pm.variables.set(\"managers\",[]);    // this is a special variable used to store users that are managers. It is needed to process file_action_users_that_are_managers\r",
							"        pm.variables.set(\"all_users\",[]);   // this is also a special variable and used to process file_action_users_that_are_managers but only for the actions excludeall and invert\r",
							"        \r",
							"\r",
							"        const Users_Action                      =  pm.iterationData.get(\"file_users_action\");\r",
							"        pm.variables.set(\"Users_Action\",           Users_Action);\r",
							"\r",
							"        // the following are optional\r",
							"        let Users_To_Exclude_Array              =   pm.iterationData.get(\"file_JSON_users_to_exclude\");\r",
							"        Users_To_Exclude_Array                  =   (typeof Users_To_Exclude_Array          !== 'undefined') ? Users_To_Exclude_Array : [];\r",
							"        pm.variables.set(\"Users_To_Exclude_Array\",          Users_To_Exclude_Array);\r",
							"\r",
							"        let Multiple_Operator_is_AND            =   pm.iterationData.get(\"file_multiple_action_users_operator_is_AND\");\r",
							"        Multiple_Operator_is_AND                =   (typeof Multiple_Operator_is_AND        !== 'undefined') ? Multiple_Operator_is_AND : false;\r",
							"        pm.variables.set(\"Multiple_Operator_is_AND\",        Multiple_Operator_is_AND);\r",
							"\r",
							"        let Users_Match_All_Users               =   pm.iterationData.get(\"file_action_users_match_all_users\");\r",
							"        Users_Match_All_Users                   =   (typeof Users_Match_All_Users           !== 'undefined') ? Users_Match_All_Users : false;\r",
							"        pm.variables.set(\"Users_Match_All_Users\",           Users_Match_All_Users);\r",
							"\r",
							"        let Users_Created_Recently              =   pm.iterationData.get(\"file_action_users_created_recently\");\r",
							"        Users_Created_Recently                  =   (typeof Users_Created_Recently          !== 'undefined') ? Users_Created_Recently : false;\r",
							"        pm.variables.set(\"Users_Created_Recently\",          Users_Created_Recently);\r",
							"\r",
							"        let Users_Created_Recently_In_Days      =   pm.iterationData.get(\"file_users_created_recently_in_days\");\r",
							"        Users_Created_Recently_In_Days          =   (typeof Users_Created_Recently_In_Days  !== 'undefined') ? Users_Created_Recently_In_Days : 7;\r",
							"        pm.variables.set(\"Users_Created_Recently_In_Days\",  Users_Created_Recently_In_Days);\r",
							"\r",
							"        let Users_With_BI_Concurrent_License    =   pm.iterationData.get(\"file_action_users_with_bi_concurrent_license\");\r",
							"        Users_With_BI_Concurrent_License        =   (typeof Users_With_BI_Concurrent_License  !== 'undefined') ? Users_With_BI_Concurrent_License : false;\r",
							"        pm.variables.set(\"Users_With_BI_Concurrent_License\",Users_With_BI_Concurrent_License);\r",
							"\r",
							"        let Users_With_BI_Named_User_License        =   pm.iterationData.get(\"file_action_users_with_bi_named_user_license\");\r",
							"        Users_With_BI_Named_User_License            =   (typeof Users_With_BI_Named_User_License  !== 'undefined') ? Users_With_BI_Named_User_License : false;\r",
							"        pm.variables.set(\"Users_With_BI_Named_User_License\",    Users_With_BI_Named_User_License);\r",
							"\r",
							"        let Users_With_A_Manager                =   pm.iterationData.get(\"file_action_users_with_a_manager\");\r",
							"        Users_With_A_Manager                    =   (typeof Users_With_A_Manager  !== 'undefined') ? Users_With_A_Manager : false;\r",
							"        pm.variables.set(\"Users_With_A_Manager\",            Users_With_A_Manager);\r",
							"\r",
							"        let Users_With_Named_ManagerIDs             =   pm.iterationData.get(\"file_action_users_with_named_managerids\");\r",
							"        Users_With_Named_ManagerIDs                 =   (typeof Users_With_Named_ManagerIDs  !== 'undefined') ? Users_With_Named_ManagerIDs : false;\r",
							"        pm.variables.set(\"Users_With_Named_ManagerIDs\",         Users_With_Named_ManagerIDs);\r",
							"\r",
							"        let Users_Named_ManagerIDs              =   pm.iterationData.get(\"file_JSON_named_managerids\");\r",
							"        Users_Named_ManagerIDs                  =   (typeof Users_Named_ManagerIDs  !== 'undefined') ? Users_Named_ManagerIDs : [];\r",
							"        pm.variables.set(\"Users_Named_ManagerIDs\",          Users_Named_ManagerIDs);\r",
							"\r",
							"        let Users_Without_Manager               =   pm.iterationData.get(\"file_action_users_without_manager\");\r",
							"        Users_Without_Manager                   =   (typeof Users_Without_Manager  !== 'undefined') ? Users_Without_Manager : false;\r",
							"        pm.variables.set(\"Users_Without_Manager\",           Users_Without_Manager);        \r",
							"\r",
							"        let Users_That_Are_Managers             =   pm.iterationData.get(\"file_action_users_that_are_managers\");\r",
							"        Users_That_Are_Managers                 =   (typeof Users_That_Are_Managers  !== 'undefined') ? Users_That_Are_Managers : false;\r",
							"        pm.variables.set(\"Users_That_Are_Managers\",         Users_That_Are_Managers);\r",
							"\r",
							"        let Users_Active                        =   pm.iterationData.get(\"file_action_users_active\");\r",
							"        Users_Active                            =   (typeof Users_Active  !== 'undefined') ? Users_Active : false;\r",
							"        pm.variables.set(\"Users_Active\",                    Users_Active); \r",
							"\r",
							"        let Users_Not_Active                    =   pm.iterationData.get(\"file_action_users_not_active\");\r",
							"        Users_Not_Active                        =   (typeof Users_Not_Active  !== 'undefined') ? Users_Not_Active : false;\r",
							"        pm.variables.set(\"Users_Not_Active\",                Users_Not_Active); \r",
							"\r",
							"        let Users_With_UserID_Ending_Underscore_1               =   pm.iterationData.get(\"file_action_users_with_userid_ending_underscore_1\");\r",
							"        Users_With_UserID_Ending_Underscore_1                   =   (typeof Users_With_UserID_Ending_Underscore_1  !== 'undefined') ? Users_With_UserID_Ending_Underscore_1 : false;\r",
							"        pm.variables.set(\"Users_With_UserID_Ending_Underscore_1\",           Users_With_UserID_Ending_Underscore_1); \r",
							"\r",
							"        let Users_With_Email_Domain_Matching                    =   pm.iterationData.get(\"file_action_users_with_email_domain_matching\");\r",
							"        Users_With_Email_Domain_Matching                        =   (typeof Users_With_Email_Domain_Matching  !== 'undefined') ? Users_With_Email_Domain_Matching : false;\r",
							"        pm.variables.set(\"Users_With_Email_Domain_Matching\",                Users_With_Email_Domain_Matching); \r",
							"\r",
							"        let Users_With_Email_Domain_Not_Matching               =   pm.iterationData.get(\"file_action_users_with_email_domain_not_matching\");\r",
							"        Users_With_Email_Domain_Not_Matching                   =   (typeof Users_With_Email_Domain_Not_Matching  !== 'undefined') ? Users_With_Email_Domain_Not_Matching : false;\r",
							"        pm.variables.set(\"Users_With_Email_Domain_Not_Matching\",           Users_With_Email_Domain_Not_Matching); \r",
							"\r",
							"        let Users_Email_Domain                      =   pm.iterationData.get(\"file_email_domain\");\r",
							"        Users_Email_Domain                          =   (typeof Users_Email_Domain  !== 'undefined') ? Users_Email_Domain.toString().toLowerCase() : 'sap.com';\r",
							"        pm.variables.set(\"Users_Email_Domain\",                  Users_Email_Domain); \r",
							"\r",
							"        let Users_With_A_Role_Or_A_Team                    =   pm.iterationData.get(\"file_action_users_with_a_role_or_a_team\");\r",
							"        Users_With_A_Role_Or_A_Team                        =   (typeof Users_With_A_Role_Or_A_Team  !== 'undefined') ? Users_With_A_Role_Or_A_Team : false;\r",
							"        pm.variables.set(\"Users_With_A_Role_Or_A_Team\",                Users_With_A_Role_Or_A_Team); \r",
							"\r",
							"        let Users_With_No_Teams                    =   pm.iterationData.get(\"file_action_users_with_no_teams\");\r",
							"        Users_With_No_Teams                        =   (typeof Users_With_No_Teams  !== 'undefined') ? Users_With_No_Teams : false;\r",
							"        pm.variables.set(\"Users_With_No_Teams\",                Users_With_No_Teams);\r",
							"\r",
							"        let Users_Teams_to_Exclude_Array                    =   pm.iterationData.get(\"file_JSON_teams_to_exclude\");\r",
							"        Users_Teams_to_Exclude_Array                        =   (typeof Users_Teams_to_Exclude_Array  !== 'undefined') ? Users_Teams_to_Exclude_Array : [];\r",
							"        pm.variables.set(\"Users_Teams_to_Exclude_Array\",                Users_Teams_to_Exclude_Array);\r",
							"\r",
							"        let Users_Teamnames_StartsWith_to_Exclude_Array     =   pm.iterationData.get(\"file_JSON_teamnames_starts_with_to_exclude\");\r",
							"        Users_Teamnames_StartsWith_to_Exclude_Array         =   (typeof Users_Teamnames_StartsWith_to_Exclude_Array  !== 'undefined') ? Users_Teamnames_StartsWith_to_Exclude_Array : [];\r",
							"        pm.variables.set(\"Users_Teamnames_StartsWith_to_Exclude_Array\", Users_Teamnames_StartsWith_to_Exclude_Array);\r",
							"\r",
							"        let Users_With_No_Roles                    =   pm.iterationData.get(\"file_action_users_with_no_roles\");\r",
							"        Users_With_No_Roles                        =   (typeof Users_With_No_Roles  !== 'undefined') ? Users_With_No_Roles : false;\r",
							"        pm.variables.set(\"Users_With_No_Roles\",                Users_With_No_Roles);\r",
							"\r",
							"        let roles_to_exclude_array             =   pm.iterationData.get(\"file_JSON_roles_to_exclude\");\r",
							"        roles_to_exclude_array                 =   (typeof roles_to_exclude_array  !== 'undefined') ? roles_to_exclude_array : [];\r",
							"        pm.variables.set(\"roles_to_exclude_array\",         roles_to_exclude_array);\r",
							"\r",
							"        let Users_With_All_Named_Roles                    =   pm.iterationData.get(\"file_action_users_with_all_named_roles\");\r",
							"        Users_With_All_Named_Roles                        =   (typeof Users_With_All_Named_Roles  !== 'undefined') ? Users_With_All_Named_Roles : false;\r",
							"        pm.variables.set(\"Users_With_All_Named_Roles\",                Users_With_All_Named_Roles);\r",
							"\r",
							"        let named_roles_array             =   pm.iterationData.get(\"file_JSON_named_roles\");\r",
							"        named_roles_array                 =   (typeof named_roles_array  !== 'undefined') ? named_roles_array : [];\r",
							"        pm.variables.set(\"named_roles_array\",         named_roles_array);\r",
							"\r",
							"        let Users_LangDateTimeNumberFormats_Different_From                    =   pm.iterationData.get(\"file_actions_users_with_LangDateTimeNumberFormats_different_from\");\r",
							"        Users_LangDateTimeNumberFormats_Different_From                        =   (typeof Users_LangDateTimeNumberFormats_Different_From  !== 'undefined') ? Users_LangDateTimeNumberFormats_Different_From : false;\r",
							"        pm.variables.set(\"Users_LangDateTimeNumberFormats_Different_From\",                Users_LangDateTimeNumberFormats_Different_From);\r",
							"        \r",
							"        if (Users_LangDateTimeNumberFormats_Different_From)\r",
							"        {\r",
							"            pm.variables.set(\"Users_preferredlanguage\",                         pm.iterationData.get(\"file_preferredlanguage\"));\r",
							"            pm.variables.set(\"Users_dataaccesslanguage\",                        pm.iterationData.get(\"file_dataaccesslanguage\"));\r",
							"            pm.variables.set(\"Users_dateformatting\",                            pm.iterationData.get(\"file_dateformatting\"));\r",
							"            pm.variables.set(\"Users_timeformatting\",                            pm.iterationData.get(\"file_timeformatting\"));\r",
							"            pm.variables.set(\"Users_numberformatting\",                          pm.iterationData.get(\"file_numberformatting\"));\r",
							"        }\r",
							"\r",
							"        // new variables from version 0.9\r",
							"        let Users_created_more_than                    =   pm.iterationData.get(\"file_action_users_created_more_than_days_ago\");\r",
							"        Users_created_more_than                        =   (typeof Users_created_more_than  !== 'undefined') ? Users_created_more_than : false;\r",
							"        pm.variables.set(\"Users_created_more_than\",                Users_created_more_than);\r",
							"\r",
							"        let Users_created_more_than_days                    =   pm.iterationData.get(\"file_users_created_more_than_days\");\r",
							"        Users_created_more_than_days                        =   (typeof Users_created_more_than_days  !== 'undefined') ? Users_created_more_than_days : 30;\r",
							"        pm.variables.set(\"Users_created_more_than_days\",                Users_created_more_than_days);\r",
							"\r",
							"        let Users_with_most_recent_login_at_least_days_ago                   =   pm.iterationData.get(\"file_action_users_with_most_recent_login_at_least_days_ago\");\r",
							"        Users_with_most_recent_login_at_least_days_ago                       =   (typeof Users_with_most_recent_login_at_least_days_ago  !== 'undefined') ? Users_with_most_recent_login_at_least_days_ago : false;\r",
							"        pm.variables.set(\"Users_with_most_recent_login_at_least_days_ago\",               Users_with_most_recent_login_at_least_days_ago);\r",
							"\r",
							"        let Users_with_most_recent_login_days_ago_days                   =   pm.iterationData.get(\"file_users_with_with_most_recent_login_at_least_days\");\r",
							"        Users_with_most_recent_login_days_ago_days                       =   (typeof Users_with_most_recent_login_days_ago_days  !== 'undefined') ? Users_with_most_recent_login_days_ago_days : 30;\r",
							"        pm.variables.set(\"Users_with_most_recent_login_days_ago_days\",               Users_with_most_recent_login_days_ago_days);\r",
							"\r",
							"\r",
							"        let Users_with_most_recent_login_within_last_days_ago                   =   pm.iterationData.get(\"file_action_users_with_most_recent_login_within_last_days\");\r",
							"        Users_with_most_recent_login_within_last_days_ago                       =   (typeof Users_with_most_recent_login_within_last_days_ago  !== 'undefined') ? Users_with_most_recent_login_within_last_days_ago : false;\r",
							"        pm.variables.set(\"Users_with_most_recent_login_within_last_days_ago\",               Users_with_most_recent_login_within_last_days_ago);\r",
							"\r",
							"        let Users_with_most_recent_login_days_within_last_days                   =   pm.iterationData.get(\"file_users_with_with_most_recent_login_within_last_days\");\r",
							"        Users_with_most_recent_login_days_within_last_days                       =   (typeof Users_with_most_recent_login_days_within_last_days  !== 'undefined') ? Users_with_most_recent_login_days_within_last_days : 30;\r",
							"        pm.variables.set(\"Users_with_most_recent_login_days_within_last_days\",               Users_with_most_recent_login_days_within_last_days);\r",
							"\r",
							"\r",
							"        let Users_with_few_logins_than                   =   pm.iterationData.get(\"file_action_users_with_fewer_logins_than\");\r",
							"        Users_with_few_logins_than                       =   (typeof Users_with_few_logins_than  !== 'undefined') ? Users_with_few_logins_than : false;\r",
							"        pm.variables.set(\"Users_with_few_logins_than\",               Users_with_few_logins_than);\r",
							"       \r",
							"        let Users_fewer_logins_than                 =   pm.iterationData.get(\"file_users_with_fewer_logins_than\");\r",
							"        Users_fewer_logins_than                       =   (typeof Users_fewer_logins_than  !== 'undefined') ? Users_fewer_logins_than : 5;\r",
							"        pm.variables.set(\"Users_fewer_logins_than\",               Users_fewer_logins_than);\r",
							"\r",
							"        let Users_with_fewer_logins_within_last_days                   =   pm.iterationData.get(\"file_action_users_with_fewer_logins_within_last_days\");\r",
							"        Users_with_fewer_logins_within_last_days                       =   (typeof Users_with_fewer_logins_within_last_days  !== 'undefined') ? Users_with_fewer_logins_within_last_days : false;\r",
							"        pm.variables.set(\"Users_with_fewer_logins_within_last_days\",               Users_with_fewer_logins_within_last_days);\r",
							"\r",
							"\r",
							"\r",
							"        let Users_with_greater_logins_than                   =   pm.iterationData.get(\"file_action_users_with_greater_logins_than\");\r",
							"        Users_with_greater_logins_than                       =   (typeof Users_with_greater_logins_than  !== 'undefined') ? Users_with_greater_logins_than : false;\r",
							"        pm.variables.set(\"Users_with_greater_logins_than\",               Users_with_greater_logins_than);  \r",
							"  \r",
							"        let Users_greater_logins_than                   =   pm.iterationData.get(\"file_users_with_greater_logins_than\");\r",
							"        Users_greater_logins_than                       =   (typeof Users_greater_logins_than  !== 'undefined') ? Users_greater_logins_than : 5;\r",
							"        pm.variables.set(\"Users_greater_logins_than\",               Users_greater_logins_than);\r",
							"\r",
							"\r",
							"        let Users_with_greater_logins_within_last_days                   =   pm.iterationData.get(\"file_action_users_with_greater_logins_within_last_days\");\r",
							"        Users_with_greater_logins_within_last_days                       =   (typeof Users_with_greater_logins_within_last_days  !== 'undefined') ? Users_with_greater_logins_within_last_days : false;\r",
							"        pm.variables.set(\"Users_with_greater_logins_within_last_days\",               Users_with_greater_logins_within_last_days);  \r",
							"  \r",
							"\r",
							"\r",
							"        let Users_logins_within_last_days                   =   pm.iterationData.get(\"file_users_with_logins_within_last_days\");\r",
							"        Users_logins_within_last_days                       =   (typeof Users_logins_within_last_days  !== 'undefined') ? Users_logins_within_last_days : 60;\r",
							"        pm.variables.set(\"Users_logins_within_last_days\",               Users_logins_within_last_days);\r",
							"\r",
							"\r",
							"\r",
							"        let Users_with_private_folder_content                   = pm.iterationData.get(\"file_action_users_with_private_folder_content\");\r",
							"        Users_with_private_folder_content                       = (typeof Users_with_private_folder_content  !== 'undefined') ? Users_with_private_folder_content : false;\r",
							"        pm.variables.set(\"Users_with_private_folder_content\",             Users_with_private_folder_content);\r",
							"\r",
							"        let Users_without_private_folder_content                = pm.iterationData.get(\"file_action_users_without_private_folder_content\");\r",
							"        Users_without_private_folder_content                    = (typeof Users_without_private_folder_content !== 'undefined') ? Users_without_private_folder_content : false;\r",
							"        pm.variables.set(\"Users_without_private_folder_content\",          Users_without_private_folder_content);\r",
							"        \r",
							"        let Users_with_public_content                           = pm.iterationData.get(\"file_action_users_that_created_public_content\");\r",
							"        Users_with_public_content                               = (typeof Users_with_public_content  !== 'undefined') ? Users_with_public_content : false;\r",
							"        pm.variables.set(\"Users_with_public_content\",                     Users_with_public_content);\r",
							"\r",
							"        let Users_did_not_create_public_content                 = pm.iterationData.get(\"file_action_users_that_did_not_create_public_content\");\r",
							"        Users_did_not_create_public_content                     = (typeof Users_did_not_create_public_content  !== 'undefined') ? Users_did_not_create_public_content : false;\r",
							"        pm.variables.set(\"Users_did_not_create_public_content\",           Users_did_not_create_public_content);\r",
							"\r",
							"        // just to be on the safe side, we shall unset some variables that get set later in the collection. We don't want to re-use the contents of these variables\r",
							"        pm.variables.unset(\"username_login_array\");             // remove the variable that will be set in the request READ Login Activity\r",
							"        pm.variables.unset(\"users_with_private_content_array\"); // remove the variable that will be set in  the request READ repository content\r",
							"        pm.variables.unset(\"users_with_public_content_array\");  // remove the variable that will be set in  the request READ repository content\r",
							"\r",
							"        const at_least_one_nonUsersThatAreManager_test =   (   Users_Match_All_Users\r",
							"                                                            || Users_Created_Recently\r",
							"                                                            || Users_With_BI_Concurrent_License\r",
							"                                                            || Users_With_BI_Named_User_License\r",
							"                                                            || Users_With_A_Manager\r",
							"                                                            || Users_With_Named_ManagerIDs\r",
							"                                                            || Users_Without_Manager\r",
							"                                                            || Users_Active\r",
							"                                                            || Users_Not_Active\r",
							"                                                            || Users_With_UserID_Ending_Underscore_1\r",
							"                                                            || Users_With_Email_Domain_Matching\r",
							"                                                            || Users_With_Email_Domain_Not_Matching\r",
							"                                                            || Users_With_A_Role_Or_A_Team\r",
							"                                                            || Users_With_No_Teams\r",
							"                                                            || Users_With_No_Roles\r",
							"                                                            || Users_With_All_Named_Roles\r",
							"                                                            || Users_LangDateTimeNumberFormats_Different_From\r",
							"                                                            || Users_created_more_than\r",
							"                                                            || Users_with_most_recent_login_at_least_days_ago\r",
							"                                                            || Users_with_most_recent_login_within_last_days_ago\r",
							"                                                            || Users_with_few_logins_than\r",
							"                                                            || Users_with_greater_logins_than\r",
							"                                                            || Users_with_private_folder_content\r",
							"                                                            || Users_without_private_folder_content\r",
							"                                                            || Users_with_public_content\r",
							"                                                            || Users_did_not_create_public_content);\r",
							"        \r",
							"\r",
							"\r",
							"        if (at_least_one_nonUsersThatAreManager_test || Users_That_Are_Managers)           \r",
							"        {\r",
							"            // there is at least one action_users test set to true which means its worth reading the users to determine if a team needs to be updated or not.\r",
							"            \r",
							"            // for the logic of processing 'UsersThatAreManagers' with the action 'replace', we need to know if there are any non-Users That Are Manager tests set\r",
							"            // so we shall save this binary value here and use it in the 'READ users page by page' request when processing Managers with the action 'replace'.\r",
							"            pm.variables.set(\"at_least_one_nonUsersThatAreManager_test\", at_least_one_nonUsersThatAreManager_test);\r",
							"\r",
							"            // we need to read the JSON_roles_to_exclude and add the namespace if it is missing\r",
							"            const corrected_roles_to_exclude_array = roles_to_exclude_array.map(myfunction_correct_role_definition);\r",
							"            const corrected_named_roles_array      = named_roles_array.map(myfunction_correct_role_definition);\r",
							"\r",
							"            pm.variables.set(\"Users_Roles_to_Exclude_Array\",corrected_roles_to_exclude_array);\r",
							"            pm.variables.set(\"Users_Named_Roles_Array\",corrected_named_roles_array);\r",
							"\r",
							"\r",
							"            function myfunction_correct_role_definition( value, index, array)\r",
							"            {\r",
							"                let new_role_definition;\r",
							"                let current_role_defintion=value.value;\r",
							"                if (current_role_defintion.indexOf(\"PROFILE:\")==0)\r",
							"                {\r",
							"                    return current_role_defintion;\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    new_role_definition=\"PROFILE:\".concat(pm.environment.get(\"ContentNamespace\"),\":\",current_role_defintion);\r",
							"                    return new_role_definition;\r",
							"                } // end if\r",
							"            }; // end myfunction_correct_role_definition\r",
							"\r",
							"\r",
							"\r",
							"            const valid_actions=[\"add\",\"remove\",\"replace\",\"intersect\",\"exclude\",\"excludeall\",\"invert\"];\r",
							"            if (valid_actions.includes(Users_Action))\r",
							"            {\r",
							"                // action is valid, so we can progress to READ all users\r",
							"                // lets see if we can add a filter to the GET /Users request so to speed things up.\r",
							"                // we can only add a filter for some actions, like add, remove, replace because otherwise we need to read the entire user population\r",
							"                // we can also only apply a filter on certain conditions like the username and email\r",
							"                // the logic below determines if a filter can be applied and what the value of that filter should be\r",
							"                // the logic is simple and combinations of rules are not included because its unlikely such combinations would actually be used\r",
							"\r",
							"                let filterenabled=false;\r",
							"\r",
							"                const actions_supported_to_enable_filter=[\"add\",\"remove\",\"replace\",\"intersect\"];\r",
							"                if (actions_supported_to_enable_filter.includes(Users_Action))\r",
							"                {\r",
							"                    let filtervalue = \"\"; // this variable will be used to store the filter value\r",
							"                    if ( (Users_With_Email_Domain_Matching) &&    !(Users_Match_All_Users\r",
							"                                                                || Users_Created_Recently\r",
							"                                                                || Users_With_BI_Concurrent_License\r",
							"                                                                || Users_With_BI_Named_User_License\r",
							"                                                                || Users_With_A_Manager\r",
							"                                                                || Users_With_Named_ManagerIDs\r",
							"                                                                || Users_Without_Manager\r",
							"                                                                || Users_Active\r",
							"                                                                || Users_Not_Active\r",
							"                                                                || Users_With_UserID_Ending_Underscore_1\r",
							"                                                                || Users_With_Email_Domain_Not_Matching\r",
							"                                                                || Users_With_A_Role_Or_A_Team\r",
							"                                                                || Users_With_No_Teams\r",
							"                                                                || Users_With_No_Roles\r",
							"                                                                || Users_With_All_Named_Roles\r",
							"                                                                || Users_LangDateTimeNumberFormats_Different_From\r",
							"                                                                || Users_created_more_than\r",
							"                                                                || Users_with_most_recent_login_at_least_days_ago\r",
							"                                                                || Users_with_most_recent_login_within_last_days_ago\r",
							"                                                                || Users_with_few_logins_than\r",
							"                                                                || Users_with_greater_logins_than\r",
							"                                                                || Users_with_private_folder_content\r",
							"                                                                || Users_without_private_folder_content\r",
							"                                                                || Users_with_public_content\r",
							"                                                                || Users_did_not_create_public_content ) )\r",
							"                    {\r",
							"                        // then we can enable the filter when we read all users\r",
							"                        filterenabled = true;\r",
							"                        filtervalue = \"email Ew \\\"@\".concat(Users_Email_Domain,\"\\\"\");\r",
							"                    };  // end if Users_With_Email_Domain_Matching\r",
							"\r",
							"                    if ( (Users_With_Email_Domain_Not_Matching) && !(Users_Match_All_Users\r",
							"                                                                || Users_Created_Recently\r",
							"                                                                || Users_With_BI_Concurrent_License\r",
							"                                                                || Users_With_BI_Named_User_License\r",
							"                                                                || Users_With_A_Manager\r",
							"                                                                || Users_With_Named_ManagerIDs\r",
							"                                                                || Users_Without_Manager\r",
							"                                                                || Users_Active\r",
							"                                                                || Users_Not_Active\r",
							"                                                                || Users_With_UserID_Ending_Underscore_1\r",
							"                                                                || Users_With_Email_Domain_Matching\r",
							"                                                                || Users_With_A_Role_Or_A_Team\r",
							"                                                                || Users_With_No_Teams\r",
							"                                                                || Users_With_No_Roles\r",
							"                                                                || Users_With_All_Named_Roles\r",
							"                                                                || Users_LangDateTimeNumberFormats_Different_From\r",
							"                                                                || Users_created_more_than\r",
							"                                                                || Users_with_most_recent_login_at_least_days_ago\r",
							"                                                                || Users_with_most_recent_login_within_last_days_ago\r",
							"                                                                || Users_with_few_logins_than\r",
							"                                                                || Users_with_greater_logins_than\r",
							"                                                                || Users_with_private_folder_content\r",
							"                                                                || Users_without_private_folder_content\r",
							"                                                                || Users_with_public_content\r",
							"                                                                || Users_did_not_create_public_content ) )\r",
							"                    {\r",
							"                        // then we can enable the filter when we read all users\r",
							"                        filterenabled = true;\r",
							"                        filtervalue = \"Not email Ew \\\"@\".concat(Users_Email_Domain,\"\\\"\");\r",
							"                    };  // end if Users_With_Email_Domain_Not_Matching\r",
							"\r",
							"                    if ( (Users_With_UserID_Ending_Underscore_1) && !(Users_Match_All_Users\r",
							"                                                                || Users_Created_Recently\r",
							"                                                                || Users_With_BI_Concurrent_License\r",
							"                                                                || Users_With_BI_Named_User_License\r",
							"                                                                || Users_With_A_Manager\r",
							"                                                                || Users_With_Named_ManagerIDs\r",
							"                                                                || Users_Without_Manager\r",
							"                                                                || Users_Active\r",
							"                                                                || Users_Not_Active\r",
							"                                                                || Users_With_Email_Domain_Matching\r",
							"                                                                || Users_With_Email_Domain_Not_Matching\r",
							"                                                                || Users_With_A_Role_Or_A_Team\r",
							"                                                                || Users_With_No_Teams\r",
							"                                                                || Users_With_No_Roles\r",
							"                                                                || Users_With_All_Named_Roles\r",
							"                                                                || Users_LangDateTimeNumberFormats_Different_From\r",
							"                                                                || Users_created_more_than\r",
							"                                                                || Users_with_most_recent_login_at_least_days_ago\r",
							"                                                                || Users_with_most_recent_login_within_last_days_ago\r",
							"                                                                || Users_with_few_logins_than\r",
							"                                                                || Users_with_greater_logins_than\r",
							"                                                                || Users_with_private_folder_content\r",
							"                                                                || Users_without_private_folder_content\r",
							"                                                                || Users_with_public_content\r",
							"                                                                || Users_did_not_create_public_content ) )\r",
							"                    {\r",
							"                        // then we can enable the filter when we read all users\r",
							"\r",
							"                        switch (pm.variables.get(\"SAMLSSO\"))\r",
							"                        {\r",
							"                            case 'custom':\r",
							"                            case 'email':\r",
							"                            {\r",
							"                                filterenabled = false; // The userName will NOT be the same as the userid and so we must disable the filter, that is on username, but we're looking for user ids!\r",
							"                                break;\r",
							"                            }\r",
							"                            case 'userid':\r",
							"                            case 'default':\r",
							"                            {\r",
							"                                filterenabled = true;        // for using the default IdP OR you are using SAML SSO and mapping on the userID\r",
							"                                break;\r",
							"                            }\r",
							"                        };\r",
							"                        filtervalue = \"username Ew \\\"_1\\\" or username Ew \\\"_2\\\"\";       // it is really unlikely that _2 users will be have been created but we will search for them just in case!\r",
							"                    }; // end if \r",
							"\r",
							"                    if (filterenabled)\r",
							"                    {\r",
							"                        pm.variables.set(\"filtervalue\",filtervalue);\r",
							"                        console.info(pm.info.requestName+' '+pm.info.eventName+': Filtering enabled: '+filtervalue);\r",
							"                        // for more information on filtering https://help.sap.com/viewer/298f82da4b184d1fb825b7ffe365e94a/LATEST/en-US/da3dc52a0fd44da4b727c89d26326af6.html\r",
							"\r",
							"                        if ( (Users_Action === \"replace\") || (Users_Action === \"intersect\"))\r",
							"                        {\r",
							"                            // for the action 'replace' and given that we have enabled filtering, it means we will NOT be processing each and every user in SAC\r",
							"                            // this means there could be users in the existing team that we won't process, and for these users they should be removed from the team\r",
							"                            // so we will need to move ALL the existing users of the team into the 'removelist' and the let the logic of the 'replace' and 'intersect'\r",
							"                            // remove users from the remove list if they are found. This will mean, any users left of the removelist will be ones that need to be removed.\r",
							"                            this_team.arrayofusers_waiting_to_be_removed_in_this_batch=this_team.members.slice();\r",
							"                        };\r",
							"                    };\r",
							"\r",
							"\r",
							"                    if ( Multiple_Operator_is_AND && at_least_one_nonUsersThatAreManager_test && Users_That_Are_Managers )\r",
							"                    {\r",
							"                        console.warn(pm.info.requestName+' '+pm.info.eventName+': Users_That_Are_Managers will only perform an \\'OR\\' operation with other user tests, even though the \\'AND\\' operation is supported between other, non-Users_That_Are_Managers user tests');\r",
							"                    };\r",
							"\r",
							"                } // end if actions_supported_to_enable_filer\r",
							"                else\r",
							"                {\r",
							"                    // we don't need to update the variable filter, we shall leave it as false\r",
							"                };\r",
							"                \r",
							"                pm.variables.set(\"filterenabled\",filterenabled);  // store the variable to a filter can be applied to the GET /Users request so to limit the number of users returned which will speed things up a little!\r",
							"\r",
							"                array_of_teams[this_team_index]=this_team;\r",
							"                pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[0].teamname);\r",
							"                pm.variables.set(\"StartUserIndex\",1);\r",
							"                pm.variables.set(\"ReadUsersIndexSize\",parseInt(pm.collectionVariables.get(\"initial_read_index_size\")));\r",
							"    \r",
							"\r",
							"                const need_to_read_activities_log = (              Users_with_most_recent_login_at_least_days_ago\r",
							"                                                                || Users_with_most_recent_login_within_last_days_ago\r",
							"                                                                || Users_with_few_logins_than\r",
							"                                                                || Users_with_greater_logins_than );\r",
							"                                                                \r",
							"                const need_to_read_content        = (              Users_with_private_folder_content\r",
							"                                                                || Users_without_private_folder_content\r",
							"                                                                || Users_with_public_content\r",
							"                                                                || Users_did_not_create_public_content );\r",
							"                \r",
							"                if (need_to_read_activities_log)\r",
							"                {\r",
							"                    pm.execution.setNextRequest(); \r",
							"                }\r",
							"                else if (need_to_read_content)\r",
							"                {\r",
							"                    pm.execution.setNextRequest('READ repository content'); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    pm.execution.setNextRequest('READ users page by page');  \r",
							"                }\r",
							"\r",
							"\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid action: '+Users_Action+'. Supported actions: add, remove, replace, intersect, exclude, excludeall and invert. Aborting!');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': No action_users tests are set to true. Nothing to do. Aborting!');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"\r",
							"        break;\r",
							"    }  // end case is 200\r",
							"    \r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);  // repeat this call and re-attempt it\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);  // repeat this call and re-attempt it\r",
							"        }\r",
							"        ;\r",
							"   }  // end case default\r",
							"}; // end switch"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team '+pm.iterationData.get(\"file_team\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ oldest activities log entry",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.info(pm.info.requestName+' '+pm.info.eventName+': Reading oldest log entry');\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Reading oldest log entry\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200: \r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"\r",
							"        const Users_with_most_recent_login_at_least_days_ago    =  pm.variables.get(\"Users_with_most_recent_login_at_least_days_ago\");\r",
							"        const Users_with_most_recent_login_days_ago_days        =  pm.variables.get(\"Users_with_most_recent_login_days_ago_days\");\r",
							"\r",
							"\r",
							"        const Users_with_most_recent_login_within_last_days_ago   =   pm.variables.get(\"Users_with_most_recent_login_within_last_days_ago\");\r",
							"        const Users_with_most_recent_login_days_within_last_days  =   pm.variables.get(\"Users_with_most_recent_login_days_within_last_days\");\r",
							"\r",
							"        const Users_with_few_logins_than                        =  pm.variables.get(\"Users_with_few_logins_than\");\r",
							"        const Users_with_fewer_logins_within_last_days          =  pm.variables.get(\"Users_with_fewer_logins_within_last_days\");\r",
							"\r",
							"        const Users_logins_within_last_days                     =  pm.variables.get(\"Users_logins_within_last_days\");\r",
							"\r",
							"        const Users_with_greater_logins_than                    =  pm.variables.get(\"Users_with_greater_logins_than\");  \r",
							"        const Users_with_greater_logins_within_last_days        =  pm.variables.get(\"Users_with_greater_logins_within_last_days\");  \r",
							"\r",
							"\r",
							"\r",
							"        const lines = pm.response.text().split('\\n');  // lines is an array, each element is a row\r",
							"        lines.splice(0, 4);                  // lines has the first 5 lines removed from it, as this is the header\r",
							"         let columns_array = lines[0].split('\",\"');          // split each row into columns\r",
							"        \r",
							"        while (columns_array.length<8)\r",
							"        {\r",
							"            // we have fewer columns than we expect. It means the description column has carriage returns in it and we need to 'shift' the rows below up, and join it to this row, minus the carriage returns\r",
							"            lines[0]=lines[0].concat(\" \",lines[1]);\r",
							"            lines.splice(1,1);\r",
							"            columns_array = lines[0].split('\",\"');  \r",
							"        }\r",
							"\r",
							"        let timezone_hours   = parseInt(pm.variables.get(\"TimeZoneHours\"));\r",
							"        let timezone_minutes = parseInt(pm.variables.get(\"TimeZoneMinutes\"));\r",
							"        if ((timezone_hours   === undefined)|| (!Number.isInteger(timezone_hours  )))  { timezone_hours   = - Math.floor((new Date().getTimezoneOffset())/60) };\r",
							"        if ((timezone_minutes === undefined)|| (!Number.isInteger(timezone_minutes)))  { timezone_minutes = -            (new Date().getTimezoneOffset())%60  };\r",
							"\r",
							"\r",
							"        let oldest_date_GMT = columns_array[7] // get the timestamp from row 1 (index0) in the 8th column (index7)\r",
							"        let oldestdate_this_time_zone= new Date(oldest_date_GMT);\r",
							"        \r",
							"        oldestdate_this_time_zone.setHours(oldestdate_this_time_zone.getHours()     + timezone_hours);    // we add (or substract) the hours depending upon the timezone\r",
							"        oldestdate_this_time_zone.setMinutes(oldestdate_this_time_zone.getMinutes() + timezone_minutes);  // we add (or substract) the minutes depending upon the timezone\r",
							"\r",
							"        const todays_date = new Date();\r",
							"        todays_date.setHours(todays_date.getHours()  + timezone_hours );\r",
							"        todays_date.setMinutes(todays_date.getMinutes() + todays_date.getTimezoneOffset() + timezone_minutes );\r",
							"        let todays_date_my_timezone= new Date(todays_date.getFullYear().toString().concat(\".\",(\"0\"+(todays_date.getMonth()+1)).slice(-2),\".\",(\"0\"+todays_date.getDate()).slice(-2),\r",
							"                                                                                        \" \",(\"0\"+todays_date.getHours()).slice(-2),\r",
							"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\":\",(\"0\"+todays_date.getMinutes()).slice(-2),\r",
							"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\":\",(\"0\"+todays_date.getSeconds()).slice(-2 )));\r",
							"\r",
							"        let oldest_activities_log_entry_in_days = Math.floor( (todays_date_my_timezone-oldestdate_this_time_zone) / (1000 * 3600 * 24) )\r",
							"\r",
							"        pm.variables.set(\"oldest_activities_log_entry_in_days\",oldest_activities_log_entry_in_days);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': The oldest log entry found was for '+oldestdate_this_time_zone+' which was '+oldest_activities_log_entry_in_days+' days ago');\r",
							"\r",
							"        pm.execution.setNextRequest();\r",
							"\r",
							"        if (Users_with_most_recent_login_at_least_days_ago && (Users_with_most_recent_login_days_ago_days>oldest_activities_log_entry_in_days) )\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Aborting because the oldest activities log is only '+oldest_activities_log_entry_in_days+' days ago, but the test for Users_with_most_recent_login_at_least_days_ago is true and the file_users_with_with_most_recent_login_at_least_days is '+Users_with_most_recent_login_days_ago_days+'. This means it is not possible to accurately test if a user has a more recent login within this time frame because the logs are not old enough.');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"\r",
							"        if (Users_with_most_recent_login_within_last_days_ago && (Users_with_most_recent_login_days_within_last_days>oldest_activities_log_entry_in_days) )\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Aborting because the oldest activities log is only '+oldest_activities_log_entry_in_days+' days ago, but the test for Users_with_most_recent_login_within_last_days is true and the file_users_with_with_most_recent_login_within_last_days is '+Users_with_most_recent_login_days_within_last_days+'. This means it is not possible to accurately test if a user has a more recent login within this time frame because the logs are not old enough.');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"        if (Users_with_few_logins_than && Users_with_fewer_logins_within_last_days &&(Users_logins_within_last_days>oldest_activities_log_entry_in_days))\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Aborting because the oldest activities log is only '+oldest_activities_log_entry_in_days+' days ago, but the test for Users_with_few_logins_than and Users_with_fewer_logins_within_last_days are true and the Users_logins_within_last_days is '+Users_logins_within_last_days+'. This means it is not possible to accurately test if a user has fewer logins within this time frame because the logs are not old enough.');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"\r",
							"        if (Users_with_greater_logins_than && Users_with_greater_logins_within_last_days &&(Users_logins_within_last_days>oldest_activities_log_entry_in_days))\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Aborting because the oldest activities log is only '+oldest_activities_log_entry_in_days+' days ago, but the test for Users_with_greater_logins_than and Users_with_greater_logins_within_last_days are true and the Users_logins_within_last_days is '+Users_logins_within_last_days+'. This means it is not possible to accurately test if a user has more logins within this time frame because the logs are not old enough.');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"\r",
							"        break;\r",
							"    }  // end case 200\r",
							"\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";\r",
							"}; // end switch pm.response.code"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": ""
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/audit/activities/exportActivities?pageSize=1&pageIndex=1&sortKey=Timestamp&sortDescending=false",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"audit",
						"activities",
						"exportActivities"
					],
					"query": [
						{
							"key": "pageSize",
							"value": "1",
							"description": "If enabled it limits the number of records (rows) returned in each page."
						},
						{
							"key": "pageIndex",
							"value": "1"
						},
						{
							"key": "sortKey",
							"value": "Timestamp"
						},
						{
							"key": "sortDescending",
							"value": "false"
						},
						{
							"key": "Cache-Control",
							"value": "no-cache",
							"description": "if enabled, the data is 'fetched' again from the model which has a performance impact, but it dies mean any changes made will be reflected\n",
							"disabled": true
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "READ login activity",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"let pageIndex=pm.variables.get(\"pageIndex\");\r",
							"let total_pages=pm.variables.get(\"total_pages\");\r",
							"\r",
							"if ( (pageIndex===undefined) || (total_pages===undefined))\r",
							"{\r",
							"    pageIndex=1;\r",
							"    pm.variables.set(\"pageIndex\",pageIndex);\r",
							"    pm.variables.unset(\"username_login_array\");\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Downloading login activities page '+pageIndex);\r",
							"}\r",
							"else\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Downloading login activities page '+pageIndex+' of '+total_pages);\r",
							"}\r",
							"\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Reading activities log for login events\", function () {\r",
							"    pm.expect(pm.response.code).to.be.oneOf([200, 401, 403, 429])\r",
							"}\r",
							");\r",
							"\r",
							"switch (pm.response.code) {\r",
							"    case 401:  // same as 403\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter = pm.response.headers.get('Retry-After') ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.info(pm.info.requestName + ' ' + pm.info.eventName + ': SAP Analytics Cloud is receiving too many requests. Retrying in ' + retryafter + 'ms');\r",
							"        setTimeout(() => { }, retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\", 0);\r",
							"\r",
							"        // write to the console, the 7th column of the 4th row of data.\r",
							"        // we need to split the pm.response.text() by carriage return, then find the 4th row. We then split this row by comma and output the 7th column which contains the Timestamp\r",
							"        // this Timestamp will be the timestamp of the oldest record in the acitivies log becasue the request params are set to NOT sortDescending\r",
							"        // finally we remove any quotes \" which will be at the start and end of the string\r",
							"\r",
							"        const lines = pm.response.text().split('\\n');  // lines is an array, each element is a row\r",
							"        lines.splice(0, 4);         // lines has the first 5 lins removed from it, as this is the header\r",
							"        lines.splice(lines.length - 1, 1);                  // we don't want the last line because this is always empty\r",
							"        const total_pages = pm.response.headers.get('epm-page-count'); // the total number of pages there are for this query\r",
							"        let pageIndex = pm.variables.get(\"pageIndex\");  // the pageIndex that was last read\r",
							"\r",
							"        let username_login_array = pm.variables.get(\"username_login_array\");\r",
							"        if (!username_login_array) {username_login_array = []}\r",
							"\r",
							"\r",
							"        const Users_with_few_logins_than                        =  pm.variables.get(\"Users_with_few_logins_than\");\r",
							"        const Users_with_fewer_logins_within_last_days          =  pm.variables.get(\"Users_with_fewer_logins_within_last_days\");\r",
							" \r",
							"\r",
							"        const Users_with_greater_logins_than                    =  pm.variables.get(\"Users_with_greater_logins_than\");  \r",
							"        const Users_with_greater_logins_within_last_days        =  pm.variables.get(\"Users_with_greater_logins_within_last_days\");  \r",
							"\r",
							"\r",
							"        const Users_logins_within_last_days                     =  pm.variables.get(\"Users_logins_within_last_days\");\r",
							"\r",
							"\r",
							"\r",
							"        let timezone_hours   = parseInt(pm.variables.get(\"TimeZoneHours\"));\r",
							"        let timezone_minutes = parseInt(pm.variables.get(\"TimeZoneMinutes\"));\r",
							"        if ((timezone_hours   === undefined)|| (!Number.isInteger(timezone_hours  )))  { timezone_hours   = - Math.floor((new Date().getTimezoneOffset())/60) };\r",
							"        if ((timezone_minutes === undefined)|| (!Number.isInteger(timezone_minutes)))  { timezone_minutes = -            (new Date().getTimezoneOffset())%60  };\r",
							"\r",
							"\r",
							"\r",
							"        const todays_date = new Date();\r",
							"        todays_date.setHours(todays_date.getHours()  + timezone_hours );\r",
							"        todays_date.setMinutes(todays_date.getMinutes() + todays_date.getTimezoneOffset() + timezone_minutes );\r",
							"        let todays_date_my_timezone= new Date(todays_date.getFullYear().toString().concat(\".\",(\"0\"+(todays_date.getMonth()+1)).slice(-2),\".\",(\"0\"+todays_date.getDate()).slice(-2),\r",
							"                                                                                        \" \",(\"0\"+todays_date.getHours()).slice(-2),\r",
							"                                                                                        \":\",(\"0\"+todays_date.getMinutes()).slice(-2),\r",
							"                                                                                        \":\",(\"0\"+todays_date.getSeconds()).slice(-2 )));\r",
							"\r",
							"        for (let line=0; line<lines.length; line++)\r",
							"        {\r",
							"            let columns_array = lines[line].split('\",\"');          // split each row into columns\r",
							"        \r",
							"            while (columns_array.length<8)\r",
							"            {\r",
							"                // we have fewer columns than we expect. It means the description column has carriage returns in it and we need to 'shift' the rows below up, and join it to this row, minus the carriage returns\r",
							"                lines[line]=lines[line].concat(\" \",lines[line+1]);\r",
							"                lines.splice(line+1,1);\r",
							"                columns_array = lines[line].split('\",\"');  \r",
							"            }\r",
							"            \r",
							"            const login_timestamp=new Date(columns_array[7]); \r",
							"            login_timestamp.setHours(login_timestamp.getHours()     + timezone_hours);    // we add (or substract) the hours depending upon the timezone\r",
							"            login_timestamp.setMinutes(login_timestamp.getMinutes() + timezone_minutes);  // we add (or substract) the minutes depending upon the timezone\r",
							"            let number_of_days_since_last_login = Math.floor( ((todays_date_my_timezone-login_timestamp)) / (1000 * 3600 * 24) ) \r",
							"            let last_login_date_mytimezone=login_timestamp.getFullYear().toString().concat(\".\",\r",
							"                                                                    (\"0\"+(login_timestamp.getMonth()+1)).slice(-2),\".\",\r",
							"                                                                    (\"0\"+ login_timestamp.getDate()).slice(-2),\" \",\r",
							"                                                                    (\"0\"+ login_timestamp.getHours()).slice(-2),\":\",\r",
							"                                                                    (\"0\"+ login_timestamp.getMinutes()).slice(-2),\":\",\r",
							"                                                                    (\"0\"+ login_timestamp.getSeconds()).slice(-2)\r",
							"                                                                    );\r",
							"\r",
							"            let username=columns_array[2];\r",
							"\r",
							"            const count_this_login_event =\r",
							"                                            (\r",
							"                                                (\r",
							"                                                    (   ( Users_with_few_logins_than     && Users_with_fewer_logins_within_last_days  )\r",
							"                                                    ||  ( Users_with_greater_logins_than && Users_with_greater_logins_within_last_days)\r",
							"                                                    )\r",
							"                                                    && \r",
							"                                                        ( Users_logins_within_last_days >= number_of_days_since_last_login )\r",
							"                                                )\r",
							"                                            ||\r",
							"                                                (\r",
							"                                                    (   ( Users_with_few_logins_than     && !Users_with_fewer_logins_within_last_days  )\r",
							"                                                    ||  ( Users_with_greater_logins_than && !Users_with_greater_logins_within_last_days)\r",
							"                                                    )  \r",
							"                                                )\r",
							"                                            ) ? 1 : 0;\r",
							"                                            // we store a value of 1 if we want to count this event, otherwise we store 0\r",
							"                                            // this allows us to update the most recent login event as a separate tally of the number of logins which may need to be different\r",
							"             \r",
							"\r",
							"\r",
							"            let user_entry_index = username_login_array.findIndex( user_entry => user_entry.username===username)\r",
							"            if (user_entry_index>=0)\r",
							"            {\r",
							"                // user found in the array\r",
							"                username_login_array[user_entry_index].days_since_last_login     =number_of_days_since_last_login;\r",
							"                username_login_array[user_entry_index].total_logins              =username_login_array[user_entry_index].total_logins+count_this_login_event; // this means we could have a login count of 0! \r",
							"                                                                                                                                                              // This happens when the login event is outside the Users_logins_within_last_days\r",
							"                //username_login_array[user_entry_index].last_login_date_mytimezone=last_login_date_mytimezone;\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // user not found, so we must add it\r",
							"                \r",
							"                let new_user_entry={\r",
							"                    \"username\":username,\r",
							"                    \"days_since_last_login\":number_of_days_since_last_login,\r",
							"                    \"total_logins\":count_this_login_event,\r",
							"                    //\"last_login_date_mytimezone\":last_login_date_mytimezone \r",
							"                    };\r",
							"\r",
							"                username_login_array.push( new_user_entry );\r",
							"            }\r",
							"\r",
							"            \r",
							"\r",
							"        }\r",
							"        \r",
							"        pm.variables.set(\"username_login_array\",username_login_array);\r",
							"\r",
							"        if (pageIndex < total_pages)  // decide if we've read all the pages possible \r",
							"        {\r",
							"            // we need to read more pages to get all the data back. So we repeat this request, just with the next pageIndex increased by 1\r",
							"            pageIndex++;\r",
							"            pm.variables.set(\"pageIndex\", pageIndex);\r",
							"            pm.variables.set(\"total_pages\", total_pages);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else {\r",
							"            // we've read all the pages\r",
							"            pm.variables.unset(\"pageIndex\");\r",
							"            pm.variables.unset(\"total_pages\");\r",
							"\r",
							"            const Users_with_private_folder_content                   = pm.variables.get(\"Users_with_private_folder_content\");\r",
							"            const Users_without_private_folder_content                = pm.variables.get(\"Users_without_private_folder_content\");\r",
							"            const Users_with_public_content                           = pm.variables.get(\"Users_with_public_content\");\r",
							"            const Users_did_not_create_public_content                 = pm.variables.get(\"Users_did_not_create_public_content\");\r",
							"\r",
							"            const need_to_read_content        = (              Users_with_private_folder_content\r",
							"                                                            || Users_without_private_folder_content\r",
							"                                                            || Users_with_public_content\r",
							"                                                            || Users_did_not_create_public_content );\r",
							"\r",
							"            if (need_to_read_content)\r",
							"            {\r",
							"                pm.execution.setNextRequest();\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                pm.execution.setNextRequest(\"READ users page by page\");\r",
							"            }\r",
							"            \r",
							"\r",
							"        }\r",
							"        break;\r",
							"    }  // end case 200\r",
							"\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors = pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors = 0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\", errors);\r",
							"        const maxerrors = 3;  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"        // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"        // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors) {\r",
							"            console.error(pm.info.requestName + ' ' + pm.info.eventName + ': Too many continuous errors. Aborting. Response: ' + pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\", 0);\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2) {\r",
							"            console.warn(pm.info.requestName + ' ' + pm.info.eventName + ': Continuous errors detected. Response: ' + pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else {\r",
							"            console.warn(pm.info.requestName + ' ' + pm.info.eventName + ': Unexpected error. Response: ' + pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"    }\r",
							"    ;\r",
							"}; // end switch pm.response.code"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n   \"activity\":\"Login\"\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/audit/activities/exportActivities?pageIndex={{pageIndex}}&sortKey=Timestamp&sortDescending=false",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"audit",
						"activities",
						"exportActivities"
					],
					"query": [
						{
							"key": "pageSize",
							"value": "10",
							"description": "If enabled it limits the number of records (rows) returned in each page. Set this to 100000 and its best not to adjust this setting unless you get errors that could mean the volume of data is too large for the API to handle",
							"disabled": true
						},
						{
							"key": "pageIndex",
							"value": "{{pageIndex}}"
						},
						{
							"key": "sortKey",
							"value": "Timestamp"
						},
						{
							"key": "sortDescending",
							"value": "false"
						},
						{
							"key": "Cache-Control",
							"value": "no-cache",
							"disabled": true
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "READ repository content",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ repository content\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end case response is 401\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        // load the response into a variable 'resources'\r",
							"        const resources = JSON.parse(pm.response.text())[\"d\"].results.map(myfunction_simplify_resource);\r",
							"\r",
							"        function myfunction_simplify_resource(resourcevalue)\r",
							"        {\r",
							"            let corrected_resource_path=JSON.parse(resourcevalue.ancestorPath).reduce ( myfunction_return_path_as_string, \"\")\r",
							"            function myfunction_return_path_as_string( path, folder)\r",
							"            {\r",
							"                // the array of path is not consistent, for example some folders would store a folder as: \"[\"Public\",\"SAP_Content\",\"Story\"]\"\r",
							"                // when another may store it as \"[\"/\",\"\",\"Public\",\"SAP_Content\",\"Story\"]\"\r",
							"                // So we must normalise the path and we can do that by creating a simple string for the path, rather than an array\r",
							"                if (( folder==='\"') || (folder==='/') || (folder===''))\r",
							"                {\r",
							"                    // if an array value is a \" or / or just null, then we should ignore it.\r",
							"                    return path;\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // otherwise, we need to add the folder to the path\r",
							"                    return path+\"/\"+folder;\r",
							"                }\r",
							"            }; // end myfunction_return_path_as_string\r",
							"\r",
							"            let stored_in_private_folder = false;\r",
							"            let top_parent_folder        = corrected_resource_path.split(\"/\")[1];\r",
							"            let username_extracted_from_folder_name = '';\r",
							"            \r",
							"            switch (top_parent_folder)\r",
							"            {\r",
							"                case 'Users':\r",
							"                {\r",
							"                    // grab the 2nd level foldername and extract the first word before the space character \r",
							"                    //  for example '/Users/ADMIN Private' we extract ADMIN\r",
							"                    try {\r",
							"                        username_extracted_from_folder_name = corrected_resource_path.split(\"/\")[2].split(\" \")[0]; \r",
							"                        stored_in_private_folder            = true;\r",
							"                    }\r",
							"                    catch {\r",
							"                        stored_in_private_folder            = false;\r",
							"                    }\r",
							"                    break;\r",
							"                }\r",
							"                \r",
							"                case 'WORKSPACE':\r",
							"                {\r",
							"                    // grab the 3rd level foldername and extract the first word before the space character\r",
							"                    //  for example '/WORKSPACE/Users/ADMIN Private' we extract ADMIN\r",
							"                    try {\r",
							"                        username_extracted_from_folder_name = corrected_resource_path.split(\"/\")[3].split(\" \")[0];\r",
							"                        stored_in_private_folder            = true;\r",
							"                    }\r",
							"                    catch {\r",
							"                        stored_in_private_folder            = false;\r",
							"                    }\r",
							"                    break;\r",
							"                }\r",
							"\r",
							"                case 'Input Forms':\r",
							"                {\r",
							"                    // Input Forms need to be ignored\r",
							"                    stored_in_private_folder=false;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    // The top level folder is something else\r",
							"                    //  for example it might be something like:\r",
							"                    //          /Public/SAP_Content/SAP_FI_Consolidation\r",
							"                    //      or  /ADMIN Private\r",
							"                    let top_parent_folder_has_space_character =  /\\s/g.test(top_parent_folder);\r",
							"\r",
							"                    if (top_parent_folder_has_space_character)\r",
							"                    {\r",
							"                        // then the folder is a user folder, like /ADMIN Private\r",
							"                        // so we grab the username from the first word before the space\r",
							"                        username_extracted_from_folder_name=top_parent_folder.split(\" \")[0];\r",
							"                        stored_in_private_folder = true;\r",
							"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        // its something like:  \\Public   or   \\SYSTEM\r",
							"                        stored_in_private_folder = false;\r",
							"                    }\r",
							"                    break;\r",
							"\r",
							"                }\r",
							"            };\r",
							"\r",
							"            return {\r",
							"                stored_in_private_folder: stored_in_private_folder,\r",
							"                username_of_private_folder: username_extracted_from_folder_name,\r",
							"                resource_created_by: resourcevalue.createdBy\r",
							"            }\r",
							"        }\r",
							"\r",
							"\r",
							"        const users_with_private_content_array=resources.reduce( function_unique_private_users, []);\r",
							"        \r",
							"        function function_unique_private_users(unique_users, this_resource)\r",
							"        {\r",
							"\r",
							"            const user_already_in_array=unique_users.find( user=> (user===this_resource.username_of_private_folder) ) ;\r",
							"            if (user_already_in_array)\r",
							"            {\r",
							"                return unique_users\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                if (this_resource.stored_in_private_folder===true)\r",
							"                {\r",
							"                    return [...unique_users,this_resource.username_of_private_folder] \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return unique_users\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"\r",
							"        const users_with_public_content_array=resources.reduce( function_unique_public_users, []);\r",
							"        \r",
							"        function function_unique_public_users(unique_users, this_resource)\r",
							"        {\r",
							"\r",
							"            const user_already_in_array=unique_users.find( user=> (user===this_resource.resource_created_by) ) ;\r",
							"            if (user_already_in_array)\r",
							"            {\r",
							"                return unique_users\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                if ( (this_resource.stored_in_private_folder===false) && (this_resource.resource_created_by!=''))\r",
							"                {\r",
							"                    return [...unique_users,this_resource.resource_created_by] \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return unique_users\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"\r",
							"        \r",
							"\r",
							"        pm.variables.set(\"users_with_private_content_array\",users_with_private_content_array);\r",
							"        pm.variables.set(\"users_with_public_content_array\",users_with_public_content_array);\r",
							"        break;\r",
							"    }\r",
							"    default:  // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"    };\r",
							"\r",
							"} // end switch response code"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"console.info(pm.info.requestName+' '+pm.info.eventName+': Reading repository content');"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "$format",
						"value": "json",
						"type": "text"
					},
					{
						"key": "resourceTypes",
						"value": "STORY",
						"type": "text",
						"disabled": true
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/Repositories?$format=json&$select=createdBy,ancestorPath",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"Repositories"
					],
					"query": [
						{
							"key": "$format",
							"value": "json"
						},
						{
							"key": "$select",
							"value": "createdBy,ancestorPath"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "READ users page by page",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ users page by page\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"if (!array_of_teams) { array_of_teams=[] };\r",
							"const this_team_index = array_of_teams.findIndex(element => element.teamname === pm.variables.get(\"currentteam\"));\r",
							"const this_team = array_of_teams[this_team_index];\r",
							"\r",
							"let users_waiting_to_be_added_in_this_batch    = this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"let users_waiting_to_be_removed_in_this_batch  = this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"let managers  = pm.variables.get(\"managers\");     // this is a special variable used to store users that are managers. It is needed to process file_action_users_that_are_managers\r",
							"let all_users = pm.variables.get(\"all_users\");   // this is also a special variable and used to process file_action_users_that_are_managers but only for the actions excludeall and invert\r",
							"\r",
							"if (!managers)  { managers  = [] };\r",
							"if (!all_users) { all_users = [] };\r",
							"\r",
							"if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        break;\r",
							"    }\r",
							"    case 200:\r",
							"    {\r",
							"\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody                          = JSON.parse(pm.response.text());\r",
							"        const StartUserIndex                    = pm.variables.get(\"StartUserIndex\");\r",
							"        let   ReadUsersIndexSize                = pm.variables.get(\"ReadUsersIndexSize\");          \r",
							"        const total_users_in_this_SAC_service   = readbody.totalResults;\r",
							"        const users_this_page                   = readbody.Resources.length;\r",
							"        let   max_index_size                    = pm.variables.get(\"MaxIndexSize\");\r",
							"        const filterenabled                     = pm.variables.get(\"filterenabled\");\r",
							"        let   current_datetime                  = new Date();  // we need the current datetime for processing recently created users\r",
							"    \r",
							"        if (readbody.itemsPerPage<ReadUsersIndexSize)\r",
							"        {  // we requested more users than SAC provided and so SAC is limiting the number of users we can read per page\r",
							"        // confusingly readbody.itemsPerPage will be 200, even when the number of users returned could be just 5 (i.e. less than 200).\r",
							"        // this means this code will only be executed if we ask for more users than we got back (even when the number of users is less than what we asked for)\r",
							"            max_index_size = readbody.itemsPerPage;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Maximum index size set by SAP Anlaytics Cloud is '+max_index_size);\r",
							"            pm.variables.set(\"MaxIndexSize\",       max_index_size);\r",
							"            pm.variables.set(\"ReadUsersIndexSize\", max_index_size); \r",
							"        };\r",
							"        const max_user_index_this_page = StartUserIndex + users_this_page -1;\r",
							"        const users_per_second = Math.round((users_this_page/(pm.response.responseTime/1000))*10)/10;\r",
							"        \r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Analysing '+users_this_page+' users '+StartUserIndex+' to '+max_user_index_this_page+' (throughput: '+users_per_second+' users/sec) of '+total_users_in_this_SAC_service);\r",
							"        let users_found_this_page = 0;\r",
							"        let managers_found_this_page = 0;\r",
							"        // let users_to_add_this_page = 0;      // these variables are used in commented-out console logs\r",
							"        // let users_to_remove_this_page = 0;   // these variables are used in commented-out console logs\r",
							"\r",
							"\r",
							"        const Users_Action                                  = pm.variables.get(\"Users_Action\");\r",
							"        const Users_To_Exclude_Array                        = pm.variables.get(\"Users_To_Exclude_Array\");\r",
							"        const Multiple_Operator_is_AND                      = pm.variables.get(\"Multiple_Operator_is_AND\");\r",
							"        const Users_Match_All_Users                         = pm.variables.get(\"Users_Match_All_Users\");\r",
							"        const Users_Created_Recently                        = pm.variables.get(\"Users_Created_Recently\");\r",
							"        const Users_Created_Recently_In_Days                = pm.variables.get(\"Users_Created_Recently_In_Days\");\r",
							"        const Users_With_BI_Concurrent_License              = pm.variables.get(\"Users_With_BI_Concurrent_License\");\r",
							"        const Users_With_BI_Named_User_License              = pm.variables.get(\"Users_With_BI_Named_User_License\");\r",
							"        const Users_With_A_Manager                          = pm.variables.get(\"Users_With_A_Manager\");\r",
							"        const Users_With_Named_ManagerIDs                   = pm.variables.get(\"Users_With_Named_ManagerIDs\");\r",
							"        const Users_Named_ManagerIDs                        = pm.variables.get(\"Users_Named_ManagerIDs\");\r",
							"        const Users_Without_Manager                         = pm.variables.get(\"Users_Without_Manager\");\r",
							"        const Users_That_Are_Managers                       = pm.variables.get(\"Users_That_Are_Managers\");\r",
							"        const Users_Active                                  = pm.variables.get(\"Users_Active\");\r",
							"        const Users_Not_Active                              = pm.variables.get(\"Users_Not_Active\");\r",
							"        const Users_With_UserID_Ending_Underscore_1         = pm.variables.get(\"Users_With_UserID_Ending_Underscore_1\");\r",
							"        const Users_With_Email_Domain_Matching              = pm.variables.get(\"Users_With_Email_Domain_Matching\");\r",
							"        const Users_With_Email_Domain_Not_Matching          = pm.variables.get(\"Users_With_Email_Domain_Not_Matching\");\r",
							"        const Users_Email_Domain                            = pm.variables.get(\"Users_Email_Domain\");\r",
							"        const Users_With_A_Role_Or_A_Team                   = pm.variables.get(\"Users_With_A_Role_Or_A_Team\");\r",
							"        const Users_With_No_Teams                           = pm.variables.get(\"Users_With_No_Teams\");\r",
							"        const Teams_To_Exclude_Array                        = pm.variables.get(\"Users_Teams_to_Exclude_Array\");\r",
							"        const Teamnames_StartsWith_to_Exclude_Array         = pm.variables.get(\"Users_Teamnames_StartsWith_to_Exclude_Array\");\r",
							"        const Users_With_No_Roles                           = pm.variables.get(\"Users_With_No_Roles\");\r",
							"        const Roles_To_Exclude_Array                        = pm.variables.get(\"Users_Roles_to_Exclude_Array\");\r",
							"        const Users_With_All_Named_Roles                    = pm.variables.get(\"Users_With_All_Named_Roles\");\r",
							"        const Users_Named_Roles_Array                       = pm.variables.get(\"Users_Named_Roles_Array\");\r",
							"        const Users_LangDateTimeNumberFormats_Different_From= pm.variables.get(\"Users_LangDateTimeNumberFormats_Different_From\");\r",
							"        const Users_preferredlanguage                       = pm.variables.get(\"Users_preferredlanguage\");\r",
							"        const Users_dataaccesslanguage                      = pm.variables.get(\"Users_dataaccesslanguage\");\r",
							"        const Users_dateformatting                          = pm.variables.get(\"Users_dateformatting\");\r",
							"        const Users_timeformatting                          = pm.variables.get(\"Users_timeformatting\");\r",
							"        const Users_numberformatting                        = pm.variables.get(\"Users_numberformatting\");\r",
							"        const Users_created_more_than                           =  pm.variables.get(\"Users_created_more_than\");\r",
							"        const Users_created_more_than_days                      =  pm.variables.get(\"Users_created_more_than_days\");\r",
							"        const Users_with_most_recent_login_at_least_days_ago    =  pm.variables.get(\"Users_with_most_recent_login_at_least_days_ago\");\r",
							"        const Users_with_most_recent_login_days_ago_days        =  pm.variables.get(\"Users_with_most_recent_login_days_ago_days\");\r",
							"        const Users_with_most_recent_login_within_last_days_ago   =   pm.variables.get(\"Users_with_most_recent_login_within_last_days_ago\");\r",
							"        const Users_with_most_recent_login_days_within_last_days  =   pm.variables.get(\"Users_with_most_recent_login_days_within_last_days\");\r",
							"        const Users_with_few_logins_than                        =  pm.variables.get(\"Users_with_few_logins_than\");\r",
							"        const Users_fewer_logins_than                           =  pm.variables.get(\"Users_fewer_logins_than\");\r",
							"\r",
							"        const Users_with_greater_logins_than                    =  pm.variables.get(\"Users_with_greater_logins_than\");  \r",
							"        const Users_greater_logins_than                         =  pm.variables.get(\"Users_greater_logins_than\");\r",
							"\r",
							"        const Users_with_private_folder_content                 =  pm.variables.get(\"Users_with_private_folder_content\");\r",
							"        const Users_without_private_folder_content              =  pm.variables.get(\"Users_without_private_folder_content\");\r",
							"        const Users_with_public_content                         =  pm.variables.get(\"Users_with_public_content\");\r",
							"        const Users_did_not_create_public_content               =  pm.variables.get(\"Users_did_not_create_public_content\");\r",
							"\r",
							"\r",
							"        const username_login_array                          = pm.variables.get(\"username_login_array\");             // from the request READ Login Activity\r",
							"        const users_with_private_content_array              = pm.variables.get(\"users_with_private_content_array\"); // from the request READ repository content\r",
							"        const users_with_public_content_array               = pm.variables.get(\"users_with_public_content_array\");  // from the request READ repository content\r",
							"\r",
							"        readbody.Resources.forEach( myfunction_process_user );  // each Resource is a user and each user contains a list of roles and teams they are a member of\r",
							"        function myfunction_process_user(uservalue)\r",
							"        {\r",
							"            let user_identified = false;\r",
							"            const user_test_results_boolean_array=[];\r",
							"            let managers_matched_at_least_one_test = false;\r",
							" \r",
							"            // we assume the user is to be excluded from the action unless it is identified by the various tests, thus it imples an 'OR' operation if multiple tests are enabled\r",
							"            // the first section of code checks the user against the various test(s) that are enabled. The user is either identified (against 1 or more tests) or not.\r",
							"            // the second section of code then looks to what needs to happen for that user, based upon the test result\r",
							"            //      the user will be added, removed or left in the team according to the 'action'\r",
							"            //      if we are processing 'managers' (Users_That_Are_Managers test) then we will be storing all the managers in an array for post-processing,\r",
							"            //      since we won't know all the managers until we've read all the users.\r",
							"            //      and if we are processing the action 'excludeall' with the 'Users_That_Are_Managers' test, then we will be storing all the users in an 'allusers' array,\r",
							"            //      again because we won't know which user is a manager of another until we've read all the users\r",
							"            // the third section, once all the users have been read, is to process the Managers (assuming there is a Users_That_Are_Managers test)\r",
							"            //      the logic used in the these tests is quite complex and the comments explain the logic well. \r",
							"            //      You'll find many console.log statements that are commented-out, if you comment them back in they are helpful for debugging purposes, if not a little verbous!\r",
							"\r",
							"            // \r",
							"            // Commonly used functions\r",
							"\r",
							"            // myfunction_Identify_Relevant_Teams is used by a few 'tests' to determine the number of teams that are relevent, as some teams may\r",
							"            // be on the exclusion list. There are two exclude lists, either the named exclusion list Teams_To_Exclude_Array or Teamnames_StartsWith_to_Exclude_Array\r",
							"            function myfunction_Identify_Relevant_Teams( total, teamvalue )\r",
							"            {\r",
							"                if (Teams_To_Exclude_Array.find(element => element.value === teamvalue.value))\r",
							"                {\r",
							"                    // we need to ignore this team, because its listed in the array of teams to be excluded\r",
							"                    return total -1;\r",
							"                }\r",
							"                else if (Teamnames_StartsWith_to_Exclude_Array.find(element => element.value === teamvalue.value.substr(0,element.value.length))) \r",
							"                {\r",
							"                    // the team starts with the text of a list of teamnames to exclude file_JSON_teamnames_starts_with_to_exclude\r",
							"                    return total -1;\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // we found a team the user is in\r",
							"                    return total;\r",
							"                }; // end if\r",
							"            };\r",
							"\r",
							"\r",
							"            // myfunction_Identify_Relevant_Roles is used by a few 'tests' to determine the number of roles that are relevent, as some roles may\r",
							"            // be on the exclusion list. There is just one exclude list Roles_To_Exclude_Array\r",
							"            function myfunction_Identify_Relevant_Roles( total, rolevalue)\r",
							"            {\r",
							"                if (Roles_To_Exclude_Array.find(element => element === rolevalue))\r",
							"                {\r",
							"                    // we need to ignore this role, because its listed in the array of roles to be excluded list\r",
							"                    return total -1;\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // the user is in a role \r",
							"                    return total;\r",
							"                }; // end if\r",
							"            }; //end function\r",
							"\r",
							"\r",
							"            //\r",
							"            //  If you wanted to add your own test into the script, it should be easy. Just don't forget to update the 'test' around line 435 of this request 'tests'.\r",
							"\r",
							"            const user_found_in_array_of_users_to_exclude = Users_To_Exclude_Array.find(element => element.value === uservalue.id);\r",
							"            if (!user_found_in_array_of_users_to_exclude) \r",
							"            {\r",
							"                const uservalue_managerId=uservalue[\"urn:scim:schemas:extension:enterprise:1.0\"].manager.managerId;\r",
							"                const this_user_has_a_manager = (uservalue_managerId!='');\r",
							"                //console.info(pm.info.requestName+' '+pm.info.eventName+': Processing User: '+uservalue.id+' '+uservalue.meta.location+' '+uservalue.displayName+' has manager:'+uservalue_managerId);\r",
							"\r",
							"                // the tests\r",
							"\r",
							"\r",
							"                if (Users_Match_All_Users)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(true);\r",
							"                }; // end Users_Match_All_Users\r",
							"\r",
							"                if (Users_Created_Recently)\r",
							"                {\r",
							"                    // the user is match if the difference between the current datetime and the users created datetime is less than the number of days specified\r",
							"                    // days is 1000 * 60 * 60 * 24 milliseconds.\r",
							"                    user_test_results_boolean_array.push((Math.floor( (current_datetime - Date.parse(uservalue.meta.created) ) / (1000 * 60 * 60 * 24) )) <= Users_Created_Recently_In_Days);\r",
							"                };\r",
							"\r",
							"\r",
							"                if (Users_With_BI_Concurrent_License)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push( (uservalue[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"].isConcurrent));\r",
							"                }; // end Users_With_BI_Concurrent_License\r",
							"                \r",
							"\r",
							"\r",
							"                if (Users_With_BI_Named_User_License)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(!uservalue[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"].isConcurrent);\r",
							"                }; // end Users_With_BI_Named_User_License\r",
							"\r",
							"\r",
							"                if (Users_With_A_Manager)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(this_user_has_a_manager);\r",
							"                }; // end Users_With_A_Manager\r",
							"\r",
							"\r",
							"                if (Users_With_Named_ManagerIDs)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push( ( (this_user_has_a_manager) && (Users_Named_ManagerIDs.find(namedmanager => namedmanager.value === uservalue_managerId)) ));\r",
							"                }; // end Users_With_Named_ManagerIDs\r",
							"\r",
							"\r",
							"                if (Users_Without_Manager)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(!this_user_has_a_manager);\r",
							"                }; // end Users_Without_Manager\r",
							"\r",
							"\r",
							"                if (Users_That_Are_Managers)\r",
							"                {\r",
							"                    if (this_user_has_a_manager)\r",
							"                    {\r",
							"                        // the user needs to be included in the action upon the target team\r",
							"                        // special manager test here! Notice the different variable we are setting     **********************************\r",
							"                        managers_matched_at_least_one_test = true;\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        // the user does not have a Manager\r",
							"                    }\r",
							"                }; // end Users_That_Are_Managers\r",
							"\r",
							"                if (Users_Active)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(uservalue.active);\r",
							"                }; // end Users_Active\r",
							"\r",
							"                if (Users_Not_Active)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(!uservalue.active);\r",
							"                }; // end Users_Not_Active\r",
							"\r",
							"                if (Users_With_UserID_Ending_Underscore_1)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push( ( (uservalue.id.slice(-2) === '_1') || (uservalue.id.slice(-2) === '_2') ) );\r",
							"                };\r",
							"\r",
							"                if (Users_With_Email_Domain_Matching)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push( (uservalue.emails[0].value.substr(uservalue.emails[0].value.search(\"@\")+1) === Users_Email_Domain) );\r",
							"                }; // end Users_With_Email_Domain_Matching\r",
							"\r",
							"                if (Users_With_Email_Domain_Not_Matching)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push( (uservalue.emails[0].value.substr(uservalue.emails[0].value.search(\"@\")+1) != Users_Email_Domain) );\r",
							"                }; // end Users_With_Email_Domain_Matching\r",
							"\r",
							"\r",
							"                if (Users_With_A_Role_Or_A_Team)\r",
							"                {\r",
							"\r",
							"                    const relevent_teams_for_this_user=uservalue.groups.reduce( myfunction_Identify_Relevant_Teams, uservalue.groups.length);\r",
							"\r",
							"                    const SACroles=uservalue.roles;\r",
							"                    let relevent_roles_for_this_user=SACroles.length;\r",
							"                    if ( (SACroles.length===1) && (SACroles[0]==\"\"))\r",
							"                        { \r",
							"                            // there are no roles when the length is 1 and the value is empty!\r",
							"                            relevent_roles_for_this_user = 0;\r",
							"                        }\r",
							"                    else\r",
							"                    {\r",
							"                        relevent_roles_for_this_user=SACroles.reduce( myfunction_Identify_Relevant_Roles, SACroles.length );\r",
							"                    };  // end if the user has some roles\r",
							"\r",
							"                    user_test_results_boolean_array.push( ( (relevent_teams_for_this_user!=0) || (relevent_roles_for_this_user!=0) ) );\r",
							"                }; // end Users_With_A_Role_Or_A_Team\r",
							"\r",
							"\r",
							"                if (Users_With_No_Teams)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push( (uservalue.groups.reduce( myfunction_Identify_Relevant_Teams, uservalue.groups.length)===0) );\r",
							"                };  //end Users_With_No_Teams\r",
							"\r",
							"\r",
							"                if (Users_With_No_Roles)\r",
							"                {\r",
							"                    const SACroles=uservalue.roles;\r",
							"                    if ( (SACroles.length===1) && (SACroles[0]==\"\"))\r",
							"                        { \r",
							"                            // there are no roles when the length is 1 and the value is empty!\r",
							"                            user_test_results_boolean_array.push(true);\r",
							"                        }\r",
							"                    else\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push((SACroles.reduce( myfunction_Identify_Relevant_Roles, SACroles.length )===0));\r",
							"                    };  \r",
							"                } //end Users_With_No_Roles\r",
							"\r",
							"\r",
							"                if (Users_With_All_Named_Roles)\r",
							"                {\r",
							"                    // we need to find each and every of the named roles, and for each of these the user must have them in their assigned roles\r",
							"                    user_test_results_boolean_array.push(Users_Named_Roles_Array.every( (role) => {return (uservalue.roles.find(element => element === role))} )); \r",
							"                }; // end Users_With_All_Named_Roles\r",
							"\r",
							"\r",
							"                if (Users_LangDateTimeNumberFormats_Different_From)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push( (   (uservalue.preferredLanguage                                        !=Users_preferredlanguage)\r",
							"                        || (uservalue[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"].dataAccessLanguage !=Users_dataaccesslanguage)\r",
							"                        || (uservalue[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"].dateFormatting     !=Users_dateformatting)\r",
							"                        || (uservalue[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"].timeFormatting     !=Users_timeformatting)\r",
							"                        || (uservalue[\"urn:ietf:params:scim:schemas:extension:sap:user-custom-parameters:1.0\"].numberFormatting   !=Users_numberformatting) ) );\r",
							"                }; // end Users_LangDateTimeNumberFormats_Different_From\r",
							"\r",
							"\r",
							"                if (Users_created_more_than)\r",
							"                {\r",
							"                    // the user is match if the difference between the current datetime and the users created datetime is less than the number of days specified\r",
							"                    // days is 1000 * 60 * 60 * 24 milliseconds.\r",
							"                    user_test_results_boolean_array.push((Math.floor( (current_datetime - Date.parse(uservalue.meta.created) ) / (1000 * 60 * 60 * 24) )) > Users_created_more_than_days);\r",
							"                }\r",
							"\r",
							"                if (Users_with_most_recent_login_at_least_days_ago)\r",
							"                {\r",
							"                    let user_login= username_login_array.find( user => user.username===uservalue.id);\r",
							"                    if (user_login)\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push((user_login.days_since_last_login >= Users_with_most_recent_login_days_ago_days));\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push(true); // if the user has not been found, then the last login must had been greater than Users_with_most_recent_login_days_ago_days\r",
							"                    }\r",
							"                }\r",
							"\r",
							"\r",
							"                if (Users_with_most_recent_login_within_last_days_ago)\r",
							"                {\r",
							"                    let user_login= username_login_array.find( user => user.username===uservalue.id);\r",
							"                    if (user_login)\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push((user_login.days_since_last_login < Users_with_most_recent_login_days_within_last_days));\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push(false); // if the user has not been found, then the last login must had been greater than Users_with_most_recent_login_days_within_last_days\r",
							"                    }\r",
							"                }\r",
							"\r",
							"\r",
							"\r",
							"                if (Users_with_few_logins_than)\r",
							"                {\r",
							"                    let user_login = username_login_array.find( user => user.username===uservalue.id)\r",
							"                    if (user_login)\r",
							"                    {\r",
							"                        //console.log(\"370: user_login \",user_login)\r",
							"                        user_test_results_boolean_array.push((user_login.total_logins <= Users_fewer_logins_than))\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push(true); // we will postively identify users that have not yet logged-on, they have no login event and thus have few login events than X\r",
							"                    }\r",
							"                }\r",
							"\r",
							"\r",
							"\r",
							"                if (Users_with_greater_logins_than)\r",
							"                {\r",
							"                    let user_login = username_login_array.find( user => user.username===uservalue.id)\r",
							"                    if (user_login)\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push((user_login.total_logins > Users_greater_logins_than));\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        user_test_results_boolean_array.push(false);\r",
							"                    }\r",
							"                }\r",
							"\r",
							"                if (Users_with_private_folder_content)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push((users_with_private_content_array.find( user => user===uservalue.id)))\r",
							"                }\r",
							"\r",
							"                if (Users_without_private_folder_content)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(!(users_with_private_content_array.find( user => user===uservalue.id)))\r",
							"                }\r",
							"\r",
							"                if (Users_with_public_content)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push((users_with_public_content_array.find( user => user===uservalue.id)))\r",
							"                }\r",
							"\r",
							"                if (Users_did_not_create_public_content)\r",
							"                {\r",
							"                    user_test_results_boolean_array.push(!(users_with_public_content_array.find( user => user===uservalue.id)))\r",
							"                }\r",
							"\r",
							"                // we shall now determine if the user should be identified based upon the array of tests they have passed or failed\r",
							"                // either the user needs to pass all the tests, or just some of them.\r",
							"                // the user will need to pass all the tests if the condition is an AND\r",
							"                // the user will need to pass some of the tests if the condition is an OR\r",
							"                if (Multiple_Operator_is_AND)\r",
							"                {\r",
							"                    // the operator is an AND and so all the conditions we are testing for must be true\r",
							"                    user_identified=user_test_results_boolean_array.every( (test) => {return test});\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // the operator is an OR and so any 1 of the conditions we are testing for must be true, even if some others are false\r",
							"                    user_identified=user_test_results_boolean_array.some( (test) => {return test});\r",
							"                };\r",
							"\r",
							"\r",
							"                // users - we now need to process what happens if we found a user that matches a test\r",
							"\r",
							"                if (Users_Match_All_Users ||\r",
							"                    Users_Created_Recently ||\r",
							"                    Users_With_BI_Concurrent_License ||\r",
							"                    Users_With_BI_Named_User_License ||\r",
							"                    Users_With_A_Manager ||\r",
							"                    Users_With_Named_ManagerIDs ||\r",
							"                    Users_Without_Manager ||\r",
							"                    Users_Active  ||\r",
							"                    Users_Not_Active ||\r",
							"                    Users_With_UserID_Ending_Underscore_1 ||\r",
							"                    Users_With_Email_Domain_Matching ||\r",
							"                    Users_With_Email_Domain_Not_Matching ||\r",
							"                    Users_With_A_Role_Or_A_Team ||\r",
							"                    Users_With_No_Teams  ||\r",
							"                    Users_With_No_Roles  ||\r",
							"                    Users_With_All_Named_Roles ||\r",
							"                    Users_LangDateTimeNumberFormats_Different_From ||\r",
							"                    Users_created_more_than  ||\r",
							"                    Users_with_most_recent_login_at_least_days_ago  ||\r",
							"                    Users_with_most_recent_login_within_last_days_ago ||\r",
							"                    Users_with_few_logins_than || \r",
							"                    Users_with_greater_logins_than ||\r",
							"                    Users_with_private_folder_content ||\r",
							"                    Users_without_private_folder_content  || \r",
							"                    Users_with_public_content  || \r",
							"                    Users_did_not_create_public_content     )\r",
							"\r",
							"                {\r",
							"                    // the test is a non-manager test and there's at least one of these types of tests\r",
							"\r",
							"                    if (user_identified)\r",
							"                    {\r",
							"                        users_found_this_page ++;\r",
							"                        //console.info(pm.info.requestName+' '+pm.info.eventName+': User identifed: '+uservalue.id+' '+uservalue.meta.location+' '+uservalue.displayName+' has manager:'+uservalue_managerId);\r",
							"                        switch (Users_Action) \r",
							"                        {\r",
							"                        case \"add\":         // add and replace share the same code\r",
							"                        case \"replace\":\r",
							"                        \r",
							"                            if ( this_team.members.find(element => element.value === uservalue.id) ) //  user found in existing team\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already member of team (US1/US3)');\r",
							"                                if (filterenabled)\r",
							"                                {\r",
							"                                    // because we have enabled filtering the logic is slightly different.\r",
							"                                    // with filtering enabled, then all existing team members will be added into the remove list\r",
							"                                    // this is becasue the filter will only return users that match the filter unlike without the filter\r",
							"                                    // where all users are read and for the users that don't match they are removed as they are processed\r",
							"                                    // but with filtering enabled we need to remove the users that do match from the remove list so they remain in the team\r",
							"                                    // leaving all other users to be left in the remove list and thus removed from the team\r",
							"                                    // this also means that the filtering logic will ONLY work for a single test and you can't combine tests (at least not for\r",
							"                                    // the replace or intersect actions)\r",
							"                                    if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )\r",
							"                                    {\r",
							"                                        const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === uservalue.id);\r",
							"                                        users_waiting_to_be_removed_in_this_batch.splice(userindex,1);\r",
							"                                    };\r",
							"                                };\r",
							"                            }\r",
							"                            else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === uservalue.id) ) // user_found_in_add_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already on add list. No action needed');\r",
							"                            }\r",
							"                            else if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in remove list. Removing user from remove list');\r",
							"                                const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === uservalue.id);\r",
							"                                users_waiting_to_be_removed_in_this_batch.splice(userindex,1);\r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' needs to be added to team (US2)');\r",
							"                                const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                                newentry.value  = uservalue.id;\r",
							"                                newentry.$ref   = uservalue.meta.location;\r",
							"                                users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"                                //  users_to_add_this_page++;   // this is commented out because the variable is used to commented-out console logs\r",
							"                            }\r",
							"                            ; // end if \r",
							"                            break; // end of case 'replace'\r",
							"                        \r",
							"                        case \"invert\":  // same as remove\r",
							"                        case \"remove\":\r",
							"                            // before we remove the user we need to check if the user is already on the list. We don't need or want to remove the same user twice\r",
							"                            \r",
							"                            if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already added to remove list. No action needed');\r",
							"                            }\r",
							"                            else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === uservalue.id) ) // user_found_in_add_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already will be removed from add list (UR2)');\r",
							"                                const userindex = users_waiting_to_be_added_in_this_batch.findIndex(element => element.value === uservalue.id);\r",
							"                                users_waiting_to_be_added_in_this_batch.splice(userindex,1);\r",
							"                            }\r",
							"                            else if ( this_team.members.find(element => element.value === uservalue.id) )  // user_found_in_existing_team_membership\r",
							"                            {\r",
							"                            \r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' added to the remove list (UR3)');\r",
							"                                const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                                newentry.value  = uservalue.id;\r",
							"                                newentry.$ref   = uservalue.meta.location;\r",
							"                                users_waiting_to_be_removed_in_this_batch.push(newentry);\r",
							"                                // users_to_remove_this_page++;  // this is commented out because the variable is used to commented-out console logs\r",
							"                            }\r",
							"                            else // user not found\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' not found. Cannot remove user! (UR4)');\r",
							"                            }\r",
							"                            break; // end of case 'remove' and 'invert'\r",
							"                        \r",
							"                        case \"intersect\":\r",
							"                        \r",
							"                            if ( this_team.members.find(element => element.value === uservalue.id) ) // \r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' exists in target team');\r",
							"\r",
							"                                //\r",
							"                                if (filterenabled)\r",
							"                                {\r",
							"                                    // because we have enabled filtering the logic is slightly different.\r",
							"                                    // with filtering enabled, then all existing team members will be added into the remove list\r",
							"                                    // this is becasue the filter will only return users that match the filter unlike without the filter\r",
							"                                    // where all users are read and for the users that don't match they are removed as they are processed\r",
							"                                    // but with filtering enabled we need to remove the users that do match from the remove list so they remain in the team\r",
							"                                    // leaving all other users to be left in the remove list and thus removed from the team\r",
							"                                    // this also means that the filtering logic will ONLY work for a single test and you can't combine tests (at least not for\r",
							"                                    // the replace or intersect action\r",
							"                                    if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )\r",
							"                                    {\r",
							"                                        const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === uservalue.id);\r",
							"                                        users_waiting_to_be_removed_in_this_batch.splice(userindex,1);\r",
							"                                    };\r",
							"                                };\r",
							"                            }\r",
							"                            else if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in remove list. No action needed');\r",
							"                            }\r",
							"                            else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_add_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in add list. Removing user from add list');\r",
							"                                const userindex = users_waiting_to_be_added_in_this_batch.findIndex(element => element.value === uservalue.id);\r",
							"                                users_waiting_to_be_added_in_this_batch.splice(userindex,1)\r",
							"                            } \r",
							"                            else \r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' does not exists in target team, so nothing to do');\r",
							"                            }\r",
							"                            ; // end if  \r",
							"                            break; // end of case 'intersect'\r",
							"                        \r",
							"                        case \"exclude\":     // allow to continue to excludeall with no break as its the same code\r",
							"                        case \"excludeall\":\r",
							"                        \r",
							"                            if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_add_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in add list.');\r",
							"                            }\r",
							"                            else if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in remove list.');\r",
							"                            }\r",
							"                            else if ( this_team.members.find(element => element.value === uservalue.id) ) // \r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' found in target team, so now removing user');\r",
							"                                const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                                newentry.value  = uservalue.id;\r",
							"                                newentry.$ref   = uservalue.meta.location;\r",
							"                                users_waiting_to_be_removed_in_this_batch.push(newentry);\r",
							"                                // users_to_remove_this_page++; // this is commented out because the variable is used to commented-out console logs\r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' not in target team, so now adding user to team');\r",
							"                                const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                                newentry.value  = uservalue.id;\r",
							"                                newentry.$ref   = uservalue.meta.location;\r",
							"                                users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"                                //users_to_add_this_page++; // this is commented out because the variable is used to commented-out console logs\r",
							"                            }\r",
							"                            ; // end if \r",
							"                            break; // end of case 'exclude' or 'excludeall'\r",
							"\r",
							"                        default:\r",
							"                            console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled case statement for Users_Action ', Users_Action);\r",
							"                        }; // end switch Users_Action\r",
							"                        \r",
							"\r",
							"                    }\r",
							"                    else // user is ** NOT ** matched by at least 1 test.\r",
							"                    {\r",
							"                        //console.info(pm.info.requestName+' '+pm.info.eventName+': User NOT identifed: '+uservalue.id+' '+uservalue.meta.location+' '+uservalue.displayName+' has manager: '+uservalue_managerId);\r",
							"\r",
							"                        switch (Users_Action) \r",
							"                        {\r",
							"                        case \"add\":     // add and remove share the same code\r",
							"                        case \"remove\": \r",
							"                            // nothing to do\r",
							"                            break; \r",
							"                        \r",
							"                        case \"replace\":     // replace and intersect share the same code\r",
							"                        case \"intersect\": \r",
							"                            // we may be processing a user that needs to be removed from the target team\r",
							"                            if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in remove list.');\r",
							"                            }\r",
							"                            if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_add_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in add list. Removing user from add list');\r",
							"                                const userindex = users_waiting_to_be_added_in_this_batch.findIndex(element => element.value === uservalue.id);\r",
							"                                users_waiting_to_be_added_in_this_batch.splice(userindex,1)\r",
							"                            }\r",
							"                            else if ( this_team.members.find(element => element.value === uservalue.id) ) // \r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' found in target team, but we need to remove it');\r",
							"                                const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                                newentry.value  = uservalue.id;\r",
							"                                newentry.$ref   = uservalue.meta.location;\r",
							"                                users_waiting_to_be_removed_in_this_batch.push(newentry);\r",
							"                                // users_to_remove_this_page++; // this is commented out because the variable is used to commented-out console logs\r",
							"                            }\r",
							"                            else // user not found\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' not found in target team, no action needed');\r",
							"                            }\r",
							"                            ; // end if\r",
							"                            break; // end of case for interect or replace\r",
							"\r",
							"                        case \"exclude\":\r",
							"                            // nothing to do\r",
							"                            break; // end of case for exclude\r",
							"\r",
							"                        case \"invert\":      // invert and excludeall share the same code\r",
							"                        case \"excludeall\":\r",
							"                        \r",
							"                            // we may be processing a user that needs to be removed from the target team\r",
							"                            if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' in remove list, so removing from remove list.');\r",
							"                                const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === uservalue.id);\r",
							"                                users_waiting_to_be_removed_in_this_batch.splice(userindex,1)\r",
							"                            }\r",
							"                            if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === uservalue.id) )  // user_found_in_add_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already in add list. Nothing to do');\r",
							"                                \r",
							"                            }\r",
							"                            else if ( this_team.members.find(element => element.value === uservalue.id) ) // \r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' found in target team, no action needed');\r",
							"                                \r",
							"                            }\r",
							"                            else // user not found\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' not in target team, so now adding user to team (excludeall and invert)');\r",
							"                                const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                                newentry.value  = uservalue.id;\r",
							"                                newentry.$ref   = uservalue.meta.location;\r",
							"                                users_waiting_to_be_added_in_this_batch.push(newentry);\r",
							"                                //users_to_add_this_page++; // this is commented out because the variable is used to commented-out console logs\r",
							"                            }\r",
							"                            ; // end if \r",
							"                            break; // end of case for excludeall\r",
							"\r",
							"                        default:\r",
							"                            console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled case statement for Users_Action ', Users_Action);\r",
							"                        }; // end of case on user_action\r",
							"                    }; // end if user_identified (or not!)\r",
							"                }; // end if test is a non-manager test\r",
							"\r",
							"                // managers - we now need to process what happens if we found a manager that matches a test\r",
							"                if (Users_That_Are_Managers)\r",
							"                {\r",
							"                    // we need to store all users in a separate array all_users because some of the users may or may not be managers, but we won't know until we've \r",
							"                    // read all the users and identified which are managers or not. Then and only then can we process 'all_users' for the invert and exclude_all opertions\r",
							"                    // when and only when the test Users_That_Are_Managers is true.\r",
							"                    \r",
							"\r",
							"                    switch (Users_Action) \r",
							"                    {\r",
							"                    case \"invert\":\r",
							"                    case \"excludeall\":  // invert and excludeall require the need to scan all the users\r",
							"                    \r",
							"                        if ( all_users.find(element => element.id === uservalue.id) ) //  user found in existing array\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' already member of all_users');\r",
							"                        }\r",
							"                        else\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+uservalue.id+' needs to be added to all_users');\r",
							"                            const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                            newentry.value  = uservalue.id;\r",
							"                            newentry.$ref   = uservalue.meta.location;\r",
							"                            all_users.push(newentry);\r",
							"                        }; // end if - adding user to all_users\r",
							"                        break;\r",
							"                    default:\r",
							"                        // we don't need to store every user in the all_users array, we can determine the result by processing just the managers array\r",
							"                    };\r",
							"\r",
							"                    // now we need to process the manager of the user\r",
							"\r",
							"\r",
							"                    if (managers_matched_at_least_one_test)  // i.e the user has a manager and we know the managers userid\r",
							"                    {\r",
							"                        \r",
							"                        //console.info(pm.info.requestName+' '+pm.info.eventName+': Manager identified. User: '+uservalue.id+' '+uservalue.meta.location+' '+uservalue.displayName+' has manager: '+uservalue_managerId);\r",
							"\r",
							"                        if ( managers.find(element => element.value === uservalue_managerId) )  // user_found_in_managers_array\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+' Manager '+uservalue_managerId+' found in managers array');\r",
							"                        }\r",
							"                        else // managers not found in the list of managers so we need to add the user. Once all the users are processed we can then determine what needs to be done for these managers\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+uservalue_managerId+' needs to be added to managers array');\r",
							"                            const newentry    = {\"type\":'User',\"value\":'',\"$ref\":''};\r",
							"                            newentry.value  = uservalue_managerId;\r",
							"                            newentry.$ref   = \"/api/v1/scim/Users/\".concat(uservalue_managerId);\r",
							"                            managers.push(newentry);\r",
							"                            managers_found_this_page ++;\r",
							"                        }; // end if\r",
							"\r",
							"                    }  // end if managers_matched_at_least_one_test\r",
							"                    else //  the user doesn't have a manager, but the user still might be a manager referenced by another user, but we don't know that yet\r",
							"                    {\r",
							"                        //console.info(pm.info.requestName+' '+pm.info.eventName+': Manager not identified for user: '+uservalue.id+' '+uservalue.meta.location+' '+uservalue.displayName+' has manager: '+uservalue_managerId);            \r",
							"                    }; // end if  manager_matched_at_least_one_test\r",
							"\r",
							"\r",
							"                }; // end if Users_That_Are_Managers\r",
							"\r",
							"            } // end if the resource is a User\r",
							"        }; // end myfunction_process_user\r",
							"\r",
							"        // we need to save the updated arrays into the array_of_teams \r",
							"        this_team.arrayofusers_waiting_to_be_added_in_this_batch  =users_waiting_to_be_added_in_this_batch;\r",
							"        this_team.arrayofusers_waiting_to_be_removed_in_this_batch=users_waiting_to_be_removed_in_this_batch;\r",
							"        array_of_teams[this_team_index]=this_team;\r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"        \r",
							"        \r",
							"        //console.log(pm.info.requestName+' '+pm.info.eventName+': this_team',this_team);\r",
							"        \r",
							"        \r",
							"        // a more verbous log can be handy:\r",
							"        // console.log(pm.info.requestName+' '+pm.info.eventName+': Identifed '+users_found_this_page+' users (that match at least one test) and '+managers_found_this_page+' managers (without regard to matching any test) on this page. Action \\''+Users_Action+'\\' means '+users_to_add_this_page+' users are to be added and '+users_to_remove_this_page+' to be removed, resuling in '+this_team.arrayofusers_waiting_to_be_added_in_this_batch.length+' to be added and '+this_team.arrayofusers_waiting_to_be_removed_in_this_batch.length+' to be removed from the team '+this_team.teamname);\r",
							"        if (Users_That_Are_Managers)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Identifed '+users_found_this_page+' users and '+managers_found_this_page+' managers (for post-processing) on this page');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Identifed '+users_found_this_page+' users on this page');\r",
							"        }; // end if Users_That_Are_Managers\r",
							"\r",
							"        if (max_user_index_this_page>=total_users_in_this_SAC_service)\r",
							"        {\r",
							"            // we have read all the users so we can now go to update the team, there's no need to change the index size\r",
							"        }\r",
							"        else if ( (users_this_page === ReadUsersIndexSize) && (!max_index_size))\r",
							"        {\r",
							"            // there could be a need to change the index size but we only do this if the number of users returned last was the maximum number we asked for\r",
							"            // and when the max_index_size has not yet been set. max_index_size is set when we find out that SAC is limited the number of users per page\r",
							"            let newindexsize = ReadUsersIndexSize;\r",
							"            if (pm.response.responseTime>270000)\r",
							"            {\r",
							"                newindexsize= Math.round(newindexsize * 0.6);\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was over 4 mins 30 sec. Reducing index size to keep under 5 mins. Index size now '+newindexsize);\r",
							"            }\r",
							"            else if (pm.response.responseTime>210000)\r",
							"            {\r",
							"                newindexsize= Math.round(newindexsize * 0.8);\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was over 3 mins 30 sec. Reducing index size to keep under 5 mins. Index size now '+newindexsize);\r",
							"            }\r",
							"            else if (pm.response.responseTime<60000)\r",
							"            {\r",
							"                newindexsize= Math.round(newindexsize * 2);\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was under 1 min. Increasing index size to improve throughput. Index size now '+newindexsize);\r",
							"            }\r",
							"            else if (pm.response.responseTime<120000)\r",
							"            {\r",
							"                newindexsize= Math.round(newindexsize * 1.75);\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was under 2 mins. Increasing index size to improve throughput. Index size now '+newindexsize);            \r",
							"            };\r",
							"            if (newindexsize<1) {newindexsize=1};\r",
							"            pm.variables.set(\"ReadUsersIndexSize\", newindexsize);   // set the new index size\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            // nothing to do.\r",
							"        };\r",
							"\r",
							"        // Define the next set of users to query, it will start with the user after the last one\r",
							"        const Next_Read_Start_At = max_user_index_this_page + 1\r",
							"        pm.variables.set(\"StartUserIndex\",Next_Read_Start_At);\r",
							"\r",
							"        // and the size of the last page may not be the full Index Size, it may well be shorter\r",
							"        ReadUsersIndexSize=pm.variables.get(\"ReadUsersIndexSize\");\r",
							"        if ((Next_Read_Start_At+ReadUsersIndexSize-1) > total_users_in_this_SAC_service)\r",
							"        {\r",
							"            pm.variables.set(\"ReadUsersIndexSize\",(total_users_in_this_SAC_service-Next_Read_Start_At+1))\r",
							"        };\r",
							"\r",
							"        \r",
							"\r",
							"        \r",
							"        const update_target_team = ( Next_Read_Start_At>total_users_in_this_SAC_service);\r",
							"        \r",
							"        \r",
							"        if (update_target_team)  // update required of the user. A team update may still be needed.\r",
							"        {\r",
							"            const displayname     = pm.iterationData.get(\"file_team_displayname\");\r",
							"            const displayname_contains_TIMESTAMP = displayname.search(\"TIMESTAMP\");  // displayname_contain_TIMESTAMP will be true if the displayname contains the text TIMESTAMP\r",
							"                                                                                    // if so, then the team will still need updating, even if the team membership remains the same\r",
							"\r",
							"\r",
							"            // we need to process any managers that we found now we've read all the users.\r",
							"            if (Users_That_Are_Managers)  // this means we need to process the managers\r",
							"            {\r",
							"                //\r",
							"                //               this section can be useful to show when the post-processing starts and how many users need processing:\r",
							"                //               (you'll need to also comment-in the variables that are used here. The variables are declared earlier in the script and are updated throughout the script too)\r",
							"                //const total_managers=managers.length;\r",
							"                //if ((Users_Action === \"invert\") || (Users_Action ===\"excludeall\"))\r",
							"                //{\r",
							"                //    console.info(pm.info.requestName+' '+pm.info.eventName+': Processing '+all_users.length+' users of which '+total_managers+' are managers');\r",
							"                //}\r",
							"                //else\r",
							"                //{\r",
							"                //    console.info(pm.info.requestName+' '+pm.info.eventName+': Processing '+total_managers+' managers');\r",
							"                //};\r",
							"                \r",
							"\r",
							"                let managers_or_users_to_add = 0;     // just to keep a tally of how many managers are to be added or removed.\r",
							"                let managers_or_users_to_remove = 0;  // they only purpose is for the console log to show these numbers.\r",
							"                \r",
							"                switch (Users_Action) \r",
							"                {\r",
							"                case \"add\":\r",
							"                {\r",
							"                    managers.forEach( myfunction_process_all_managers );\r",
							"                    function myfunction_process_all_managers( manager )\r",
							"                    {\r",
							"                \r",
							"                        if ( this_team.members.find(element => element.value === manager.value) ) //  user found in existing team\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' already member of team (1)');\r",
							"                        }\r",
							"                        else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === manager.value) ) // user_found_in_add_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' already on add list. No action needed (2)');\r",
							"                        }\r",
							"                        else // no need to test if the user is in the remove list because the action is add\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' needs to be added to team (3)');\r",
							"                            users_waiting_to_be_added_in_this_batch.push(manager);\r",
							"                            managers_or_users_to_add++;\r",
							"                        }; // end if \r",
							"                    }; // end myfunction_process_all_managers\r",
							"                    break; // end of case 'add'\r",
							"                }\r",
							"\r",
							"                case \"remove\":\r",
							"                {\r",
							"                    // before we remove the user we need to check if the user is already on the list. We don't need or want to remove the same user twice\r",
							"                    managers.forEach( myfunction_process_all_managers );\r",
							"                    function myfunction_process_all_managers( manager )\r",
							"                    {\r",
							"                    \r",
							"                        if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === manager.value) )  // user_found_in_remove_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' already added to remove list. No action needed (4)');\r",
							"                        }\r",
							"                        // no need to check if the user is in the add list, because the action is remove\r",
							"                        else if ( this_team.members.find(element => element.value === manager.value) )  // user_found_in_existing_team_membership\r",
							"                        {\r",
							"                            \r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' added to the remove list (5)');\r",
							"                            users_waiting_to_be_removed_in_this_batch.push(manager);\r",
							"                            managers_or_users_to_remove++;\r",
							"                        }\r",
							"                        else // user not found\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' not found in team. Cannot remove user! (6)');\r",
							"                        }; // end if\r",
							"                    }; // end myfunction_process_all_managers\r",
							"                    break; // end of case 'remove' \r",
							"                }\r",
							"\r",
							"                case \"replace\":\r",
							"                {\r",
							"                    // next we need to look at all the existing team members and potentially remove existing users as they are not managers\r",
							"                    // this action is a little confusing, because another test may have identifed the user should be added or removed already\r",
							"                    // But remember that managers are processed after the user tests, and because we perform a OR operation between other tests and this manager test\r",
							"                    // we need to cater for such events and only add or remove the user if the user does or doesn't already exist in the add and remove lists!\r",
							"\r",
							"\r",
							"                    const at_least_one_nonUsersThatAreManager_test = pm.variables.get(\"at_least_one_nonUsersThatAreManager_test\");\r",
							"\r",
							"                    this_team.members.forEach( myfunction_process_existing_team_users );\r",
							"                    function myfunction_process_existing_team_users(user)\r",
							"                    {   \r",
							"                        if ( managers.find(element => element.value === user.value) ) // user_found_in_existing_team_membership\r",
							"                        {\r",
							"                            // user is a manager, so this user will be added by the myfunction_process_all_managers. We don't need to do anything\r",
							"                        }\r",
							"                        else // user is not a manager\r",
							"                        {\r",
							"                            // user is not a manager (but is currently in the current team member)\r",
							"                            if (at_least_one_nonUsersThatAreManager_test)\r",
							"                            {\r",
							"                                // the user will have been tested against another test. If they are tested against another test we must OR that test with this test\r",
							"                                // And since they have been tested against another test it means that if the user is NOT in the remove list, then the user will have passed\r",
							"                                // that other test. This then means (if the user is in the remove list) they would have failed that other test.\r",
							"                                // So, if the user is in the remove list, then we should keep the user in that remove list, because they are not a manager either\r",
							"                                // otherwise the user must have passed the other test and we should leave the user in the team\r",
							"                                \r",
							"                                // user is NOT an existing team member, is NOT a manager BUT has already been 'replaced' by another test, because the user is in the remove list\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' found in remove list and so must had been replaced by another test, leaving user in remove list (7)');\r",
							"                                // nothing to do.\r",
							"                                \r",
							"                                // user not in the remove list and so we must add the user to the remove list, so this isManager test is OR'ed with the other test\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' not found in remove list and so must had been replaced by another test, leaving user in team (8)');\r",
							"                                // end if users_waiting_to_be_removed_in_this_batch\r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                // the user is NOT a manager, still in the current team but there was no other test for the user other than this 'UsersThatAreManagers'\r",
							"                                // it means its simple, we should remove the user from the current team, if not already in the remove list.\r",
							"                                if (  users_waiting_to_be_removed_in_this_batch.find(element => element.value === user.value) )  // user_found_in_remove_list\r",
							"                                {\r",
							"                                    // user is NOT an existing team member, is NOT a manager BUT has already been 'replaced' by another test, because the user is in the remove list\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' found in remove list, there are no other tests (9a)');\r",
							"                                    // nothing to do.\r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    // user not in the remove list and so we must add the user to the remove list, so this isManager test is OR'ed with the other test\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' not found in remove list and so adding user to remove list. There are no other tests (9)');\r",
							"                                    users_waiting_to_be_removed_in_this_batch.push(user);\r",
							"                                    managers_or_users_to_remove++;\r",
							"                                }; // end if users_waiting_to_be_removed_in_this_batch\r",
							"                            }; // end if at_least_one_nonUsersThatAreManager_test\r",
							"                        }; // end if user is a manager, or not a manager\r",
							"                    }; // end function myfunction_process_existing_team_users\r",
							"\r",
							"                    // we need to look at all the managers and either add or remove them from the existing team\r",
							"                    managers.forEach( myfunction_process_all_managers );\r",
							"                    function myfunction_process_all_managers( manager )\r",
							"                    {\r",
							"                        if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === manager.value) ) // user_found_in_add_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' already on add list. No action needed (11 a)');\r",
							"                        }\r",
							"                        else\r",
							"                        {\r",
							"                            if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === manager.value) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' found in remove list, removing user from remove list (11 b)'); \r",
							"                                const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === manager.value);                               \r",
							"                                users_waiting_to_be_removed_in_this_batch.splice(userindex,1);\r",
							"                                managers_or_users_to_add ++;\r",
							"                            }\r",
							"                            else if ( this_team.members.find(element => element.value === manager.value) ) //  user found in existing team\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' already member of team (11 c)');\r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' needs to be added to team (12)');\r",
							"                                users_waiting_to_be_added_in_this_batch.push(manager);\r",
							"                                managers_or_users_to_add ++;\r",
							"                            }; // end if\r",
							"                        }\r",
							"                    }; // end my function\r",
							"\r",
							"                    break; // end of case 'replace'\r",
							"                }\r",
							"                \r",
							"                case \"intersect\":\r",
							"                {\r",
							"                    // next we need to look at all the existing team members and potentially remove existing users as they are:\r",
							"                    //    ( managers OR they tested in another user test and so will already be in the add list) \r",
							"\r",
							"                    const at_least_one_nonUsersThatAreManager_test = pm.variables.get(\"at_least_one_nonUsersThatAreManager_test\");\r",
							"\r",
							"                    this_team.members.forEach( myfunction_process_existing_team_users );\r",
							"                    function myfunction_process_existing_team_users(user)\r",
							"                    {   \r",
							"                        if ( managers.find(element => element.value === user.value) ) // user_found_in_existing_team_membership\r",
							"                        {\r",
							"                            // user is a manager and already in the team, so no action needed - this is the intersect function!\r",
							"                            if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === user.value) ) // user_found_in_remove_list \r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already existing team member, but found on remove list, now removed from remove list (14 a)');\r",
							"                                const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === user.value);\r",
							"                                users_waiting_to_be_removed_in_this_batch.splice(userindex,1);\r",
							"                                managers_or_users_to_add ++; \r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already member of existing team (14 b)');\r",
							"                            };\r",
							"                        }\r",
							"                        else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === user.value) ) // user_found_in_add_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already on add list and therefore another test has already intersected this user (15)');\r",
							"                        }\r",
							"                        else if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === user.value) ) // user_found_in_remove_list \r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already in remove list because another test has intersected this user (16)');\r",
							"                        }\r",
							"                        else if (at_least_one_nonUsersThatAreManager_test)\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' not in add or remove list and user tested against a non-isManager test (16 a)');\r",
							"                        }\r",
							"                        else\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' added to remove list as not identifed by another test to intersected with (17)');\r",
							"                            users_waiting_to_be_removed_in_this_batch.push(user);\r",
							"                            managers_or_users_to_remove++;\r",
							"                        }; // end if user is a manager, or not a manager\r",
							"                    }; // end function myfunction_process_existing_team_users\r",
							"\r",
							"                    break; // end of case 'intersect'\r",
							"                }\r",
							"\r",
							"                case \"exclude\":\r",
							"                {   \r",
							"                    // all managers that are matched will be stored in the 'managers' array.\r",
							"                    // for each of these managers we need to identify if we need to add any of them to the team for the 'exclude' action.\r",
							"                    //     the user will need to be added if they are NOT a member of the current team, (or) NOT in the 'add' list already\r",
							"                    // then for all the existing team members, users may need to be removed if they are a manager\r",
							"\r",
							"                    managers.forEach( myfunction_process_all_managers );\r",
							"                    function myfunction_process_all_managers( manager )\r",
							"                    {\r",
							"                        if ( this_team.members.find(element => element.value === manager.value) ) //  manager found in existing team\r",
							"                        {\r",
							"                            // manager already a member of the team\r",
							"                            // the user should be removed, but we won't process that here, we'll do that in the myfunction_process_existing_team_users\r",
							"                            // it might improve the performance (but not removing them here) becaue before we remove them we have to check if the user is already on the remove list!\r",
							"                        }\r",
							"                        else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === manager.value) )  // user_found_in_add_list\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' already in add list (18)');\r",
							"                        }\r",
							"                        else\r",
							"                        {\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+manager.value+' not in target team, so now adding user to team (19)');\r",
							"                            users_waiting_to_be_added_in_this_batch.push(manager);\r",
							"                            managers_or_users_to_add++;\r",
							"                        }; // end if                   \r",
							"                    }; // end myfunction_process_all_managers\r",
							"\r",
							"                    // and for all existing team members, we need to remove the user if they are a manager. Before removing we should check if they are already on the remove list\r",
							"                    this_team.members.forEach( myfunction_process_existing_team_users );\r",
							"                    function myfunction_process_existing_team_users(user)\r",
							"                    {   \r",
							"                        if ( managers.find(element => element.value === user.value) ) // user_found_in_existing_team_membership\r",
							"                        {\r",
							"                            // user is a manager, so we should remove the user, if not already on the remove list.\r",
							"                            if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === user.value) )\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already in remove list. No action (20)');\r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                users_waiting_to_be_removed_in_this_batch.push(user);\r",
							"                                managers_or_users_to_remove++;\r",
							"                            }\r",
							"                        }\r",
							"                        else // user is not a manager\r",
							"                        {\r",
							"                            // user is not a manager (but is a current team member) and we don't need to do anything\r",
							"                            //console.log(pm.info.requestName+' '+pm.info.eventName+': user '+user.value+' is not a manager and so will be left in the team (21)');\r",
							"                        }; // end if user is a manager, or not a manager\r",
							"                    }; // end function myfunction_process_existing_team_users\r",
							"\r",
							"                    break; // end of case 'exclude'\r",
							"                }                    \r",
							"\r",
							"                case \"excludeall\":  // excludeall requires the need to scan all the users\r",
							"                {\r",
							"                    // all users are stored in the 'all_users' array.\r",
							"                    // for each of these users we need to identify if we need to add or remove any of them to the team for the 'excludeall' action.\r",
							"                    //   the user should be removed from the team if:\r",
							"                    //   they are a member of the current team AND are a manager (if the user is already in the remove list, then another test has already excludeded all them)\r",
							"                    //   otherwise they should be added to the add list (as long as they are not already in the remove list)\r",
							"                    //            \r",
							"\r",
							"                    all_users.forEach( myfunction_process_all_users );\r",
							"                    function myfunction_process_all_users( user )\r",
							"                    {\r",
							"                        if ( this_team.members.find(element => element.value === user.value) ) \r",
							"                        {   \r",
							"                            //  user is in the existing team\r",
							"                            if ( managers.find(element => element.value === user.value) )  \r",
							"                            {   \r",
							"                                // the user is in existing team and is also a manager\r",
							"                                if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === user.value) )  // user_found_in_remove_list\r",
							"                                {\r",
							"                                    // user is an existing team member, is a manager BUT has already been 'excludedall' by another test, because the user is in the remove list\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already in remove list and excludedall by another test (22)');\r",
							"                                }\r",
							"                                else // user can be removed\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' added to remove list and excludedall by this test (23)');\r",
							"                                    users_waiting_to_be_removed_in_this_batch.push(user);\r",
							"                                    managers_or_users_to_remove++;\r",
							"                                };\r",
							"                            }\r",
							"                            else  // the user is in the existing team member but is NOT a manager\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' already in target team and is not a manager (24)');\r",
							"                                // nothing to do!\r",
							"                            };  // end if the user is a manager or not\r",
							"                        }\r",
							"                        else \r",
							"                        {\r",
							"                            // user is NOT an exisitng team member. so we must add the user to the team, if they're not already in the remove or add lists\r",
							"                            if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === user.value) )  // user_found_in_remove_list\r",
							"                            {\r",
							"                                // user is NOT an existing team member, is NOT a manager BUT has already been 'excludedall' by another test, because the user is in the remove list\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' already in remove list and excludedall by another test r1 (25)');\r",
							"                            }\r",
							"                            else if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === user.value) ) \r",
							"                            {\r",
							"                                \r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' found in add list and excludedall by another test (26 a)');\r",
							"                                // user not a manager\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' already in add list and excludedall by another test and is not a manager (26 b)');\r",
							"                            }\r",
							"                            else\r",
							"                            {\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' not a manager, not already in team and excludedall by this test (27)');\r",
							"                                users_waiting_to_be_added_in_this_batch.push(user);\r",
							"                                managers_or_users_to_add++;\r",
							"                            } // end if\r",
							"                        };  // end if else member of existing team or not\r",
							"                    }; // end myfunction_process_all_users\r",
							"\r",
							"                    break;  // end of excludeall case\r",
							"                }\r",
							"\r",
							"                case \"invert\":  // invert requires the need to scan all the users\r",
							"                {\r",
							"                    // all users are stored in the 'all_users' array.\r",
							"                    // for each of these users we need to identify if we need to add or remove any of them to the team for the 'excludeall' action.\r",
							"                    //   the user should be removed from the team if:\r",
							"                    //   they are a manager (if the user is already in the remove list, then another test has already inverted all them)\r",
							"                    //   otherwise they should be added to the add list (as long as they are not already in the remove list (if they where they where inverted by another test))\r",
							"                    //            \r",
							"\r",
							"                    const at_least_one_nonUsersThatAreManager_test = pm.variables.get(\"at_least_one_nonUsersThatAreManager_test\");\r",
							"\r",
							"                    all_users.forEach( myfunction_process_all_users );\r",
							"                    function myfunction_process_all_users( user )\r",
							"                    {\r",
							"                        if ( managers.find(element => element.value === user.value) ) \r",
							"                        {   \r",
							"                            // the user is a manager and should be removed from the team (if they are already in it)\r",
							"\r",
							"                            if ( this_team.members.find(element => element.value === user.value) )  \r",
							"                            {   \r",
							"                                // the user is in existing team and is also a manager - so we must remove the user, unless the user is already in the remove list!\r",
							"                                if ( users_waiting_to_be_removed_in_this_batch.find(element => element.value === user.value) )  // user_found_in_remove_list\r",
							"                                {\r",
							"                                    // user is an existing team member, is a manager BUT has already been 'inverted' by another test, because the user is in the remove list\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already in remove list and inverted by another test (28)');\r",
							"                                }\r",
							"                                else // user can be removed\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' added to remove list and inverted by this test (29)');\r",
							"                                    users_waiting_to_be_removed_in_this_batch.push(user);\r",
							"                                    managers_or_users_to_add++;  // slightly oddd to count towards the add rather than remove, but it makes sense that we've found a user that should be added back in, from previously removed\r",
							"                                };\r",
							"                            }\r",
							"                            else  // the user is NOT in the existing team member and is a manager\r",
							"                            {\r",
							"                                if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === user.value) )  // user_found_in_remove_list\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' previously identifed to be added, now removed from add list as this user is a manager (30)');\r",
							"                                    const userindex = users_waiting_to_be_added_in_this_batch.findIndex(element => element.value === user.value);\r",
							"                                    users_waiting_to_be_added_in_this_batch.splice(userindex,1);\r",
							"                                    managers_or_users_to_add ++;                                    \r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Manager '+user.value+' already not in the team (30a)');\r",
							"                            }; // end if \r",
							"                                // nothing to do!\r",
							"                            };  // end if the user is a team member or not\r",
							"\r",
							"                        }\r",
							"                        else\r",
							"                        {\r",
							"                            // user is NOT a manager. so we must add the user to the team (with some conditions though because the user may have passed another non-manager test)\r",
							"                            if ( this_team.members.find(element => element.value === user.value) )  \r",
							"                            {   \r",
							"                                // user is in the team\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' not a manager but is an existing team member. Leave previous test which may have removed user (31)');\r",
							"                                //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' is not a manager and already in team (32)');\r",
							"                            }\r",
							"                            else  // the user is NOT in the existing team member and is a not manager\r",
							"                            {\r",
							"                                // user is not a manager and not in the team, but should be unless the user has been matched by another test\r",
							"                                if (at_least_one_nonUsersThatAreManager_test)\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' not a manager, not in existing team member and had another nonisManager test. Leave previous test which may have added the user (33)');\r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    //\r",
							"                                    if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === user.value) )  // user_found_in_remove_list\r",
							"                                    {\r",
							"                                        // user is NOT an existing team member, is NOT a manager and has NOT already been 'inverted' by another test (the user is in the remove list)\r",
							"                                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' not a manager, not in existing team and not matched by any other test. Already in add list (34)');\r",
							"                                    }\r",
							"                                    else \r",
							"                                    {\r",
							"                                        //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.value+' not a manager, not in existing team and not matched by any other test. Adding user to add list (35)');\r",
							"                                        users_waiting_to_be_added_in_this_batch.push(user);\r",
							"                                        managers_or_users_to_add++;  // slightly oddd to count towards the add rather than remove, but it makes sense that we've found a user that should be added back in, from previously removed\r",
							"                                    };\r",
							"                                };\r",
							"\r",
							"                            };  // end if the user is a team member or not\r",
							"\r",
							"\r",
							"                        };  // end if else member of existing team or not\r",
							"                    }; // end myfunction_process_all_users\r",
							"\r",
							"                    break;  // end of invert case\r",
							"                }\r",
							"\r",
							"                default:\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled case statement for Users_Action ', Users_Action);\r",
							"                }; // end switch Users_Action\r",
							"                \r",
							"                // now we have processed all the managers we must save the team update\r",
							"                this_team.arrayofusers_waiting_to_be_added_in_this_batch  =users_waiting_to_be_added_in_this_batch;\r",
							"                this_team.arrayofusers_waiting_to_be_removed_in_this_batch=users_waiting_to_be_removed_in_this_batch;\r",
							"                array_of_teams[this_team_index]=this_team;\r",
							"                pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"                //console.log(pm.info.requestName+' '+pm.info.eventName+': teams=',array_of_teams);               \r",
							"\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Post-processing of manangers identified additional changes of '+managers_or_users_to_add+' users to be added and '+managers_or_users_to_remove+' to be removed');\r",
							"\r",
							"            }; // end if Users_That_Are_Managers\r",
							"\r",
							"\r",
							"            if ( displayname_contains_TIMESTAMP ||\r",
							"                    ((users_waiting_to_be_added_in_this_batch.length+users_waiting_to_be_removed_in_this_batch.length) >0 )\r",
							"                )\r",
							"            {\r",
							"                // the team displayname needs an update, OR there's some users that need to be added or removed from the team.\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': All users successfully read. Performing action \\''+Users_Action+'\\' by adding '+this_team.arrayofusers_waiting_to_be_added_in_this_batch.length+' and removing '+this_team.arrayofusers_waiting_to_be_removed_in_this_batch.length+' users in team '+this_team.teamname);\r",
							"\r",
							"\r",
							"                let displayname     = pm.iterationData.get(\"file_team_displayname\");\r",
							"                // the displayname may contain a string of TIMESTAMP and we need to replace this with the current date and time\r",
							"                let  timestamp = new Date();  // get todays date and time. The time will be in UTC.\r",
							"\r",
							"                let timezone_hours   = parseInt(pm.variables.get(\"TimeZoneHours\"));\r",
							"                let timezone_minutes = parseInt(pm.variables.get(\"TimeZoneMinutes\"));\r",
							"                let timezone_text    = pm.variables.get(\"TimeZoneDescription\");\r",
							"    \r",
							"                if ((timezone_hours   === undefined)|| (!Number.isInteger(timezone_hours  )))  { timezone_hours   =0 };\r",
							"                if ((timezone_minutes === undefined)|| (!Number.isInteger(timezone_minutes)))  { timezone_minutes =0 };\r",
							"                if (timezone_text     === undefined) { timezone_text    ='UTC' };\r",
							"                \r",
							"                // const timezone_hours = 1;  const timezone_minutes = 0;  const timezone_text='ECT'; // timezone for European Central Time\r",
							"                // const timezone_hours = 2;  const timezone_minutes = 0;  const timezone_text='EET/ART'; // timezone for Eastern European Time, (Arabic) Egypt Standard Time\t\t\r",
							"                // const timezone_hours = 3;  const timezone_minutes = 0;  const timezone_text='EAT'; // timezone for Eastern African Time\r",
							"                // const timezone_hours = 3;  const timezone_minutes = 30; const timezone_text='MET'; // timezone for Middle East Time\r",
							"                // const timezone_hours = 4;  const timezone_minutes = 0;  const timezone_text='NET'; // timezone for Near East Time\r",
							"                // const timezone_hours = 5;  const timezone_minutes = 0;  const timezone_text='PLT'; // timezone for Pakistan Lahore Time\t\r",
							"                // const timezone_hours = 5;  const timezone_minutes = 30; const timezone_text='IST'; // timezone for India Standard Time\t\r",
							"                // const timezone_hours = 6;  const timezone_minutes = 0;  const timezone_text='BST'; // timezone for Bangladesh Standard Time\t\r",
							"                // const timezone_hours = 7;  const timezone_minutes = 0;  const timezone_text='VST'; // timezone for Vietnam Standard Time\t\r",
							"                // const timezone_hours = 8;  const timezone_minutes = 0;  const timezone_text='CTT'; // timezone for China Taiwan Time\r",
							"                // const timezone_hours = 9;  const timezone_minutes = 0;  const timezone_text='JST'; // timezone for Japan Standard Time\t\r",
							"                // const timezone_hours = 9;  const timezone_minutes = 30; const timezone_text='ACT'; // timezone for Australia Central Time\t\r",
							"                // const timezone_hours = 10; const timezone_minutes = 0;  const timezone_text='AET'; // timezone for Australia Eastern Time\t\r",
							"                // const timezone_hours = 11; const timezone_minutes = 0;  const timezone_text='SST'; // timezone for Solomon Standard Time\t\r",
							"                // const timezone_hours = 12; const timezone_minutes = 0;  const timezone_text='NST'; // timezone for New Zealand Standard Time\t\r",
							"                // const timezone_hours =-11; const timezone_minutes = 0;  const timezone_text='MIT'; // timezone for Midway Islands Time\r",
							"                // const timezone_hours =-10; const timezone_minutes = 0;  const timezone_text='HST'; // timezone for Hawaii Standard Time\r",
							"                // const timezone_hours =-9;  const timezone_minutes = 0;  const timezone_text='AST'; // timezone for Alaska Standard Time\t\r",
							"                // const timezone_hours =-8;  const timezone_minutes = 0;  const timezone_text='PST'; // timezone for Pacific Standard Time\r",
							"                // const timezone_hours =-7;  const timezone_minutes = 0;  const timezone_text='PNT/MST'; // timezone for Phoenix Standard Time, Mountain Standard Time\r",
							"                // const timezone_hours =-6;  const timezone_minutes = 0;  const timezone_text='CST'; // timezone for Central Standard Time\r",
							"                // const timezone_hours =-5;  const timezone_minutes = 0;  const timezone_text='EST/IET'; // timezone for Eastern Standard Time, Indiana Eastern Standard Time\r",
							"                // const timezone_hours =-4;  const timezone_minutes = 0;  const timezone_text='PRT'; // timezone for Puerto Rico and US Virgin Islands Time\r",
							"                // const timezone_hours =-3;  const timezone_minutes =-30; const timezone_text='CNT'; // timezone for Canada Newfoundland Time\r",
							"                // const timezone_hours =-3;  const timezone_minutes = 0;  const timezone_text='AGT/BET'; // timezone for Argentina Standard Time, Brazil Eastern Time\r",
							"                // const timezone_hours =-1;  const timezone_minutes = 0;  const timezone_text='CAT'; // timezone for Central African Time\r",
							"\r",
							"\r",
							"                timestamp.setHours(timestamp.getHours()     + timezone_hours);    // we add (or substract) the hours depending upon the timezone\r",
							"                timestamp.setMinutes(timestamp.getMinutes() + timezone_minutes);  // we add (or substract) the minutes depending upon the timezone\r",
							"                timestamp   = timestamp.toISOString();     // we convert it to a string\r",
							"                timestamp   = timestamp.replace(\"T\",\" \");  // remove the letter T which is between the date and the time which is a bit annoying when trying to read it\r",
							"                timestamp   = timestamp.slice(0,-8);       // remove the last 8 characters so we remove the seconds and leaves just hours and minutes\r",
							"                timestamp   = timestamp.concat(' ',timezone_text);  // add a space character and the text description of the timezone so users can understand the time correctly\r",
							"                displayname = displayname.replace(\"TIMESTAMP\", timestamp); // if TIMESTAMP is not present in the displayname then there's no change, otherwise its replaced with the date+time+text\r",
							"\r",
							"                if (displayname.length>1024)\r",
							"                    {\r",
							"                        // the display length is too long\r",
							"                        console.warn(pm.info.requestName+' '+pm.info.eventName+': displayname has a maximum length of 1024 characters. Truncating displayname');\r",
							"                        displayname=displayname.substr(0,1024);\r",
							"                    }\r",
							"                ; // end if display name is too long\r",
							"                pm.variables.set(\"displayname\",displayname); // we save displayname as a variable so we only process it once. The UPDATE team event will read it and use it in the displayname of the team description.\r",
							"\r",
							"\r",
							"\r",
							"                pm.execution.setNextRequest(); // let Postman run the next call to UPDATE the team\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // team doesn't need an update\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': All users successfully read, but there are no users that need to be processed on team '+this_team.teamname+' which has '+this_team.members.length+' users');\r",
							"                array_of_teams.splice(this_team_index,1);\r",
							"                pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                pm.execution.setNextRequest(null); \r",
							"            }; //end if\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            pm.execution.setNextRequest(pm.info.requestName);  // we call this same request again because its not yet time to update the team!\r",
							"        }; // end if updated needed\r",
							"\r",
							"        break;\r",
							"\r",
							"    }   // end case response is 200\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"}; // end swtich pm.response.code\r",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const StartUserIndex=pm.variables.get(\"StartUserIndex\");\r",
							"const ReadUsersIndexSize=pm.variables.get(\"ReadUsersIndexSize\");\r",
							"const MaxUserIndex=( StartUserIndex + ReadUsersIndexSize -1);\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading users '+StartUserIndex+' to '+MaxUserIndex);\r",
							"\r",
							"// we may be able to filter the list of users to only the ones we need. This logic is determined in the previous 'READ team' 'Tests' request\r",
							"// so it only needs to be determined once. We are then just applying the filter if filtering is an option for our query.\r",
							"if (pm.variables.get(\"filterenabled\"))\r",
							"{\r",
							"    pm.request.url.query.add({key: 'filter', value: encodeURIComponent(pm.variables.get(\"filtervalue\"))})\r",
							"    // for more information on filtering https://help.sap.com/viewer/298f82da4b184d1fb825b7ffe365e94a/LATEST/en-US/da3dc52a0fd44da4b727c89d26326af6.html\r",
							"}\r",
							"\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Users/?startIndex={{StartUserIndex}}&count={{ReadUsersIndexSize}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Users",
						""
					],
					"query": [
						{
							"key": "startIndex",
							"value": "{{StartUserIndex}}"
						},
						{
							"key": "count",
							"value": "{{ReadUsersIndexSize}}"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const currentteam = pm.variables.get(\"currentteam\");\r",
							"//console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+currentteam);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const array_of_teams  = pm.variables.get(\"array_of_teams\");\r",
							"    const this_team_index = array_of_teams.findIndex(element => element.teamname === currentteam);\r",
							"    const this_team       = array_of_teams[this_team_index];\r",
							"        \r",
							"\r",
							"    const meta            = this_team.meta;\r",
							"    const users_chucksize       = this_team.users_chunk_size;\r",
							"    const roles_chunksize       = this_team.roles_chunk_size;\r",
							"    const users_in_this_team_update =this_team.members;\r",
							"    const roles_in_this_team_update =this_team.roles;\r",
							"    const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"    const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"    const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"    const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"\r",
							"    if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_added_in_this_batch)   { roles_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"    \r",
							"\r",
							"    let number_of_users_that_can_change_in_this_chunk;\r",
							"    if ((users_waiting_to_be_added_in_this_batch.length+users_waiting_to_be_removed_in_this_batch.length)>=users_chucksize)\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_chucksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=(users_waiting_to_be_added_in_this_batch.length + users_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"\r",
							"    let number_of_users_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_users_that_can_be_added_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_added_in_this_chunk =0;\r",
							"\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length > number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (users_waiting_to_be_removed_in_this_batch.length<=number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk-number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (users_waiting_to_be_added_in_this_batch.length<number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=users_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    const max_users_in_single_PUT_request = 32767;\r",
							"    if ((this_team.members.length+number_of_users_that_can_be_added_in_this_chunk) > max_users_in_single_PUT_request)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Maximum number of users reached '+max_users_in_single_PUT_request);\r",
							"        number_of_users_that_can_be_added_in_this_chunk=max_users_in_single_PUT_request-this_team.members.length\r",
							"    }\r",
							"\r",
							"\r",
							"\r",
							"    let number_of_roles_that_can_change_in_this_chunk;\r",
							"    if ((roles_waiting_to_be_added_in_this_batch.length+roles_waiting_to_be_removed_in_this_batch.length)>=roles_chunksize)\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=roles_chunksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=(roles_waiting_to_be_added_in_this_batch.length + roles_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"    \r",
							"    if (roles_waiting_to_be_removed_in_this_batch.length > number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_removed_in_this_batch.length<=number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=roles_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk-number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_added_in_this_batch.length<number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=roles_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    if (number_of_users_that_can_be_removed_in_this_chunk > 0)\r",
							"    {\r",
							"        // if we can remove users, then we should remove all users before adding or removing any roles\r",
							"        // we have disabled the ability for any roles to be added or removed under this condition\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        // but if we have any roles to add or remove then we must also prevent any new user from being added in this chunk\r",
							"        // since it is possible users will be removed and added within the same chunk, hence...\r",
							"        if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"        {\r",
							"            // we have now disabled the ability for new users to be added when users can be removed AND when there are role changes\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"        }\r",
							"    }\r",
							"    else if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"    {\r",
							"            // this is when there are users that can be added and there are changed needed to roles.\r",
							"            // in this condition we need to prevent new users from being added until all the role changes have been made.\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    };\r",
							"\r",
							"    let number_of_users_removed = 0;\r",
							"    let number_of_users_added   = 0;\r",
							"\r",
							"    const users_removed_in_this_chunk = [];\r",
							"    while (number_of_users_removed < number_of_users_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_user=users_waiting_to_be_removed_in_this_batch.shift();\r",
							"        users_removed_in_this_chunk.push(removing_user);\r",
							"        \r",
							"        let removing_user_index = users_in_this_team_update.findIndex(element => element.value === removing_user.value);\r",
							"        users_in_this_team_update.splice(removing_user_index,1);\r",
							"        number_of_users_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofusers_removed_in_this_chunk\",users_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_users_added < number_of_users_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        users_in_this_team_update.push(users_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_users_added++;\r",
							"    };\r",
							"\r",
							"\r",
							"    let number_of_roles_removed = 0;\r",
							"    let number_of_roles_added   = 0;\r",
							"\r",
							"    const roles_removed_in_this_chunk = [];\r",
							"    while (number_of_roles_removed < number_of_roles_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_role=roles_waiting_to_be_removed_in_this_batch.shift();\r",
							"        roles_removed_in_this_chunk.push(removing_role);\r",
							"        \r",
							"        let removing_role_index = roles_in_this_team_update.findIndex(element => element === removing_role);\r",
							"        roles_in_this_team_update.splice(removing_role_index,1);\r",
							"        number_of_roles_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofroles_removed_in_this_chunk\",roles_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_roles_added < number_of_roles_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        roles_in_this_team_update.push(roles_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_roles_added++;\r",
							"    };\r",
							"\r",
							"\r",
							"    const number_of_users_actually_changed = number_of_users_that_can_be_added_in_this_chunk + number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    const number_of_roles_actually_changed = number_of_roles_that_can_be_added_in_this_chunk + number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    pm.variables.set(\"number_of_users_in_this_chunk\",number_of_users_actually_changed);\r",
							"    pm.variables.set(\"number_of_roles_in_this_chunk\",number_of_roles_actually_changed);\r",
							"    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"    // displayname is already set in the previous event 'READ all users page by page' and so we don't need to do anything with it here\r",
							"    pm.variables.set(\"meta\",   JSON.stringify(meta));\r",
							"    pm.variables.set(\"members\",JSON.stringify(users_in_this_team_update));\r",
							"    pm.variables.set(\"roles\",  JSON.stringify(roles_in_this_team_update));\r",
							"    pm.variables.set(\"expected_user_count\",users_in_this_team_update.length);\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName\r",
							"                +': Updating team: '+currentteam+': adding '+number_of_users_that_can_be_added_in_this_chunk\r",
							"                +' users, removing '+number_of_users_that_can_be_removed_in_this_chunk\r",
							"                +' users, adding '+number_of_roles_that_can_be_added_in_this_chunk\r",
							"                +' roles, removing '+number_of_roles_that_can_be_removed_in_this_chunk\r",
							"                +' roles');\r",
							"\r",
							"}  // end if errors"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE team\", () => {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"});\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401: // same as 403\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        break;    \r",
							"    } // end response is 401 or 403\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        const readbody            = JSON.parse(pm.response.text());\r",
							"        const expected_user_count = pm.variables.get(\"expected_user_count\");\r",
							"        const actual_user_count   = readbody.members.length;\r",
							"        const previouserrors=pm.variables.get(\"ContinuousErrors\");  // errors holds the number of previous errors before this sucessful event. We need to know this so not to adjust the chunk size.\r",
							"                                                            // adjusting the chunk size after a previous error could be because the previous error was resolved by a repeated call. \r",
							"                                                            // and that repeated call could had taken a fraction of the normal processing time because it had already partly processed it beforehand.\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        \r",
							"        if (expected_user_count === actual_user_count)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in team as expected');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in the team, however '+ expected_user_count+' where expected');\r",
							"        };\r",
							"\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === pm.variables.get(\"currentteam\"));\r",
							"        const this_team = array_of_teams[this_team_index];\r",
							"        \r",
							"        const number_of_user_changes_in_the_last_update=pm.variables.get(\"number_of_users_in_this_chunk\");\r",
							"        if (number_of_user_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const users_per_second = Math.round((number_of_user_changes_in_the_last_update/(pm.response.responseTime/1000))*10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+users_per_second+' users/second');\r",
							"\r",
							"            const users_in_last_request= JSON.parse(pm.variables.get(\"members\"));\r",
							"            users_in_last_request.forEach( myfunction_find_missing_users );\r",
							"            function myfunction_find_missing_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (S3/S1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' was not found in the team, but was expected to be present');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const users_that_should_had_been_removed =pm.variables.get(\"arrayofusers_removed_in_this_chunk\");\r",
							"            users_that_should_had_been_removed.forEach( myfunction_find_not_removed_users );\r",
							"            function myfunction_find_not_removed_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' should had been removed, but was not');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"        \r",
							"        const number_of_roles_changes_in_the_last_update=pm.variables.get(\"number_of_roles_in_this_chunk\");\r",
							"        if (number_of_roles_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const roles_per_second = Math.round((number_of_roles_changes_in_the_last_update/(pm.response.responseTime/1000))*100)/100;\r",
							"            const users_per_role_per_second = Math.round( ((this_team.members.length*number_of_roles_changes_in_the_last_update)/(pm.response.responseTime/1000)) *10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+roles_per_second+' roles/second, '+users_per_role_per_second+' users/role/second');\r",
							"\r",
							"            const roles_in_last_request= JSON.parse(pm.variables.get(\"roles\"));\r",
							"            roles_in_last_request.forEach( myfunction_find_missing_roles );\r",
							"            function myfunction_find_missing_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team, already a member of '+value+' role (R3/R1)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Team not a member of role '+value+' but was expected to be');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const roles_that_should_had_been_removed =pm.variables.get(\"arrayofroles_removed_in_this_chunk\");\r",
							"            roles_that_should_had_been_removed.forEach( myfunction_find_not_removed_roles );\r",
							"            function myfunction_find_not_removed_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Role '+value.value+' should no longer contain this team, but does');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"\r",
							"        const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"        const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"        const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"        const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"        if( (users_waiting_to_be_added_in_this_batch.length\r",
							"            +users_waiting_to_be_removed_in_this_batch.length\r",
							"            +roles_waiting_to_be_added_in_this_batch.length\r",
							"            +roles_waiting_to_be_removed_in_this_batch.length) >0 ) \r",
							"        {\r",
							"            this_team.members=readbody.members;  // we need to reload the members that are actually in the team into our members list so the current list is accurate\r",
							"            this_team.roles  =readbody.roles;\r",
							"\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' users: '+this_team.members.length+' (yet to add: '+users_waiting_to_be_added_in_this_batch.length+' & remove: '+users_waiting_to_be_removed_in_this_batch.length+') member of: '+this_team.roles.length+' roles (yet to be added to: '+roles_waiting_to_be_added_in_this_batch.length+' & removed from: '+roles_waiting_to_be_removed_in_this_batch.length+')');\r",
							"            // need to test if chucksize is too large, if so we need to reduce it\r",
							"\r",
							"            if (number_of_user_changes_in_the_last_update>0) \r",
							"            {\r",
							"                // then our last update was for adding or removing users, so we need to change the chunk size accordingly\r",
							"                // however, there is a condition where we are removing users to allow updates to roles to be made, before we then start adding users in.\r",
							"                // it means that a chunk update may not have been 'full' of users, this in turn means the last update could had been very quick and we need to\r",
							"                // only adjust the chunk size when the last update was 'full'.\r",
							"\r",
							"                const max_users_in_single_PUT_request = 32767;\r",
							"                if (readbody.members.length>=max_users_in_single_PUT_request)\r",
							"                {\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }\r",
							"                else if ( (number_of_user_changes_in_the_last_update === this_team.users_chunk_size) && (previouserrors ===0 ) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.users_chunk_size;\r",
							"                    if (pm.response.responseTime>270000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.6);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime>210000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.8);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 2);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<120000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 1.75);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 2 mins. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.users_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                };\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // our last update was for adding or removing roles, so we need to change the chunk size accordingly \r",
							"                // however we may only remove roles before adding them, so we need to check the chunk was 'full'\r",
							"                if ( (number_of_roles_changes_in_the_last_update === this_team.roles_chunk_size) && (previouserrors === 0) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.roles_chunk_size;\r",
							"                    if ( (pm.response.responseTime>270000)  && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if ( (pm.response.responseTime>210000) && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<20000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 20 secs. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<80000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min 30 secs. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.roles_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                };\r",
							"                pm.execution.setNextRequest(pm.info.requestName); \r",
							"            };\r",
							"        }\r",
							"        else // the current team has been processed\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' update complete it has '+readbody.members.length+' users and is a member of '+readbody.roles.length+' roles');\r",
							"            // so we should now remove the team from the teams array\r",
							"            array_of_teams.splice(this_team_index,1);\r",
							"            pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"            const teams_to_update = array_of_teams.length;\r",
							"            if ( teams_to_update > 0 )\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+array_of_teams[0].teamname);\r",
							"                pm.variables.set(\"currentteam\", array_of_teams[0].teamname);\r",
							"                pm.execution.setNextRequest(pm.info.requestName);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                //console.log(pm.info.requestName+' '+pm.info.eventName+': All teams updated');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"\r",
							"        };  // end waiting to be added/removed\r",
							"\r",
							"        break;\r",
							"    }  // end case response is 200\r",
							"    default:  // response code is unexpected\r",
							"    {\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }  // end default case\r",
							"} // end switch"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],\r\n    \"id\": \"{{currentteam}}\",\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"meta\": {{meta}},\r\n    \"members\": {{members}},\r\n    \"roles\": {{roles}}\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{currentteam}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{currentteam}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating team '+pm.variables.get(\"currentteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401: // same as 403\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        break;\r",
							"    }  //end case 403    \r",
							"\r",
							"    case 201: \r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // the team was created ok, so we can go to re-read the team.\r",
							"        pm.execution.setNextRequest('READ team');\r",
							"        break;\r",
							"    }  // end case 201\r",
							"\r",
							"    case 400:  // shares the same logic as 409\r",
							"    case 409:\r",
							"    {\r",
							"        // although we obtained an unexpected result, this is handled so we shall set the errors to 0.\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team. Teams cannot be created when the team or the team folder already exists. Team folder names are CaSe sensitive, as are team names when reading a team, but unlike team names when creating a team! This means reading a team (which is case sensitive) may not find a team, but when trying to create a team of the same name (which isn\\'t case sensitive), the team creation fails! Aborting this team.  Response: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";\r",
							"}; // end switch pm.response.code"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\": [\r\n    \"urn:ietf:params:scim:schemas:core:2.0:Group\"\r\n  ],\r\n  \"id\": \"{{currentteam}}\",\r\n  \"displayName\": \"{{currentteam}} with Team Folder\"\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE team without folder",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating team '+pm.variables.get(\"currentteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE team without team folder\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 201: \r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // the team was created ok, so we can go to re-read the team.\r",
							"        pm.execution.setNextRequest('READ team');\r",
							"        break;\r",
							"    }  // end case 201\r",
							"\r",
							"    case 400: // same as 409\r",
							"    case 409:\r",
							"    {\r",
							"        // although we obtained an unexpected result, this is handled so we shall set the errors to 0.\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        try {\r",
							"            if ( JSON.parse(pm.response.text()).scimType ==='uniqueness')\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create the team '+pm.variables.get(\"currentteam\")+' using the scim2 endpoint /api/v1/scim2/Groups. This is probably because a team with the same name already exists. Teams created with the scim2 endpoint /api/v1/scim2/Groups will not be readable or updatable using the scim1 /api/v1/scim/Groups/'+pm.variables.get(\"currentteam\")+' endpoint until the System Administration setting \\'Ignore Content Namespace for Teams\\' has been turned ON. Please turn this setting to ON now, and re-run this sample. If this setting is already enabled, but the scim1 /api/v1/scim/Groups/'+pm.variables.get(\"currentteam\")+' endpoint is unable to read the team (a GET request returns a 404), please contact SAP Support. Aborting this team.  Response: '+ pm.response.text());\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team.  Aborting this team.  Response: '+ pm.response.text());\r",
							"            }\r",
							"        }\r",
							"\t\tcatch (error)\r",
							"        { \r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team.  Aborting this team.  Response: '+ pm.response.text());\r",
							"        }\r",
							"        pm.execution.setNextRequest(null);\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";\r",
							"}; // end switch pm.response.code"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "x-sap-sac-create-team-folder",
						"value": "false",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:Group\",\r\n        \"urn:sap:params:scim:schemas:extension:sac:2.0:group-custom-parameters\"\r\n    ],\r\n    \"displayName\": \"{{currentteam}}\",\r\n    \"members\": [],\r\n    \"urn:sap:params:scim:schemas:extension:sac:2.0:group-custom-parameters\": {\r\n        \"description\": \"{{currentteam}}\"\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Groups",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.execution.setNextRequest();                                  // we will now get a new x-csrf-token\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "FETCH csrf token",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.info(pm.info.requestName+' '+pm.info.eventName+': Fetching a new x-csrf-token');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Fetch x-csrf-token\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }\r",
							"    \r",
							"    case 200:\r",
							"    {\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetched a new x-csrf-token');\r",
							"        pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"    } // end switch pm.response.code\r",
							"};\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "fetch",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/csrf",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"csrf"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "initial_read_index_size",
			"value": "200"
		}
	]
}