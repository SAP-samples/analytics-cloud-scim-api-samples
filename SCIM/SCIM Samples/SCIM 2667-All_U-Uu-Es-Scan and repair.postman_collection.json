{
	"info": {
		"_postman_id": "425a6f84-8878-49c5-a861-320def67b012",
		"name": "SCIM 2667-All_U-Uu-Es-Scan and repair",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9.2\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-425a6f84-8878-49c5-a861-320def67b012?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "READ users page by page",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ users page by page\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new tokens: accesstoken & x-csrf-token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody                          = JSON.parse(pm.response.text());\r",
							"        const SAMLSSO                           = pm.variables.get(\"SAMLSSO\");\r",
							"        const repair_mode_enabled               = (pm.collectionVariables.get(\"repair_mode_enabled\")==='true' ?true:false);\r",
							"        const detailed_console_log_enabled      = (pm.collectionVariables.get(\"detailed_console_log_enabled\")==='true' ?true:false);\r",
							"        const user_validation_tests             = pm.collectionVariables.get(\"user_validation_tests\").split(',').map(test => {return eval(test)} );\r",
							"        \r",
							"        const StartUserIndex                    = pm.variables.get(\"StartUserIndex\");\r",
							"        let   ReadUsersIndexSize                = pm.variables.get(\"ReadUsersIndexSize\");\r",
							"        let   all_users                         = pm.variables.get(\"all_users\");\r",
							"        if  (!all_users)\r",
							"        { \r",
							"            all_users            = [];\r",
							"            console.log('The following '+user_validation_tests.length+\" user validation tests are enabled:\");\r",
							"            user_validation_tests.forEach(test => {console.log(\"   \"+test.name)});\r",
							"            if (repair_mode_enabled)\r",
							"            {\r",
							"                console.warn('>>>>>>  Repair mode is enabled. <<<<<<');\r",
							"                if ( ( (SAMLSSO==='userid') || (SAMLSSO==='custom') ) && (user_validation_tests.includes(email_is_valid)))\r",
							"                {\r",
							"                    console.warn('If any changes are needed to update the users e-mail then a configuration change is needed, otherwise those updates will not be accepted. The e-mail which is usually not updatable when the SAML SSO is configured to map the user attribute on USERID or a CUSTOM property. The SCIM API can not update properties that are mapped to SAML attributes. For the SCIM API to update the e-mail, the e-mail must be unmapped as a SAML-mapped property. Log in to SAP Analytics Cloud as an administrator to do this. Then, select Menu-Security-Users and select the button \\'Map SAML User Properties\\', which opens a dialogue box called \\'Map SAML Attribute\\'. Select the SAML Attribute \\'email\\' and press delete and then save. You should add the e-mail as a mapped attribute once you have finished so future e-mail changes are updated when the user next logs in. (For SAP documentation on mapping SAML attributes please visit https://help.sap.com/docs/SAP_ANALYTICS_CLOUD/00f68c2e08b941f081002fd3691d86a7/b385d1af93444e9fbc6439d2c6b3c1a7.html?locale=en-US&q=Map%20SAML%20Attributes%20to%20Users ).');\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.warn('>>>>>> Repair mode is currently not enabled <<<<<< It means no changes will be made and it is perfectly safe to run this sample against your SAP Analytics Cloud Service. To enable repair mode change the Collection variable \\'repair_mode_enabled\\' from false to true');\r",
							"            }\r",
							"            \r",
							"        }\r",
							"\r",
							"        let   bulk_operations                   = pm.variables.get(\"bulk_operations\");\r",
							"        if  (!bulk_operations) { bulk_operations= [] }\r",
							"        const total_users_in_this_SAC_service   = readbody.totalResults;\r",
							"        const users_this_page                   = readbody.Resources ? readbody.Resources.length: 0;\r",
							"        const max_user_index_this_page = StartUserIndex + users_this_page -1;\r",
							"        const users_per_second = Math.round((users_this_page/(pm.response.responseTime/1000))*10)/10;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Analysing '+users_this_page+' users '+StartUserIndex+' to '+max_user_index_this_page+' (throughput: '+users_per_second+' users/sec) of '+total_users_in_this_SAC_service);\r",
							"\r",
							"        \r",
							"\r",
							"        function email_is_valid( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"\r",
							"            const email_string_is_valid = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$/.test(user.email);\r",
							"            const email_repairable=( /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(user.email));\r",
							"\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.test_passed=( email_string_is_valid )\r",
							"\r",
							"                    if (email_repairable)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"emails\",\r",
							"                                            \"value\": [ {\"value\":user.email.toLowerCase(),\"type\":\"work\",\"primary\":true}]\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                            \r",
							"                    }\r",
							"                    \r",
							"                    return (result);\r",
							"                    break;\r",
							"                }\r",
							"                case 'email':\r",
							"                case 'default':\r",
							"                {\r",
							"                    // we test if the email is in lowercase or not,\r",
							"                    // and we also test if the email stored in idpUserId matches\r",
							"                    // the email address as seen in the user interface.\r",
							"\r",
							"                    result.test_passed = (email_string_is_valid && user.idpUserId===user.email);\r",
							"                                       \r",
							"                    if (email_repairable)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"emails\",\r",
							"                                            \"value\": [ {\"value\":user.email.toLowerCase(),\"type\":\"work\",\"primary\":true}]\r",
							"                                        },\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                            \"value\": user.email.toLowerCase()\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        }\r",
							"        \r",
							"        function idpUserId_is_valid( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'email':\r",
							"                case 'default':\r",
							"                {\r",
							"                    result.test_passed = ( user.email===user.idpUserId );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                            \"value\": user.email.toLowerCase()\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                case 'userid':\r",
							"                {\r",
							"                    result.test_passed = ( user.idpUserId===user.userName );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                            \"value\": user.userName\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.test_passed = !(  ( user.idpUserId===undefined )\r",
							"                                        ||( user.idpUserId===''           )\r",
							"                                        ||( user.idpUserId===null\t\t  )   )\r",
							"                    return result\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function externalId_is_valid( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch ('userid')\r",
							"            {\r",
							"                case 'email':\r",
							"                case 'default':\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.test_passed = !(  ( user.externalId===undefined )\r",
							"                                        ||( user.externalId===''           )\r",
							"                                        ||( user.externalId===null\t\t  )   )\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function email_is_unique( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            if (user.idpUserId===undefined) {user.idpUserId=''};\r",
							"            \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'default':\r",
							"                case 'email':\r",
							"                {\r",
							"                    result.conflicting_users=all_users.filter (\r",
							"                        (other_user) =>\r",
							"                            { if (other_user.idpUserId===undefined) {other_user.idpUserId=''};\r",
							"                            return (   (other_user.email.toLowerCase()===user.email.toLowerCase()     )\r",
							"                                    || (other_user.idpUserId.toLowerCase()===user.email.toLowerCase() )\r",
							"                                    || (other_user.email.toLowerCase()===user.idpUserId.toLowerCase() )\r",
							"                                    ) }\r",
							"                    )\r",
							"                    if (result.conflicting_users.length>0)\r",
							"                    {\r",
							"                        result.test_passed=false;\r",
							"                    };\r",
							"                    return (result);\r",
							"                    break;\r",
							"                }\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.conflicting_users=all_users.filter (\r",
							"                        (other_user) =>\r",
							"                            { return (   (other_user.email.toLowerCase()===user.email.toLowerCase()     )\r",
							"                                    ) }\r",
							"                    )\r",
							"                    if (result.conflicting_users.length>0)\r",
							"                    {\r",
							"                        result.test_passed=false;\r",
							"                    };\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function idpUserId_is_unique( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            if (user.idpUserId===undefined) {user.idpUserId=''};\r",
							"            \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'default':\r",
							"                case 'email':\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.conflicting_users=all_users.filter (\r",
							"                        (other_user) =>\r",
							"                            { \r",
							"                                if (other_user.idpUserId===undefined) {other_user.idpUserId=''};\r",
							"                                return (other_user.idpUserId.toLowerCase()===user.idpUserId.toLowerCase())\r",
							"                            }\r",
							"                    )\r",
							"                    if (result.conflicting_users.length>0)\r",
							"                    {\r",
							"                        result.test_passed=false;\r",
							"                    };\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"\r",
							"        function idpUserId_is_not_mismatched( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            if (user.idpUserId===undefined) {user.idpUserId=''};\r",
							"            \r",
							"            \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'default':\r",
							"                case 'email':\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.conflicting_users=all_users.filter (\r",
							"                        (other_user) =>\r",
							"                            { \r",
							"                                if (other_user.idpUserId===undefined) {other_user.idpUserId=''};\r",
							"                                return(  (other_user.idpUserId.toUpperCase()===user.userName.toUpperCase())\r",
							"                                    || (other_user.userName.toUpperCase()===user.idpUserId.toUpperCase()) )\r",
							"                            }\r",
							"                    )\r",
							"                    if (result.conflicting_users.length>0)\r",
							"                    {\r",
							"                        result.test_passed=false;\r",
							"                    };\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\t\r",
							"        \r",
							"        function idpUserId_is_lowercase( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'custom':\r",
							"                {\r",
							"                    if (user.idpUserId===undefined) {user.idpUserId=''};\r",
							"                    result.test_passed = ( user.idpUserId.toLowerCase()===user.idpUserId );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                            \"value\": user.idpUserId.toLowerCase()\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function idpUserId_is_uppercase( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'custom':\r",
							"                {\r",
							"                    if (user.idpUserId===undefined) {user.idpUserId=''};\r",
							"                    result.test_passed = ( user.idpUserId.toUpperCase()===user.idpUserId );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                            \"value\": user.idpUserId.toUpperCase()\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function idpUserId_matches_sacuserid( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.test_passed = ( user.idpUserId===user.userName );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                            \"value\": user.userName\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function externalId_is_unique_or_not_null( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            \r",
							"            \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'default':\r",
							"                case 'email':\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.conflicting_users=all_users.filter (\r",
							"                        (other_user) =>\r",
							"                            { \r",
							"                                if (other_user.externalId===undefined) {other_user.externalId=''};\r",
							"                                const this_user_externalId_is_not_null = (user.externalId!=undefined) ? true: false;\r",
							"                                return ( this_user_externalId_is_not_null && other_user.externalId!=''\r",
							"                                && (other_user.externalId.toLowerCase()===user.externalId.toLowerCase() ) )\r",
							"                            }\r",
							"                    )\r",
							"                    if (result.conflicting_users.length>0)\r",
							"                    {\r",
							"                        result.test_passed=false;\r",
							"                    };\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"                \r",
							"        function externalId_is_not_mismatched( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            if (user.idpUserId===undefined) {user.idpUserId=''};\r",
							"            \r",
							"            \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'default':\r",
							"                case 'email':\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                {\r",
							"                    result.conflicting_users=all_users.filter (\r",
							"                        (other_user) =>\r",
							"                            { \r",
							"                                if (other_user.externalId===undefined) {other_user.externalId=''};\r",
							"                                if (other_user.idpUserId===undefined) {other_user.idpUserId=''};\r",
							"                                const this_user_externalId_is_not_null = (user.externalId!=undefined) ? true: false;\r",
							"                                return ( this_user_externalId_is_not_null \r",
							"                                && (user.email!='')\r",
							"                                && (user.externalId!='')\r",
							"                                &&  ( (other_user.userName.toLowerCase()===user.externalId.toLowerCase() ) \r",
							"                                    ||(other_user.externalId.toLowerCase()===user.userName.toLowerCase() )\r",
							"                                    ||(other_user.idpUserId.toLowerCase()===user.externalId.toLowerCase() )\r",
							"                                    ||(other_user.externalId.toLowerCase()===user.idpUserId.toLowerCase() )\r",
							"                                    ||(other_user.email.toLowerCase()===user.externalId.toLowerCase() ) \r",
							"                                    ||(other_user.externalId.toLowerCase()===user.email.toLowerCase() )\r",
							"                                ))\r",
							"                            \r",
							"                            }\r",
							"                    )\r",
							"                    if (result.conflicting_users.length>0)\r",
							"                    {\r",
							"                        result.test_passed=false;\r",
							"                    };\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\t\r",
							"        \r",
							"        function externalId_is_lowercase( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                default:\r",
							"                {\r",
							"                    if (user.externalId===undefined) {user.externalId=''};\r",
							"                    result.test_passed = ( user.externalId.toLowerCase()===user.externalId );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"externalId\",\r",
							"                                            \"value\": user.externalId.toLowerCase()\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function externalId_is_uppercase( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                default:\r",
							"                {\r",
							"                    if (user.externalId===undefined) {user.externalId=''};\r",
							"                    result.test_passed = ( user.externalId.toUpperCase()===user.externalId );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"externalId\",\r",
							"                                            \"value\": user.externalId.toUpperCase()\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        function externalId_matches_sacuserid( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                case 'email':\r",
							"                case 'default':\r",
							"                {\r",
							"                    result.test_passed = ( user.externalId===user.userName );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"externalId\",\r",
							"                                            \"value\": user.userName\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"        \r",
							"        function externalId_matches_idpUserId( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'userid':\r",
							"                case 'custom':\r",
							"                case 'email':\r",
							"                case 'default':\r",
							"                {\r",
							"                    result.test_passed = ( user.externalId===user.idpUserId );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"externalId\",\r",
							"                                            \"value\": user.idpUserId\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"\r",
							"        function externalId_is_null( user )\r",
							"        {\r",
							"            const result= {\r",
							"                    \"test_passed\":true,\r",
							"                    \"conflicting_users\":[],\r",
							"                    \"patch_operations\":[]\r",
							"                };\r",
							"                \r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                default:\r",
							"                {\r",
							"                    if (user.externalId===undefined) {user.externalId=''};\r",
							"                    result.test_passed = ( user.externalId==='' );\r",
							"                    if (!result.test_passed)\r",
							"                    {\r",
							"                        result.patch_operations.push(\r",
							"                            {\r",
							"                                \"method\": \"PATCH\",\r",
							"                                \"path\": \"/Users/\".concat(user.id),\r",
							"                                \"data\": {\r",
							"                                    \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                    \"Operations\":\r",
							"                                    [\r",
							"                                        {\r",
							"                                            \"op\": \"replace\",\r",
							"                                            \"path\": \"externalId\",\r",
							"                                            \"value\": \"\"\r",
							"                                        }\r",
							"                                    ]\r",
							"                                }\r",
							"                            }\r",
							"                        );\r",
							"                    }\r",
							"                    return result;\r",
							"                    break;\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"        \r",
							"\r",
							"        function myfunction_process_user(user)\r",
							"        {\r",
							"            // an array for each failed test\r",
							"            const failed_tests=[];\r",
							"\r",
							"            user.failed_tests=0;\r",
							"            // for each of the function tests we will call a process which has the same name as the function test\r",
							"            user_validation_tests.forEach(\r",
							"            (function_test) => \r",
							"                { \r",
							"                    // return an object from each function test function. This next line does the magic to call the function\r",
							"                    const {test_passed, conflicting_users, patch_operations } = function_test(user);\r",
							"                    if (!test_passed)\r",
							"                    { \r",
							"                        failed_tests.push(\r",
							"                        {\r",
							"                            // for each failed test we store a few details so we can log then to the console and add the patch_operations, if we are in repair mode, to a variable bulk_operations for processing later\r",
							"                            \"test_failed\":function_test.name,\r",
							"                            \"conflicting_users\":conflicting_users,\r",
							"                            \"patch_operations\":patch_operations\r",
							"                        });\r",
							"\r",
							"                        // define a Postman tesst to show this user failing the test. Feel free to comment-out this next line if the number of tests are huge causing a performance issue\r",
							"                        pm.test(user.userName+\" \"+function_test.name,function() { throw new Error( function_test.name ) });\r",
							"                        \r",
							"                    } // end if test failed\r",
							"\r",
							"                } // end of each functional test\r",
							"            );\r",
							"\r",
							"            // store the number of failed test with the user definition, we shall use this later in the summary\r",
							"            user.failed_tests=failed_tests.length;\r",
							"\r",
							"            if (failed_tests.length>0)\r",
							"            {\r",
							"                \r",
							"                console.error(\"User \"+user.userName+\" failed \"+failed_tests.length+\" test(s)  uuid(id):\"+user.id\r",
							"                    //+\"  id(userName):\"+user.userName\r",
							"                    +\"  email:\"+user.email\r",
							"                    +\"  SAMLmapping(idpUserId):\"+user.idpUserId\r",
							"                    +\"  externalId:\"+user.externalId)\r",
							"                failed_tests.forEach( failed_test =>\r",
							"                {\r",
							"                    if (failed_test.conflicting_users.length===0)\r",
							"                    {\r",
							"                        if (detailed_console_log_enabled) { console.info(\"   \"+user.userName+\" failed the test \"+failed_test.test_failed); }\r",
							"                        if (failed_test.patch_operations.length>0)\r",
							"                        {\r",
							"                            if (repair_mode_enabled)\r",
							"                            {\t//repair mode\r",
							"                                if (user.systemowner)\r",
							"                                {\r",
							"                                    console.log(\"      This user can't be repaired because they are the System Owner, and the API can not update the System Owner.\");\r",
							"                                    console.log(\"      However, the repair Bulk PATCH operation otherwise would be: \"+JSON.stringify(user.patch_operations))\r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    user.repair=true;\r",
							"                                    if (detailed_console_log_enabled) { console.log(\"      The repair Bulk PATCH operation is: \"+JSON.stringify(failed_test.patch_operations)) };\r",
							"                                    failed_test.patch_operations.forEach ( (operation) => {bulk_operations.push(operation)})\r",
							"                                }\r",
							"                            }\r",
							"                            else\r",
							"                            {  // scan only mode\r",
							"                                if (user.systemowner)\r",
							"                                {\r",
							"                                    console.log(\"      This user can't be repaired because, they are the System Owner (and the API can not update the System Owner), and because the repair mode is not enabled. \");\r",
							"                                    console.log(\"      However, if it was and the user was not the System Owner, the Bulk PATCH operation would be: : \"+JSON.stringify(user.patch_operations))\r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    user.repair=true;\r",
							"                                    if (detailed_console_log_enabled) { console.log(\"      Repair mode is not enabled. However, if it was the Bulk PATCH operation would be: \"+JSON.stringify(failed_test.patch_operations)) };\r",
							"                                }\r",
							"                            }\r",
							"                        }\r",
							"                                \r",
							"                    }\r",
							"                    else \r",
							"                    {\r",
							"                        if (detailed_console_log_enabled) { console.info(\"   \"+user.userName+\" failed the test \"+failed_test.test_failed+\" and appears in conflict with \"+failed_test.conflicting_users.length+\" other user(s):\") }\r",
							"                        \r",
							"                        \r",
							"                        failed_test.conflicting_users.forEach( conflicting_user =>\r",
							"                        {\r",
							"                            const other_user_failed_tests=all_users.find (\r",
							"                                (other_user) =>\r",
							"                                    { \r",
							"                                        return (other_user.id===conflicting_user.id)\r",
							"                                    }\r",
							"                            );\r",
							"                            \r",
							"                            const conflicting_user_has_repair_operations = (other_user_failed_tests.repair===true) ? ' including a repair operation)':')';\r",
							"                            const conflicting_user_failed_tests = other_user_failed_tests.failed_tests;\r",
							"                            \r",
							"                            if (detailed_console_log_enabled)\r",
							"                            { \r",
							"                                console.log( \"      uuid(id):\"+conflicting_user.id\r",
							"                                        +\"  id(userName):\"+conflicting_user.userName\r",
							"                                        +\"  email:\"+conflicting_user.email\r",
							"                                        +\"  SAMLmapping(idpUserId):\"+conflicting_user.idpUserId\r",
							"                                        +\"  externalId:\"+conflicting_user.externalId\r",
							"                                        +\"  (previously failed \"+conflicting_user_failed_tests+\" tests\"+conflicting_user_has_repair_operations);\r",
							"                            }\r",
							"                            if (failed_test.patch_operations.length>0)\r",
							"                            {\r",
							"                                if (repair_mode_enabled)\r",
							"                                {\r",
							"                                    // repair mode\r",
							"                                    if (user.systemowner)\r",
							"                                    {\r",
							"                                        console.log(\"      This user can't be repaired because they are the System Owner and the API can not update the System Owner.\");\r",
							"                                        console.log(\"      However, repair Bulk PATCH operation otherwise would be: \"+JSON.stringify(failed_test.patch_operations))\r",
							"                                    }\r",
							"                                    else\r",
							"                                    {\r",
							"                                        user.repair=true;\r",
							"                                        if (detailed_console_log_enabled) { console.log(\"      The repair Bulk PATCH operation is: \"+JSON.stringify(failed_test.patch_operations)); }\r",
							"                                        failed_test.patch_operations.forEach ( (operation) => {bulk_operations.push(operation)})\r",
							"                                    }\r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    //scan only mode\r",
							"                                    if (user.systemowner)\r",
							"                                    {\r",
							"                                        console.log(\"      This user can't be repaired because they are the System Owner, and the API can not update the System Owner.\");\r",
							"                                        console.log(\"      Repair mode is not enabled. However, if it was and the user was not the System Owner, the Bulk PATCH operation would be: : \"+JSON.stringify(user.patch_operations))\r",
							"                                    }\r",
							"                                    else\r",
							"                                    {\r",
							"                                        user.repair=true;\r",
							"                                        if (detailed_console_log_enabled) { console.log(\"      Repair mode is not enabled. However, if it was the Bulk PATCH operation would be: \"+JSON.stringify(failed_test.patch_operations)) };\r",
							"                                    }\r",
							"                                }\r",
							"                            }\r",
							"                        }); //end For each: failed_test.conflicting_users \r",
							"                    }\r",
							"                });\r",
							"                \r",
							"                if (detailed_console_log_enabled) { console.log(); }\r",
							"            }\r",
							"            all_users.push(user);\r",
							"            \r",
							"        }; // end myfunction_process_user        \r",
							"\r",
							"\r",
							"        \r",
							"        // for each user will shall create an object {id, userName, email, idpUserId, externalId, systemowner } and then process this object in myfunction_process_user\r",
							"        readbody.Resources.map( (user) =>\r",
							"        {\r",
							"                return {\"id\": user.id,\r",
							"                        \"userName\": user.userName,\r",
							"                        \"email\": user.emails[0].value,\r",
							"                        \"idpUserId\": user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId,\r",
							"                        \"externalId\":user.externalId,\r",
							"                        \"systemowner\": ( ((user.roles) && (user.roles.find( role => {return role.value==='PROFILE:sap.epm:System_Owner'}))) === true ? true : false)\r",
							"                        }\r",
							"        } ).forEach( myfunction_process_user );\r",
							"        \r",
							"\r",
							"\r",
							"        pm.variables.set(\"all_users\",all_users);\r",
							"        pm.variables.set(\"bulk_operations\",bulk_operations);\r",
							"\r",
							"        // Define the next set of users to query, it will start with the user after the last one\r",
							"        const Next_Read_Start_At = max_user_index_this_page + 1\r",
							"        pm.variables.set(\"StartUserIndex\",Next_Read_Start_At);\r",
							"\r",
							"        ReadUsersIndexSize=pm.variables.get(\"ReadUsersIndexSize\");\r",
							"        if ((Next_Read_Start_At+ReadUsersIndexSize-1) > total_users_in_this_SAC_service)\r",
							"        {\r",
							"            pm.variables.set(\"ReadUsersIndexSize\",(total_users_in_this_SAC_service-Next_Read_Start_At+1));\r",
							"        }\r",
							"\r",
							"        if ( Next_Read_Start_At>total_users_in_this_SAC_service)\r",
							"        {\r",
							"            const total_users_with_a_failed_test=all_users.filter( user => {return user.failed_tests>0}).length;\r",
							"            const news = (total_users_with_a_failed_test===0) ? 'Congratulations! All users appear entirely consistent. ' : 'Potential inconsistencies have been identified. ';\r",
							"            if (bulk_operations.length>0)\r",
							"            {\r",
							"                if (repair_mode_enabled)\r",
							"                {\r",
							"                    console.log(\"Scan complete. \"+news+total_users_with_a_failed_test+\" out of \"+total_users_in_this_SAC_service+\" user(s) failed at least one test. Repair mode is enabled. \"+bulk_operations.length+\" user(s) will now be updated.\");\r",
							"                    pm.execution.setNextRequest();\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.log(\"Scan complete. \"+news+total_users_with_a_failed_test+\" out of \"+total_users_in_this_SAC_service+\" user(s) failed at least one test. Repair mode is not enabled. If repair mode was enabled, then \"+bulk_operations.length+\" user(s) would now be updated.\");\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.info(\"Scan complete. \"+news+total_users_with_a_failed_test+\" out of \"+total_users_in_this_SAC_service+\" users failed at least one test, and there are no repair operations.\");\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"            pm.variables.unset(\"all_users\");\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"\r",
							"        \r",
							"\r",
							"        break;\r",
							"    }   // end case response is 200\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"}; // end swtich pm.response.code"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"let  StartUserIndex=pm.variables.get(\"StartUserIndex\");\r",
							"if (!StartUserIndex)\r",
							"{ \r",
							"    StartUserIndex=1;\r",
							"    pm.variables.set(\"StartUserIndex\",1);\r",
							"    pm.variables.set(\"ReadUsersIndexSize\",200);\r",
							"}\r",
							"const ReadUsersIndexSize=pm.variables.get(\"ReadUsersIndexSize\");\r",
							"const MaxUserIndex=( StartUserIndex + ReadUsersIndexSize -1);\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading users '+StartUserIndex+' to '+MaxUserIndex);\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/?startIndex={{StartUserIndex}}&count={{ReadUsersIndexSize}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						""
					],
					"query": [
						{
							"key": "startIndex",
							"value": "{{StartUserIndex}}"
						},
						{
							"key": "count",
							"value": "{{ReadUsersIndexSize}}"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "REPAIR users (Bulk)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"REPAIR user (bulk)\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"    \r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const bulk_operations            = pm.variables.get(\"bulk_operations\");\r",
							"        const bulk_maxOperations         = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"        const OperationsInThisUpdate     = (bulk_operations.length<bulk_maxOperations) ? bulk_operations.length : bulk_maxOperations;\r",
							"        const OperationsInThisBulkUpdate = bulk_operations.splice(0,OperationsInThisUpdate);\r",
							"        const OperationsResponse = JSON.parse(pm.response.text()).Operations.map( (operationresponse, index) =>\r",
							"        { \r",
							"            let status=(operationresponse.status!==undefined) ? parseInt(operationresponse.status) : parseInt(operationresponse.response.status);\r",
							"            let detail=''\r",
							"            try {\r",
							"                detail=operationresponse.response.detail\r",
							"            }\r",
							"            catch(err)\r",
							"            {\r",
							"                detail='';\r",
							"            }\r",
							"            return {\"status\": status, \"detail\": detail, \"operation\": OperationsInThisBulkUpdate[index]}\r",
							"        });\r",
							"\r",
							"\r",
							"        const total_operations_not_processed  = OperationsInThisBulkUpdate.length - OperationsResponse.length;\r",
							"        const valid_response_status      = [200];\r",
							"        const successfully_operations    = OperationsResponse.filter( (response) => {return  valid_response_status.includes(response.status)} );\r",
							"        const failed_operations          = OperationsResponse.filter( (response) => {return !valid_response_status.includes(response.status)} );\r",
							"        const operations_not_processed   = OperationsInThisBulkUpdate.slice( OperationsInThisBulkUpdate.length - total_operations_not_processed )\r",
							"\r",
							"\r",
							"   \r",
							"\r",
							"        successfully_operations.forEach( (operation) =>\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+operation.operation.path+' now updated.');\r",
							"        } );\r",
							"\r",
							"        failed_operations.forEach( (operation) =>\r",
							"        {\r",
							"            switch (operation.status)\r",
							"            {\r",
							"            case 403:\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': operation '+operation.operation.path+' update will be re-attempted as it appears the session timed out mid-operation.');\r",
							"                    bulk_operations.push(operation.operation);\r",
							"                    break;\r",
							"                }\r",
							"            default:\r",
							"                {\r",
							"                    // there was a previous error\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': Update for operation '+operation.operation.path+' failed. The bulk request operation was: '+JSON.stringify(operation.operation)+' and the response was: '+operation.status+' '+operation.detail);\r",
							"                    pm.test(operation.operation.path,function() { throw new Error( operation.operation.path ) });\r",
							"                 }\r",
							"            } // end swtich operation.status\r",
							"        } );\r",
							"        \r",
							"\r",
							"        operations_not_processed.forEach( (operation) =>\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': operation '+operation.path+' was not processed in the bulk request. Operation will be re-attempted.');\r",
							"            bulk_operations.push(operation);\r",
							"        } );\r",
							"\r",
							"\r",
							"        if (bulk_operations.length>0) \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+bulk_operations.length+' operation(s) remain to be updated.');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Completed.');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        };\r",
							"\r",
							"        pm.variables.set(\"bulk_operations\",bulk_operations);\r",
							"        break;\r",
							"\r",
							"\r",
							"\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const bulk_operations           = pm.variables.get(\"bulk_operations\");\r",
							"    const bulk_maxOperations        = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"    const OperationsInThisUpdate    = (bulk_operations.length<bulk_maxOperations) ? bulk_operations.length : bulk_maxOperations;\r",
							"    const OperationsInThisBulkUpdate= bulk_operations.slice(0,OperationsInThisUpdate);\r",
							"    const bulk_request=\r",
							"    {\r",
							"        \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:BulkRequest\"],\r",
							"        \"failOnErrors\":1,\r",
							"        \"Operations\": OperationsInThisBulkUpdate\r",
							"    };\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Bulk updating '+OperationsInThisUpdate+' users.');\r",
							"    pm.variables.set(\"bulk_request_body\",JSON.stringify(bulk_request));\r",
							"}"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{bulk_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Bulk",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Bulk"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 200:\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.execution.setNextRequest();                                   // we will now get a new x-csrf-token\r",
							"        break;\r",
							"    }\r",
							"    case 401:\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }; //end if \r",
							"        break;\r",
							"    }\r",
							"}; // switch case\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}/oauth/token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}"
					],
					"path": [
						"oauth",
						"token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "FETCH csrf token",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new x-csrf-token');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Fetch x-csrf-token\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"    case 200:\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetched a new x-csrf-token');\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"    } // end switch pm.response.code\r",
							"};\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "fetch",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/csrf",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"csrf"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "repair_mode_enabled",
			"value": "false",
			"type": "string"
		},
		{
			"key": "user_validation_tests",
			"value": "email_is_valid,email_is_unique,idpUserId_is_valid,idpUserId_is_not_mismatched,idpUserId_is_unique,externalId_is_unique_or_not_null,externalId_is_not_mismatched",
			"type": "string"
		},
		{
			"key": "detailed_console_log_enabled",
			"value": "true",
			"type": "string"
		},
		{
			"key": "bulk_maxOperations",
			"value": "30",
			"type": "string"
		}
	]
}