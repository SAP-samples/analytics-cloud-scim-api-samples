{
	"info": {
		"_postman_id": "f3391c1c-c7f4-4567-85a8-f9765c186b22",
		"name": "SCIM 2666-U-CDU-Fcj-Es-Migrate UserID",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9.1\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-f3391c1c-c7f4-4567-85a8-f9765c186b22?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "READ source user and validate for new user",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ source user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new tokens: accesstoken & x-csrf-token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        pm.variables.set(\"StartUserIndex\",1);\r",
							"        pm.variables.set(\"ReadUsersIndexSize\",200);\r",
							"        pm.variables.unset(\"UsersNeedingNewManager\");\r",
							"\r",
							"\r",
							"\r",
							"        let source_userid    = pm.iterationData.get(\"file_source_userid\").toUpperCase();\r",
							"        let target_userid    = pm.iterationData.get(\"file_target_userid\").toUpperCase();\r",
							"\r",
							"        const readbody                  = JSON.parse(pm.response.text());\r",
							"        const totalResults              = readbody.totalResults;\r",
							"\r",
							"        const delete_source_user_even_when_personal_content_exists = (pm.collectionVariables.get(\"delete_source_user_even_when_personal_content_exists\")==='true');\r",
							"        const delete_source_user_even_when_public_content_exists   = (pm.collectionVariables.get(\"delete_source_user_even_when_public_content_exists\"  )==='true');\r",
							"        const repository_content_read                              = (pm.variables.get(\"repository_content_read\")===true);\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"        const need_to_read_repository_content = (\r",
							"                                                    ( !delete_source_user_even_when_personal_content_exists || !delete_source_user_even_when_public_content_exists)\r",
							"                                                &&  ( !repository_content_read)\r",
							"                                                );\r",
							"        if (need_to_read_repository_content)\r",
							"        {\r",
							"            pm.execution.setNextRequest(\"READ repository content\");\r",
							"            // Once the repository content has been read, Postman will send back to this request\r",
							"        }\r",
							"        else\r",
							"        {   // repository content has either been read, or doesn't need to be read\r",
							"            if (totalResults>0)\r",
							"            {\r",
							"                const source_user       =readbody.Resources.filter( user => user.userName===source_userid );\r",
							"                const target_user       =readbody.Resources.filter( user => user.userName===target_userid );\r",
							"                const conflicting_user  =readbody.Resources.filter( user => (user.userName!==source_userid) && (user.userName!==target_userid) );\r",
							"\r",
							"                const source_user_is_system_owner = ((source_user.length===1) && (source_user.roles) && (source_user.roles[0]='PROFILE:sap.epm:System_Owner'))\r",
							"\r",
							"                if (source_user_is_system_owner)\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+\": Source user \"+source_userid+\" is the System Owner. The System Owner can not be updated. Aborting user ID migration.\");\r",
							"                    pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                }\r",
							"                else if (conflicting_user.length===0)\r",
							"                {\r",
							"                    if ( (source_user.length===1) && (target_user.length===0) )\r",
							"                    {\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+\": Source user \"+source_userid+\" found. No conflicts identified.\");\r",
							"                        switch (pm.variables.get(\"SAMLSSO\"))\r",
							"                        {\r",
							"                            case 'email':\r",
							"                            {\r",
							"                                pm.execution.setNextRequest(\"CREATE target user\"); \r",
							"                                break;\r",
							"                            }\r",
							"                            case 'default':\r",
							"                            case 'custom':\r",
							"                            case 'userid':\r",
							"                            {\r",
							"                                pm.execution.setNextRequest();  // we need to update the email or custom property so when we create the new user there is no clash of email on custom property\r",
							"                                break;\r",
							"                            }\r",
							"                            default:\r",
							"                            {\r",
							"                                pm.execution.setNextRequest();\r",
							"                                break;\r",
							"                            }\r",
							"\r",
							"                        }\r",
							"                        pm.variables.set(\"source_user\",source_user[0]);\r",
							"                        pm.variables.unset(\"target_user\"); \r",
							"                    }\r",
							"                    else if ( (source_user.length===1) && (target_user.length===1))\r",
							"                    {\r",
							"                        const hours_since_target_user_was_created =((Math.floor( (new Date() - Date.parse(target_user[0].meta.created) ) / (1000 * 60 * 60 ) )));\r",
							"                        if (hours_since_target_user_was_created<=parseInt(pm.collectionVariables.get(\"resume_migration_if_target_user_already_exists_and_created_within_last_x_hours\")))\r",
							"                        {\r",
							"                            console.info(pm.info.requestName+' '+pm.info.eventName+\": Source user \"+source_userid+\" and target user \"+target_userid+\" found. Target user created within last 24 hours. Resuming user ID migration.\");\r",
							"                            pm.variables.set(\"source_user\",source_user[0]); \r",
							"                            pm.variables.set(\"target_user\",target_user[0]);\r",
							"\r",
							"                            // we may not need to update the roles and license, we should check before we make this request. If the roles and license are ok, we should then check the teams are correct or not. if they are correct, then check to see if the source user is a manager or not.\r",
							"\r",
							"                            pm.execution.setNextRequest('UPDATE target user correcting roles and BI concurrent setting');\r",
							"                        }\r",
							"                        else\r",
							"                        {\r",
							"                            console.error(pm.info.requestName+' '+pm.info.eventName+\": Source user \"+source_userid+\" and target user \"+target_userid+\" found. Target user created over 24 hours ago. Aborting user ID migration.\");\r",
							"                            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                        }\r",
							"                    }\r",
							"                    else if ( (source_user.length===0) && (target_user.length===1))\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+\": Unexpected: Did not find source user \"+source_userid+\", but found target user \"+target_userid+'. No user ID to migrate, aborting this user ID migration.');\r",
							"                        pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+\": Unhandled exception 1, aborting this user ID migration.\");\r",
							"                        pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                    }\r",
							"                }\r",
							"                else if (conflicting_user.length>=1)\r",
							"                {\r",
							"                    if ( (source_user.length===1) && (target_user.length===0) )\r",
							"                    {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+\": Unexpected: Found source user \"+source_userid+\", but also found a conflict with the idpUserId of \"+conflicting_user.length+\" different user(s):\");\r",
							"                    pm.execution.setNextRequest(NextPostmanRequest());\r",
							"\r",
							"                    }\r",
							"                    else if ( (source_user.length===0) && (target_user.length===0) )\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+\": Unexpected: Did not find source user \"+source_userid+\", but also found a conflict with the idpUserId of \"+conflicting_user.length+\" different user(s):\");\r",
							"\r",
							"                        pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                    }\r",
							"                    else if ( (source_user.length===0) && (target_user.length===1) )\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+\": Unexpected: Did not fund source user \"+source_userid+\", instead found target user \"+target_userid+\". But also found a conflict with the idpUserId of \"+conflicting_user.length+\" different user(s):\");\r",
							"                        pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                    }\r",
							"                    else if ( (source_user.length===1) && (target_user.length===1) )\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+\": Found source user \"+source_userid+\" and target user \"+target_userid+\". But also found a conflict with the idpUserId of \"+conflicting_user.length+\" different user(s):\");\r",
							"                        pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                        \r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+\": Unhandled exception 2, aborting.\");\r",
							"                        pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                    };\r",
							"                    conflicting_user.ForEach( ( user , userindex )=> { console.error( userindex+': ID: '+user.userName+', UUID: '+user.id+\", dpUserID: \"+user['urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters'].idpUserId+\". This matches the desired target user ID. The new target user can not be created because of a clash of idpUserId with this user. Aborting user ID migration.\");});\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+\": Source user \"+source_userid+\" not found. Aborting this user ID migration.\");\r",
							"                pm.execution.setNextRequest(NextPostmanRequest());\r",
							"            }\r",
							"        }\r",
							"        break;\r",
							"    }   // end case response is 200\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"}; // end swtich pm.response.code"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const source_userid    = pm.iterationData.get(\"file_source_userid\").toUpperCase();\r",
							"const target_userid    = pm.iterationData.get(\"file_target_userid\").toUpperCase();\r",
							"\r",
							"pm.variables.set(\"filter_for_userids\",\r",
							"      \"userName eq \\\\\\\"\"\r",
							"    + source_userid \r",
							"    + \"\\\\\\\" or userName eq \\\\\\\"\" \r",
							"    + target_userid \r",
							"    + \"\\\\\\\" or urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId eq \\\\\\\"\"\r",
							"    + target_userid \r",
							"    + \"\\\\\\\" \" );\r",
							"\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading source user '+source_userid+', and validating target '+target_userid);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n     \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\r\n     \"filter\":\r\n        \"{{filter_for_userids}}\"\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/.search",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						".search"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE source user with temporary values",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const source_userid   = pm.iterationData.get(\"file_source_userid\").toUpperCase();\r",
							"    const   source_user   = pm.variables.get(\"source_user\");\r",
							"    const now = new Date();  // get todays date and time. The time will be in UTC.\r",
							"    let timezone_hours   = parseInt(pm.variables.get(\"TimeZoneHours\"));\r",
							"    let timezone_minutes = parseInt(pm.variables.get(\"TimeZoneMinutes\"));\r",
							"    if ((timezone_hours   === undefined)|| (!Number.isInteger(timezone_hours  )))  { timezone_hours   =0 };\r",
							"    if ((timezone_minutes === undefined)|| (!Number.isInteger(timezone_minutes)))  { timezone_minutes =0 };\r",
							"    now.setHours(now.getHours()     + timezone_hours);    // we add (or substract) the hours depending upon the timezone\r",
							"    now.setMinutes(now.getMinutes() + timezone_minutes);  // we add (or substract) the minutes depending upon the timezone\r",
							"    const timestamp=now.getFullYear().toString().concat((\"0\"+(now.getMonth()+1)).slice(-2),(\"0\"+now.getDate()).slice(-2),now.getHours(),now.getMinutes(),now.getSeconds());\r",
							"    const   email = source_user.emails[0].value;\r",
							"    const new_temporary_email = email.substr(0,email.search(\"@\")).concat(\"+\",timestamp,email.substr(email.search(\"@\"))).toLowerCase();\r",
							"\r",
							"    const Operations=new Array();\r",
							"\r",
							"    switch (pm.variables.get(\"SAMLSSO\"))\r",
							"    {\r",
							"        case 'userid':\r",
							"        {\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"emails\",\r",
							"                \"value\": [ {\"value\":new_temporary_email,\"type\":\"work\",\"primary\":true}]\r",
							"            });\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Updating source user '+source_userid+' with temporary email: '+ new_temporary_email );\r",
							"            break;\r",
							"        }\r",
							"        \r",
							"        case 'email':\r",
							"        case 'default':\r",
							"        {\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"emails\",\r",
							"                \"value\": [ {\"value\":new_temporary_email,\"type\":\"work\",\"primary\":true}]\r",
							"            });\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                \"value\": new_temporary_email\r",
							"            });\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Updating source user '+source_userid+' with temporary email: '+ new_temporary_email );\r",
							"            break;\r",
							"        }\r",
							"\r",
							"        case 'custom':\r",
							"        {\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"emails\",\r",
							"                \"value\": [ {\"value\":new_temporary_email,\"type\":\"work\",\"primary\":true}]\r",
							"            });\r",
							"            \r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                \"value\": \"Migrating_User_ID_\".concat(timestamp)\r",
							"            });\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Updating source user '+source_userid+' with temporary email: '+ new_temporary_email +', and temporary idpUserId: Migrating_User_ID_'+timestamp);\r",
							"            break;\r",
							"        }\r",
							"\r",
							"        default: \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': SAML SSO Exception. Source user '+source_userid );\r",
							"            break;\r",
							"        }\r",
							"    }; // end switch on SAML SSO\r",
							"\r",
							"\r",
							"    const source_user_patch_request=\r",
							"    {\r",
							"        \"schemas\": [\r",
							"            \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\r",
							"        ],\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"\r",
							"\r",
							"    pm.variables.set(\"source_user_uuid\",source_user.id);\r",
							"    pm.variables.set(\"user_request_body\",JSON.stringify(source_user_patch_request));\r",
							"}\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE source user with temporary values\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"const source_userid = pm.iterationData.get(\"file_source_userid\").toUpperCase();\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 400:\r",
							"    {\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            const   source_user   = pm.variables.get(\"source_user\");\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Update for user '+source_user.id+' '+source_user.userName+' failed. Assuming user definition is partly inconsistent, now attempting to repair.');\r",
							"            pm.variables.set(\"repair_user\",source_user);\r",
							"            pm.variables.set(\"recovery_from_repair\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(\"READ user for repair\");\r",
							"        }\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const source_user   = pm.variables.get(\"source_user\");\r",
							"        const updated_user = JSON.parse(pm.response.text());\r",
							"\r",
							"        const user_email_was_updated\t=(updated_user.emails[0].value!=source_user.emails[0].value);\r",
							"        const user_idpUserId_was_updated=(updated_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId!=source_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId);\r",
							"\t\t\r",
							"\t\tswitch (pm.variables.get(\"SAMLSSO\"))\r",
							"\t\t{\r",
							"\t\t\tcase 'email':\r",
							"\t\t\tcase 'default':\r",
							"\t\t\t{\r",
							"\t\t\t\tif (user_email_was_updated && user_idpUserId_was_updated)\r",
							"\t\t\t\t{\r",
							"\t\t\t\t\tconsole.log(pm.info.requestName+' '+pm.info.eventName+': User '+updated_user.userName+' updated with temporary email '+updated_user.emails[0].value);\r",
							"\t\t\t\t\tif (!user_email_was_updated) { console.error(pm.info.requestName+' '+pm.info.eventName+': User email was not updated as expected. This prevents new user creation with the same email. Aborting. The response from attempting to update the user was: '+ pm.response.text())}\r",
							"\t\t\t\t\tif (!user_idpUserId_was_updated) { console.error(pm.info.requestName+' '+pm.info.eventName+': User idpUserId was not updated as expected. This prevents new user creation with the same email. Aborting. The response from attempting to update the user was: '+ pm.response.text())}\r",
							"\t\t\t\t\tpm.execution.setNextRequest();\r",
							"\t\t\t\t}\r",
							"\t\t\t\telse\r",
							"\t\t\t\t{\r",
							"\t\t\t\t\tpm.execution.setNextRequest(NextPostmanRequest ());\r",
							"\t\t\t\t}\r",
							"\t\t\t\tbreak;\r",
							"\t\t\t\t\r",
							"\t\t\t}\r",
							"\t\t\tcase 'userid':\r",
							"\t\t\t{\r",
							"\t\t\t\tif (user_email_was_updated)\r",
							"\t\t\t\t{\r",
							"\t\t\t\t\tconsole.log(pm.info.requestName+' '+pm.info.eventName+': User '+updated_user.userName+' updated with temporary email '+updated_user.emails[0].value);\r",
							"\t\t\t\t\tpm.execution.setNextRequest();\r",
							"\t\t\t\t}\r",
							"\t\t\t\telse\r",
							"\t\t\t\t{\r",
							"\t\t\t\t\tconsole.error(pm.info.requestName+' '+pm.info.eventName+': User email was not updated as expected. This prevents new user creation with the same e-mail. Aborting. The source user definition shows an unchanged e-mail : '+ pm.response.text())\r",
							"\t\t\t\t\tconsole.error(pm.info.requestName+' '+pm.info.eventName+': This sample needs to update the e-mail, which is usually not updatable when the SAML SSO is configured to map the user attribute on USERID (or a CUSTOM property). The SCIM API can not update properties that are mapped to SAML attributes. For the SCIM API to update the e-mail, the e-mail must be unmapped as a SAML-mapped property. Log in to SAP Analytics Cloud as an administrator to do this. Then, select Menu-Security-Users and select the button \\'Map SAML User Properties\\', which opens a dialogue box called \\'Map SAML Attribute\\'. Select the SAML Attribute \\'email\\' and press delete and then save. This sample is then not expected to error, so please try again. You should add the e-mail as a mapped attribute once you have finished so future e-mail changes are updated when the user next logs in. (For SAP documentation on mapping SAML attributes please visit https://help.sap.com/docs/SAP_ANALYTICS_CLOUD/00f68c2e08b941f081002fd3691d86a7/b385d1af93444e9fbc6439d2c6b3c1a7.html?locale=en-US&q=Map%20SAML%20Attributes%20to%20Users ).');\r",
							"\t\t\t\t\tpm.execution.setNextRequest(NextPostmanRequest ());\r",
							"\t\t\t\t}\r",
							"\t\t\t\tbreak;\r",
							"\t\t\t}\r",
							"\t\t\tcase 'custom':\r",
							"\t\t\t{\r",
							"\t\t\t\tif (user_email_was_updated && user_idpUserId_was_updated)\r",
							"\t\t\t\t{\r",
							"\t\t\t\t\tconsole.log(pm.info.requestName+' '+pm.info.eventName+': User '+updated_user.userName+' updated with temporary email '+updated_user.emails[0].value+', and temporary idpUserId '+updated_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId);\r",
							"\t\t\t\t\tpm.execution.setNextRequest();\r",
							"\t\t\t\t}\r",
							"\t\t\t\telse\r",
							"\t\t\t\t{\r",
							"\t\t\t\t\tconsole.error(pm.info.requestName+' '+pm.info.eventName+': User email and/or idpUserId was not updated as expected. This prevents new user creation with the same e-mail and/or idpUserId. Aborting. The source user definition shows an unchanged e-mail and/or idpUserId : '+ pm.response.text())\r",
							"\t\t\t\t\tconsole.error(pm.info.requestName+' '+pm.info.eventName+': This sample needs to update the e-mail, which is usually not updatable when the SAML SSO is configured to map the user attribute on a CUSTOM property (or on USERID). The SCIM API can not update properties that are mapped to SAML attributes. For the SCIM API to update the e-mail, the e-mail must be unmapped as a SAML-mapped property. Log in to SAP Analytics Cloud as an administrator to do this. Then, select Menu-Security-Users and select the button \\'Map SAML User Properties\\', which opens a dialogue box called \\'Map SAML Attribute\\'. Select the SAML Attribute \\'email\\' and press delete and then save. This sample is then not expected to error, so please try again. You should add the e-mail as a mapped attribute once you have finished so future e-mail changes are updated when the user next logs in. (For SAP documentation on mapping SAML attributes please visit https://help.sap.com/docs/SAP_ANALYTICS_CLOUD/00f68c2e08b941f081002fd3691d86a7/b385d1af93444e9fbc6439d2c6b3c1a7.html?locale=en-US&q=Map%20SAML%20Attributes%20to%20Users ).');\r",
							"\t\t\t\t\tpm.execution.setNextRequest(NextPostmanRequest ());\r",
							"\t\t\t\t}\r",
							"\t\t\t\t\r",
							"\t\t\t\tbreak;\r",
							"\t\t\t}\r",
							"\r",
							"\t\t} // end SAMLSSO switch\r",
							"        break;\r",
							"    }\r",
							"    default:// response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors updating user '+source_userid+'. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest ());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected updating user '+source_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error updating user '+source_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"   }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{source_user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{source_user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE target user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const source_userid   = pm.iterationData.get(\"file_source_userid\").toUpperCase();\r",
							"const target_userid   = pm.iterationData.get(\"file_target_userid\").toUpperCase();\r",
							"\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating target user: '+ target_userid );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const source_user        = pm.variables.get(\"source_user\");\r",
							"const target_user_request= {};\r",
							"const elements_to_remove = ['id','meta','groups','emails'];\r",
							"\r",
							"// we copy the source user definition to the target user, but we can ignore a few elements_to_remove as they are ignored on the POST to create a user\r",
							"Object.keys(source_user).forEach( key => {  if (!elements_to_remove.includes(key)) { target_user_request[key]=source_user[key] }} );\r",
							"// we need to create a new array for emails rather than copy a reference to it, because we need to update the email and not update the referenced version\r",
							"target_user_request.emails=[]\r",
							"target_user_request.emails.push({ \"value\": source_user.emails[0].value.toLowerCase(), \"type\": \"work\", \"primary\":true});\r",
							"\r",
							"// its important we set the email to lowercase, espically for when SAML SSO is mapped on email (otherwise it won't work!) and if we ensure all emails are in lowercase, then\r",
							"// should there ever be a time the SAML SSO is changed, the emails are already in lowercase for it to work when SAML SSO is mapped on email.\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"switch (pm.variables.get(\"SAMLSSO\"))\r",
							"{\r",
							"    case 'default':\r",
							"    {\r",
							"        target_user_request.emails[0].value=target_user_request.emails[0].value.toLowerCase();\r",
							"        target_user_request.userName=target_userid;\r",
							"        // the next line is important. There was a problem (which has since been resolved) with the default authentication, it allowed creating users with a mixed CaSe of email.\r",
							"        // The idpUserId should always match the emails[0].value so forcing the idpUserId to be in lower case by copying it from emails[0].value ensures we resolve any potential issues.\r",
							"        // in theroy we don't need to do this since the API will force the email to lowercase, but it just might cause an issue with these samples, so we shall force it to lowerecase too.\r",
							"        // The other potential problem is resolves is where the email in each location simply is inconsitent and so this line will correct any bad data.\r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_user_request.emails[0].value;\r",
							"\r",
							"        // the next line should remain commented-out, because this will copy the idpUserId to the email which is typically not desired\r",
							"        // target_user_request.emails[0].value=target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId;\r",
							"        break;\r",
							"    }\r",
							"    case 'email':\r",
							"    {\r",
							"        const now = new Date();  // get todays date and time. The time will be in UTC.\r",
							"        let timezone_hours   = parseInt(pm.variables.get(\"TimeZoneHours\"));\r",
							"        let timezone_minutes = parseInt(pm.variables.get(\"TimeZoneMinutes\"));\r",
							"        if ((timezone_hours   === undefined)|| (!Number.isInteger(timezone_hours  )))  { timezone_hours   =0 };\r",
							"        if ((timezone_minutes === undefined)|| (!Number.isInteger(timezone_minutes)))  { timezone_minutes =0 };\r",
							"        now.setHours(now.getHours()     + timezone_hours);    // we add (or substract) the hours depending upon the timezone\r",
							"        now.setMinutes(now.getMinutes() + timezone_minutes);  // we add (or substract) the minutes depending upon the timezone\r",
							"        const timestamp=now.getFullYear().toString().concat((\"0\"+(now.getMonth()+1)).slice(-2),(\"0\"+now.getDate()).slice(-2),now.getHours(),now.getMinutes(),now.getSeconds());\r",
							"\r",
							"        const               email = source_user.emails[0].value.toLowerCase();\r",
							"        const new_temporary_email = email.substr(0,email.search(\"@\")).concat(\"+\",timestamp,email.substr(email.search(\"@\")));\r",
							"        target_user_request.emails[0].value=new_temporary_email;\r",
							"        target_user_request.userName=target_userid;\r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=new_temporary_email;\r",
							"\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        target_user_request.emails[0].value=target_user_request.emails[0].value.toLowerCase();\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on custom property. It means the userName (SAML Mapping) can be independent for the SAC userid and the email\r",
							"        // here we are setting the username to be the userid as specified in the data file (file_userid). This means the userid email and userName can all be different.\r",
							"        // the username will be updated later in the UPDATE user request later.\r",
							"        target_user_request.userName=target_userid;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'userid':\r",
							"    {\r",
							"        target_user_request.emails[0].value=target_user_request.emails[0].value.toLowerCase();\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on userid property. This means we must not use the email in the userName as an error will be returned.\r",
							"        // instead we will specify the userid alone\r",
							"        target_user_request.userName=target_userid;\r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_userid;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default: \r",
							"    {\r",
							"        target_user_request.emails[0].value=target_user_request.emails[0].value.toLowerCase();\r",
							"        target_user_request.userName=target_userid;\r",
							"        break;\r",
							"    }\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"pm.variables.set(\"user_request_body\",JSON.stringify(target_user_request));"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE target user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,201,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"\r",
							"const target_userid = pm.iterationData.get(\"file_target_userid\").toUpperCase();\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 502:\r",
							"    {\r",
							"        // we received a 502 which suggests the user was created but we can't be 100% sure.\r",
							"        // we shall thus go and read the user again, as its likely the user was created.\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Possible error when creating user '+pm.iterationData.get(\"file_target_userid\").toUpperCase()+'. Assuming user created ok and re-reading user. Response: '+pm.response.text());\r",
							"        pm.execution.setNextRequest(\"READ source user and validate for new user\");\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 409:\r",
							"    {\r",
							"        // there is a conflict and so the user must already exist\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Failed to create user '+pm.iterationData.get(\"file_target_userid\").toUpperCase()+'. The definition of this source user was previously updated successfully with temporary values. However, this could now prevent the user from being able to log in because the new target user failed to be created. This sample will now attempt to restore those original values, ensuring the user can log in again. This sample will then create a new target user but with temporary values. So, instead of updating the source user with temporary values for e-mail and creating a user with all the correct e-mail values, a different workflow will now be followed. The workflow for this user migration is to create a new target user but with temporary values for e-mail and idpUserId. The user will be appropriately updated with roles/teams, etc. The source user will then be deleted. Once the source user has been deleted, the target user will then be updated with the correct e-mail and idpUserId the source user had. This workflow is likely to resolve the error here, where the user failed to be created. It\\'s likely the user creation failed because the user had never logged on or not had their e-mail manually updated in the user interface since the user was created. This is an exceptional edge use case and is generally not expected, though not unheard of.  The response from the API from the POST request to create the new target user was: '+pm.response.text());\r",
							"        pm.execution.setNextRequest(\"RESTORE source user\");\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 201:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const source_user   = pm.variables.get(\"source_user\");\r",
							"        const target_userid = pm.iterationData.get(\"file_target_userid\").toUpperCase();\r",
							"        const target_user_created = JSON.parse(pm.response.text());\r",
							"\r",
							"        pm.variables.set(\"target_user\",target_user_created);\r",
							"        const userid_created_in_SAC=target_user_created.userName;\r",
							"\r",
							"        pm.execution.setNextRequest();\r",
							"\r",
							"        switch (pm.variables.get(\"SAMLSSO\"))\r",
							"        {\r",
							"            \r",
							"            case 'default':\r",
							"            case 'userid':\r",
							"            case 'custom':\r",
							"            {\r",
							"                if (source_user.emails[0].value!==target_user_created.emails[0].value)\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': The new target user has a different e-mail than the source. This suggests the source user\\'s settings were incorrect and could have prevented the user from being able to log in. The new target user has e-mail '+target_user_created.emails[0].value+', compared to the source user of '+source_user.emails[0].value+'. The new target user e-mail was obtained from the email property rather than the idpUserId value. The email is seen from within the user interface of SAP Analytics Cloud, unlike the idpUserId.');\r",
							"                };\r",
							"\r",
							"                if (source_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId!==target_user_created[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId)\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': The new target user has a different idpUserId than the source. This is highly unusual! This suggests the source user\\'s settings were incorrect. The new target user has idpUserId '+target_user_created[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId+', compared to the source user of '+source_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId+'. The new target user idpUserId has been determined by SAP Analytics Cloud and may now have resolved a problem that could have prevented the user from logging in.');\r",
							"                }\r",
							"                //no break please - it must continue into the next 'email' case\r",
							"            }\r",
							"\r",
							"            case 'email':\r",
							"            {\r",
							"                if (target_user_created.userName===target_userid)\r",
							"                {\r",
							"                    console.info(pm.info.requestName+' '+pm.info.eventName+': Target user created successfully: '+userid_created_in_SAC);\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': Target user created but with different user ID than requested. Requested: '+target_userid+' but created: '+userid_created_in_SAC+'. Aborting user ID migration.');\r",
							"                    pm.execution.setNextRequest(NextPostmanRequest ());\r",
							"                };\r",
							"\r",
							"                if ( (source_user.active) !==target_user_created.active)\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': New target user is \\'activated\\' unlike the source user which is \\'deactivated\\'. It is not possible to create users as \\'deactivated\\' which means you may need to manually change the activation status for this user: '+userid_created_in_SAC);\r",
							"                }\r",
							"\r",
							"            }\r",
							"\r",
							"        }\r",
							"        \r",
							"\r",
							"        break;\r",
							"    }\r",
							"    default:// response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors creating user '+target_userid+'. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest ());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected creating user '+target_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error creating user '+target_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"   }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE target user correcting roles and BI concurrent setting",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const   source_user   = pm.variables.get(\"source_user\");\r",
							"const   target_user   = pm.variables.get(\"target_user\");\r",
							"\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Updating target user '+target_user.userName+' with license and roles');\r",
							"\r",
							"const Operations=new Array();\r",
							"\r",
							"if (source_user.roles)\r",
							"{\r",
							"    Operations.push({\r",
							"        \"op\": \"replace\",\r",
							"        \"path\": \"roles\",\r",
							"        \"value\": source_user.roles\r",
							"    });\r",
							"}\r",
							"else if (target_user.roles) // we may need to remove some roles that where assigned. Such roles will have been assigned because they are default roles.\r",
							"{\r",
							"    Operations.push({\r",
							"    \"op\": \"replace\",\r",
							"    \"path\": \"roles\",\r",
							"    \"value\": []\r",
							"    });\r",
							"}\r",
							"else\r",
							"{\r",
							"    // there source user has no roles, and the target user has no roles. There's no roles to update.\r",
							"}\r",
							"\r",
							"// the isConcurrent setting may also be incorrect due to the use of default roles. We shall force the right license type.\r",
							"Operations.push({\r",
							"    \"op\": \"replace\",\r",
							"    \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters.isConcurrent\",\r",
							"    \"value\": source_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].isConcurrent\r",
							"});\r",
							"\r",
							"const target_user_patch_request=\r",
							"{\r",
							"    \"schemas\": [\r",
							"        \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\r",
							"    ],\r",
							"    \"Operations\": Operations\r",
							"};\r",
							"\r",
							"pm.variables.set(\"target_user_uuid\",target_user.id);\r",
							"pm.variables.set(\"user_request_body\",JSON.stringify(target_user_patch_request));"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE target user correcting roles and concurrent setting\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"let   source_user   = pm.variables.get(\"source_user\");\r",
							"let   target_user   = pm.variables.get(\"target_user\");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 400:\r",
							"    {\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const target_user = pm.variables.get(\"target_user\");\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Update for target user '+target_user.id+' '+target_user.userName+' failed. Assuming user definition is partly inconsistent, now attempting to repair.');\r",
							"            pm.variables.set(\"repair_user\",target_user);\r",
							"            pm.variables.set(\"recovery_from_repair\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(\"READ user for repair\");\r",
							"        }\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': User '+target_user.userName+' roles and BI license type settings updated.');\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"\r",
							"        if (!source_user.groups) {source_user.groups=[] };\r",
							"        if (!target_user.groups) {target_user.groups=[] };       \r",
							"\r",
							"        const teams_that_target_user_needs_to_be_added_to=source_user.groups.filter( source_user_group => {\r",
							"            return !(target_user.groups.find( team => team.value===source_user_group.value)  )\r",
							"            })\r",
							"\r",
							"        teams_that_target_user_needs_to_be_added_to.forEach( team =>\r",
							"        {\r",
							"            const this_team_index = array_of_teams.findIndex(element => element.id === team.value);\r",
							"\r",
							"            if ( this_team_index >=0 )\r",
							"            {\r",
							"                array_of_teams[this_team_index].users_waiting_to_be_added_in_this_batch.push(target_user.id);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                array_of_teams.push({\r",
							"                    id: team.value,\r",
							"                    display: team.display,\r",
							"                    users_chunk_size: parseInt(pm.collectionVariables.get(\"initial_users_chunk_size_for_team_updates\")),\r",
							"                    users_waiting_to_be_removed_in_this_batch: [],\r",
							"                    users_waiting_to_be_added_in_this_batch: new Array(target_user.id)\r",
							"                });\r",
							"            }\r",
							"        })\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"        const teams_that_target_user_needs_to_be_removed_from=target_user.groups.filter( target_user_group => {\r",
							"            return !(source_user.groups.find( team => team.value===target_user_group.value)  )\r",
							"            });\r",
							"\r",
							"\r",
							"        teams_that_target_user_needs_to_be_removed_from.forEach( team =>\r",
							"        {\r",
							"            const this_team_index = array_of_teams.findIndex(element => element.id === team.value);\r",
							"            if ( this_team_index >=0 )\r",
							"            {\r",
							"                array_of_teams[this_team_index].users_waiting_to_be_removed_in_this_batch.push(target_user.id);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                array_of_teams.push({\r",
							"                    id: team.value,\r",
							"                    display: team.display,\r",
							"                    users_chunk_size: parseInt(pm.collectionVariables.get(\"initial_users_chunk_size_for_team_updates\")),\r",
							"                    users_waiting_to_be_removed_in_this_batch: new Array(target_user.id),\r",
							"                    users_waiting_to_be_added_in_this_batch: []\r",
							"                });\r",
							"            }\r",
							"        })\r",
							"\r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"        pm.execution.setNextRequest();\r",
							"\r",
							"        break;\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{target_user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{target_user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "SEARCH users where the source user is their manager",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const source_user           = pm.variables.get(\"source_user\");\r",
							"pm.variables.set(\"filter_for_userids\",\"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User:manager.value eq \\\\\\\"\" + source_user.id + \"\\\\\\\"   \" );\r",
							"const StartUserIndex        = pm.variables.get(\"StartUserIndex\");\r",
							"const ReadUsersIndexSize    = pm.variables.get(\"ReadUsersIndexSize\");\r",
							"const MaxUserIndex=( StartUserIndex + ReadUsersIndexSize -1);\r",
							"\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Searching for users that have the source user, '+source_user.userName+' as their manager. Reading users '+StartUserIndex+' onwards.');"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"SEARCH users where the source user is their manager\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new tokens: accesstoken & x-csrf-token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody                  = JSON.parse(pm.response.text());\r",
							"        const total_users               = readbody.totalResults;\r",
							"        const users_this_page           = readbody.Resources === undefined ? 0 :readbody.Resources.length;\r",
							"        const StartUserIndex            = pm.variables.get(\"StartUserIndex\");\r",
							"        let   UsersNeedingNewManager    = pm.variables.get(\"UsersNeedingNewManager\");\r",
							"        if  (!UsersNeedingNewManager)   { UsersNeedingNewManager =[] };\r",
							"        \r",
							"\r",
							"        function AddUserToDelete_And_Update_UsersList ( source_user, target_user )\r",
							"        {\r",
							"            const delete_source_user_even_when_personal_content_exists = (pm.collectionVariables.get(\"delete_source_user_even_when_personal_content_exists\")==='true');\r",
							"            const delete_source_user_even_when_public_content_exists   = (pm.collectionVariables.get(\"delete_source_user_even_when_public_content_exists\"  )==='true');\r",
							"            const test_repository_content = (!delete_source_user_even_when_personal_content_exists || !delete_source_user_even_when_public_content_exists);\r",
							"\r",
							"\r",
							"            let   delete_source_user=true;\r",
							"            if (test_repository_content)\r",
							"            {\r",
							"                const users_with_private_content_array = pm.variables.get(\"users_with_private_content_array\");\r",
							"                const users_with_public_content_array  = pm.variables.get(\"users_with_public_content_array\");\r",
							"                const do_not_delete_users_with_personal_content_and_source_user_has_private_content = (!delete_source_user_even_when_personal_content_exists) && (users_with_private_content_array.includes(source_user.userName));\r",
							"                const do_not_delete_users_with_public_content_and_source_user_has_public_content    = (!delete_source_user_even_when_public_content_exists) && (users_with_public_content_array.includes(source_user.userName));\r",
							"                if ( do_not_delete_users_with_personal_content_and_source_user_has_private_content )\r",
							"                {\r",
							"                    // delete_source_user_even_when_personal_content_exists is false, which means we must do delete the user if they have personal contant\r",
							"                    delete_source_user=false;\r",
							"                    if (!delete_source_user_even_when_public_content_exists && do_not_delete_users_with_public_content_and_source_user_has_public_content)\r",
							"                    {\r",
							"                        console.warn(pm.info.requestName+' '+pm.info.eventName+': Source user '+source_user.userName+' will not be deleted since they have personal content. Manually delete this source user and choose the option \\'Transfer all content to another user\\' to transfer the personal content to another user, such as the target user.');\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        console.warn(pm.info.requestName+' '+pm.info.eventName+': Source user '+source_user.userName+' will not be deleted since they have personal content. Either move this personal content to the new target users personal folder and then re-run this sample to programmatically delete this source user; or manually delete this source user and choose the option \\'Transfer all content to another user\\' to transfer the personal content to another user, such as the target user.');\r",
							"                    }\r",
							"                }\r",
							"                if (do_not_delete_users_with_public_content_and_source_user_has_public_content )\r",
							"                {\r",
							"                    // users_with_public_content_array is false, which means we must do delete the user if they have public contant\r",
							"                    delete_source_user=false;\r",
							"                    if (delete_source_user_even_when_personal_content_exists)\r",
							"                    {\r",
							"                        console.warn(pm.info.requestName+' '+pm.info.eventName+': Source user '+source_user.userName+' will not be deleted since they have public content. Manually delete this source user and choose the option \\'Delete private files and only transfer public and shared content\\' to transfer the content to another user, such as the target user. ');\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        console.warn(pm.info.requestName+' '+pm.info.eventName+': Source user '+source_user.userName+' will not be deleted since they have public content. Manually delete this source user and choose the option \\'Transfer all content to another user\\' to transfer the content to another user, such as the target user. ');\r",
							"                    }\r",
							"                }                \r",
							"            }\r",
							"\r",
							"            if (delete_source_user)\r",
							"            {\r",
							"                let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"                if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"                UsersNeedToBeDeleted.push(({\"id\": source_user.id, \"userName\": source_user.userName}))\r",
							"                pm.variables.set(\"UsersNeedToBeDeleted\",UsersNeedToBeDeleted);\r",
							"\r",
							"                if (pm.variables.get(\"SAMLSSO\")==='email')\r",
							"                {\r",
							"                    let  TargetUsersNeedUpdating       = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                    if (!TargetUsersNeedUpdating)      {TargetUsersNeedUpdating = []};\r",
							"                    TargetUsersNeedUpdating.push(({\"id\": target_user.id, \"userName\": target_user.userName, \"email\": source_user.emails[0].value.toLowerCase()}))\r",
							"                    pm.variables.set(\"TargetUsersNeedUpdating\",TargetUsersNeedUpdating);\r",
							"\r",
							"                }\r",
							"                \r",
							"            }\r",
							"            return;\r",
							"        }\r",
							"\r",
							"\r",
							"        if (users_this_page>0)\r",
							"        {\r",
							"            const max_user_index_this_page          = StartUserIndex + users_this_page -1;\r",
							"            const Next_Read_Start_At                = max_user_index_this_page + 1\r",
							"            pm.variables.set(\"StartUserIndex\",Next_Read_Start_At);\r",
							"            pm.variables.set(\"ReadUsersIndexSize\",(total_users-Next_Read_Start_At+1))\r",
							"            readbody.Resources.forEach( (user) => {UsersNeedingNewManager.push({\"id\": user.id, \"userName\": user.userName})});\r",
							"            pm.variables.set(\"UsersNeedingNewManager\",UsersNeedingNewManager);\r",
							"            if (max_user_index_this_page>=total_users)\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': Source user is a manager of '+total_users+' other user(s)');\r",
							"                AddUserToDelete_And_Update_UsersList(pm.variables.get(\"source_user\"),pm.variables.get(\"target_user\"));\r",
							"                const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    pm.execution.setNextRequest(\"UPDATE user so their manager is new target user (Bulk)\");\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    pm.execution.setNextRequest();\r",
							"                }\r",
							"                \r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // no need to add the source user to the list of users to be deleted, at least not just yet, since there are more users to read.\r",
							"                pm.execution.setNextRequest(pm.info.requestName);\r",
							"            }\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Source user is not a manager of other users');\r",
							"            AddUserToDelete_And_Update_UsersList(pm.variables.get(\"source_user\"),pm.variables.get(\"target_user\"));\r",
							"            pm.execution.setNextRequest(NextPostmanRequest())\r",
							"        }    \r",
							"        break;\r",
							"    }   // end case response is 200\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"}; // end swtich pm.response.code\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n     \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:SearchRequest\"],\r\n     \"filter\": \"{{filter_for_userids}}\",\r\n     \"startIndex\": {{StartUserIndex}},\r\n     \"count\": {{ReadUsersIndexSize}}\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/.search",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						".search"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE user so their manager is new target user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const target_user               = pm.variables.get(\"target_user\");\r",
							"    const UsersNeedingNewManager    = pm.variables.get(\"UsersNeedingNewManager\");\r",
							"    const user_needing_new_manager  = UsersNeedingNewManager.slice(0,1)[0];\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Updating user '+user_needing_new_manager.userName+' to have new manager '+target_user.userName);\r",
							"\r",
							"    const Operations=new Array();\r",
							"\r",
							"    Operations.push({\r",
							"        \"op\": \"replace\",\r",
							"        \"path\": \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User:manager.value\",\r",
							"        \"value\": target_user.id\r",
							"    });\r",
							"\r",
							"    const user_patch_request=\r",
							"    {\r",
							"        \"schemas\": [\r",
							"            \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\r",
							"        ],\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"    pm.variables.set(\"user_uuid\",user_needing_new_manager.id);\r",
							"    pm.variables.set(\"user_request_body\",JSON.stringify(user_patch_request));\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user so their manager is new target user\", function ()\r",
							"    {\r",
							"        if (( pm.variables.get(\"SAMLSSO\") ) ==='email' || ( pm.variables.get(\"SAMLSSO\") )==='default' )\r",
							"        {\r",
							"            pm.expect(pm.response.code).to.be.oneOf([200,400,401,403])\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"        }\r",
							"    }\r",
							");\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"    \r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 400:\r",
							"    {\r",
							"        // \r",
							"        // we are trapping a condition here when the PATCH request returns a 400 typically with a pm.response.text():\r",
							"        //  {\"schemas\":[\"urn:ietf:params:scim:api:messages:2.0:Error\"],\"status\":\"400\",\"scimType\":\"invalidValue\",\"detail\":\"Request is unparsable, syntactically incorrect, or violates schema.\"}\r",
							"        // this will occur when:\r",
							"        //    1 ) the users email is not 100% the same when compared between the emails[0].value and the idpUserId AND when the SAML SSO is either default or email.\r",
							"        //    2 ) the users idpUserId value is not 100% the same when compared between the userName and the idpUserId AND when the SAML SSO is userid\r",
							"        //\r",
							" \r",
							"        pm.variables.set(\"ContinuousErrors\",0); // seems odd perhaps that we are not adding to the error count, but we are managing this error by capturing the error in the users entry\r",
							"                                                // in UsersNeedingNewManager, and then repairing the user, before then trying again. If we spot the user entry in UsersNeedingNewManager\r",
							"                                                // has already captured an error we will skip the user.\r",
							"        const source_user            = pm.variables.get(\"source_user\");\r",
							"        const target_user            = pm.variables.get(\"target_user\");\r",
							"        const UsersNeedingNewManager = pm.variables.get(\"UsersNeedingNewManager\");\r",
							"        const this_user              = UsersNeedingNewManager.splice(0,OperationsInThisUpdate)[0];\r",
							"        const previouserror          = (this_user.previouserror!==undefined) ? this_user.previouserror : 0;\r",
							"\r",
							"        switch (previouserror)\r",
							"        {\r",
							"            case 0:\r",
							"            {\r",
							"                // no previous error\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': Update for user '+this_user.id+' '+this_user.userName+' has failed. A repair of the user will now be attempted to try and resolve this error. Response code: '+pm.response.code+' '+pm.response.text());\r",
							"                UsersNeedingNewManager.push({...this_user, \"previouserror\": previouserror});\r",
							"                pm.variables.set(\"UsersNeedingNewManager\",UsersNeedingNewManager);\r",
							"\r",
							"                pm.variables.set(\"repair_user\",this_user);\r",
							"                pm.variables.set(\"recovery_from_repair\",pm.info.requestName);\r",
							"                pm.execution.setNextRequest(\"READ user for repair\");\r",
							"                user_needs_repair=true;  // needed so we later skip the pm.execution.setNextRequest setting later that would ignore the line above this\r",
							"                break;\r",
							"            }\r",
							"            default:\r",
							"            {\r",
							"                // there was a previous error\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Update for user '+this_user.id+' '+this_user.userName+' failed for the second time and after a possible repair of that user. This user could not be updated to have a manager as the new target user '+target_user.userName+'. It is, therefore, likely that the deletion of the source user, '+source_user.userName+', will also fail because the user '+this_user.userName+' still has them as their manager. Response code: '+pm.response.cod+' '+pm.response.text());\r",
							"                \r",
							"                \r",
							"                if (UsersNeedingNewManager.length>0) \r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedingNewManager.length+' users remain to be updated.');\r",
							"                    pm.execution.setNextRequest(pm.info.requestName);\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': All users updated with new target user as their manager.');\r",
							"                    pm.execution.setNextRequest(NextPostmanRequest());\r",
							"                };\r",
							"\r",
							"            } // end default case\r",
							"        } // end previouserror switch\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const target_user   = pm.variables.get(\"target_user\");\r",
							"        const UsersNeedingNewManager   = pm.variables.get(\"UsersNeedingNewManager\");\r",
							"        const user_needing_new_manager = UsersNeedingNewManager.splice(0,1)[0];\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': '+user_needing_new_manager.userName+' now updated with their manager to be the new target user '+target_user.userName+'.');\r",
							"        pm.variables.set(\"UsersNeedingNewManager\",UsersNeedingNewManager);\r",
							"        if (UsersNeedingNewManager.length>0) \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedingNewManager.length+' users remain to be updated.');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': All users updated with new target user as their manager.');\r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        };\r",
							"\r",
							"        break;\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            const UsersNeedingNewManager   = pm.variables.get(\"UsersNeedingNewManager\");\r",
							"            UsersNeedingNewManager.splice(0,1);\r",
							"            pm.variables.set(\"UsersNeedingNewManager\",UsersNeedingNewManager);\r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE user so their manager is new target user (Bulk)",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const target_user               = pm.variables.get(\"target_user\");\r",
							"    const UsersNeedingNewManager    = pm.variables.get(\"UsersNeedingNewManager\");\r",
							"    const bulk_maxOperations        = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"    const OperationsInThisUpdate    = (UsersNeedingNewManager.length<bulk_maxOperations) ? UsersNeedingNewManager.length : bulk_maxOperations;\r",
							"    const UsersInThisBulkUpdate     = UsersNeedingNewManager.slice(0,OperationsInThisUpdate);\r",
							"    const Operations                = UsersInThisBulkUpdate.map( user => {\r",
							"        return {\r",
							"            \"method\": \"PATCH\",\r",
							"            \"path\": \"/Users/\".concat(user.id),\r",
							"            \"data\": {\r",
							"                \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                \"Operations\":\r",
							"                [\r",
							"                    {\r",
							"                        \"op\": \"replace\",\r",
							"                        \"path\": \"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User:manager.value\",\r",
							"                        \"value\": target_user.id\r",
							"                    }\r",
							"                ]\r",
							"        }\r",
							"    }});\r",
							"\r",
							"    const bulk_request=\r",
							"    {\r",
							"        \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:BulkRequest\"],\r",
							"        \"failOnErrors\":1,\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Bulk updating '+OperationsInThisUpdate+' users to have new manager '+target_user.userName );\r",
							"    pm.variables.set(\"bulk_request_body\",JSON.stringify(bulk_request));\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE user so their manager is new target user (bulk)\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"    \r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const source_user   = pm.variables.get(\"source_user\");\r",
							"        const target_user   = pm.variables.get(\"target_user\");\r",
							"        const UsersNeedingNewManager     = pm.variables.get(\"UsersNeedingNewManager\");\r",
							"        const bulk_maxOperations         = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"        const OperationsInThisUpdate     = (UsersNeedingNewManager.length<bulk_maxOperations) ? UsersNeedingNewManager.length : bulk_maxOperations;\r",
							"        const UsersInThisBulkUpdate      = UsersNeedingNewManager.splice(0,OperationsInThisUpdate);\r",
							"        const OperationsResponse = JSON.parse(pm.response.text()).Operations.map( (operationresponse, index) =>\r",
							"        { \r",
							"            let status=(operationresponse.status!==undefined) ? parseInt(operationresponse.status) : parseInt(operationresponse.response.status);\r",
							"            let detail=''\r",
							"            try {\r",
							"                detail=operationresponse.response.detail\r",
							"            }\r",
							"            catch(err)\r",
							"            {\r",
							"                detail='';\r",
							"            }\r",
							"            let previouserror=(UsersInThisBulkUpdate[index].previouserror!==undefined) ? UsersInThisBulkUpdate[index].previouserror : 0;\r",
							"            \r",
							"            return {\"id\": UsersInThisBulkUpdate[index].id, \"userName\": UsersInThisBulkUpdate[index].userName, \"status\": status, \"detail\": detail, \"previouserror\": previouserror}\r",
							"        });\r",
							"\r",
							"\r",
							"        const total_users_not_processed  = UsersInThisBulkUpdate.length - OperationsResponse.length;\r",
							"        const valid_response_status      = [200];\r",
							"        const users_successfully_updated = OperationsResponse.filter( (response) => {return  valid_response_status.includes(response.status)} );\r",
							"        const users_not_updated          = OperationsResponse.filter( (response) => {return !valid_response_status.includes(response.status)} );\r",
							"        const users_not_processed        = UsersInThisBulkUpdate.slice( UsersInThisBulkUpdate.length - total_users_not_processed )\r",
							"        let   user_needs_repair          = false;\r",
							"\r",
							"        users_successfully_updated.forEach( (user) =>\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+user.userName+' now updated with their manager to be the new target user '+target_user.userName+'.');\r",
							"        } );\r",
							"\r",
							"        users_not_updated.forEach( (user) =>\r",
							"        {\r",
							"            switch (user.status)\r",
							"            {\r",
							"            case 403:\r",
							"                {\r",
							"                    console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' update will be re-attempted as it appears the session timed out mid-operation.');\r",
							"                    UsersNeedingNewManager.push(user);\r",
							"                    break;\r",
							"                }\r",
							"            default:\r",
							"                {\r",
							"                    switch (user.previouserror)\r",
							"                    {\r",
							"                        case 0:\r",
							"                        {\r",
							"                            // no previous error\r",
							"                            console.info(pm.info.requestName+' '+pm.info.eventName+': Update for user '+user.id+' '+user.userName+' has failed. A repair of the user will now be attempted to try and resolve this error. Response code: '+user.status+' '+user.detail);\r",
							"\r",
							"                            user.previouserror = user.status;\r",
							"                            UsersNeedingNewManager.push(user);\r",
							"                            pm.variables.set(\"repair_user\",user);\r",
							"                            pm.variables.set(\"recovery_from_repair\",pm.info.requestName);\r",
							"                            pm.execution.setNextRequest(\"READ user for repair\");\r",
							"                            user_needs_repair=true;  // needed so we later skip the pm.execution.setNextRequest setting later that would ignore the line above this\r",
							"                            break;\r",
							"                        }\r",
							"                        default:\r",
							"                        {\r",
							"                            // there was a previous error\r",
							"                            console.error(pm.info.requestName+' '+pm.info.eventName+': Update for user '+user.id+' '+user.userName+' failed for the second time and after a possible repair of that user. This user could not be updated to have a manager as the new target user '+target_user.userName+'. It is, therefore, likely that the deletion of the source user, '+source_user.userName+', will also fail because the user '+user.userName+' still has them as their manager. Response code: '+user.status+' '+user.detail);\r",
							"                            pm.test('Update manager '+user.userName,function() { throw new Error( user.userName ) });\r",
							"                        }\r",
							"                    }\r",
							"                }\r",
							"            } // end swtich user.status\r",
							"        } );\r",
							"        \r",
							"\r",
							"        users_not_processed.forEach( (user) =>\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' was not processed in the bulk request. User update will be re-attempted.');\r",
							"            UsersNeedingNewManager.push(user);\r",
							"        } );\r",
							"\r",
							"\r",
							"        if (user_needs_repair===false) // if the user needs repair the pm.execution.setNextRequest has already been set correctly.\r",
							"            {\r",
							"            if (UsersNeedingNewManager.length>0) \r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedingNewManager.length+' users remain to be updated.');\r",
							"                pm.execution.setNextRequest(pm.info.requestName);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': All users updated with new target user as their manager.');\r",
							"                pm.execution.setNextRequest(NextPostmanRequest());\r",
							"            };\r",
							"        };\r",
							"        pm.variables.set(\"UsersNeedingNewManager\",UsersNeedingNewManager);\r",
							"        break;\r",
							"\r",
							"\r",
							"\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{bulk_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Bulk",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Bulk"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE team membership",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const currentteam = pm.variables.get(\"currentteam\");\r",
							"\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const array_of_teams  = pm.variables.get(\"array_of_teams\");\r",
							"    const this_team_index = array_of_teams.findIndex(team => team.id === currentteam);\r",
							"    const this_team       = array_of_teams[this_team_index];\r",
							"    const users_chucksize = this_team.users_chunk_size;\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+this_team.display);\r",
							"\r",
							"    const users_waiting_to_be_added_in_this_batch  =this_team.users_waiting_to_be_added_in_this_batch;\r",
							"    const users_waiting_to_be_removed_in_this_batch=this_team.users_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"    if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"    \r",
							"\r",
							"\r",
							"    let number_of_users_that_can_change_in_this_chunk;\r",
							"    if ((users_waiting_to_be_added_in_this_batch.length+users_waiting_to_be_removed_in_this_batch.length)>=users_chucksize)\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_chucksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=(users_waiting_to_be_added_in_this_batch.length + users_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"\r",
							"    let number_of_users_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_users_that_can_be_added_in_this_chunk =0;\r",
							"\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length > number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (users_waiting_to_be_removed_in_this_batch.length<=number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk-number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (users_waiting_to_be_added_in_this_batch.length<number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=users_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"\r",
							"    let number_of_users_removed = 0;\r",
							"    let number_of_users_added   = 0;\r",
							"\r",
							"    const Operations=new Array();\r",
							"    const users_removed_in_this_chunk = [];\r",
							"\r",
							"    while (number_of_users_removed < number_of_users_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        users_removed_in_this_chunk.push(users_waiting_to_be_removed_in_this_batch.shift());\r",
							"        number_of_users_removed++;\r",
							"    };\r",
							"\r",
							"    if (users_removed_in_this_chunk.length>0)\r",
							"    {\r",
							"        const users_being_removed = users_removed_in_this_chunk.map( user => {return \"value eq \\\"\"+user+\"\\\"\"});\r",
							"        Operations.push({\r",
							"            \"op\": \"remove\",\r",
							"            \"path\": \"members[\".concat(users_being_removed.join(\" or \"),\"]\")\r",
							"        });\r",
							"    };\r",
							"\r",
							"/* the following will result in ALL members of the team (group) being removed if just 1 user needs to be removed!\r",
							"    if (users_removed_in_this_chunk.length>0)\r",
							"    {\r",
							"        Operations.push({\r",
							"            \"op\": \"remove\",\r",
							"            \"path\": \"members\",\r",
							"            \"value\": users_removed_in_this_chunk.map( user => {return {\"value\": user}})\r",
							"        });\r",
							"    };\r",
							"*/\r",
							"\r",
							"    pm.variables.set(\"users_removed_in_this_chunk\",users_removed_in_this_chunk);\r",
							"\r",
							"    const users_added_in_this_chunk = [];\r",
							"    while (number_of_users_added < number_of_users_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        users_added_in_this_chunk.push(users_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_users_added++;\r",
							"    };\r",
							"\r",
							"    if (users_added_in_this_chunk.length>0)\r",
							"    {\r",
							"        Operations.push({\r",
							"            \"op\": \"add\",\r",
							"            \"path\": \"members\",\r",
							"            \"value\": users_added_in_this_chunk.map( user => {return {\"value\": user}})\r",
							"        });\r",
							"    }\r",
							"\r",
							"    pm.variables.set(\"users_added_in_this_chunk\",users_added_in_this_chunk);\r",
							"\r",
							"    let team_request_body=\r",
							"    {\r",
							"        \"schemas\": [\r",
							"            \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\r",
							"        ],\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"\r",
							"\r",
							"    const number_of_users_actually_changed = number_of_users_that_can_be_added_in_this_chunk + number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    pm.variables.set(\"number_of_users_in_this_chunk\",number_of_users_actually_changed);\r",
							"    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"    pm.variables.set(\"team_uuid\",       this_team.id);\r",
							"    pm.variables.set(\"team_request_body\",JSON.stringify(team_request_body));\r",
							"\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName\r",
							"                +': Updating team: '+this_team.display+': adding '+number_of_users_that_can_be_added_in_this_chunk\r",
							"                +' users, removing '+number_of_users_that_can_be_removed_in_this_chunk\r",
							"                +' users');\r",
							"\r",
							"}  // end if errors\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE team membership\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"let   source_user   = pm.variables.get(\"source_user\");\r",
							"let   target_user   = pm.variables.get(\"target_user\");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        const currentteam = pm.variables.get(\"currentteam\");\r",
							"        const readbody            = JSON.parse(pm.response.text());\r",
							"        if (!readbody.members)  { readbody.members=[] };\r",
							"        if (!readbody.roles)    { readbody.roles=[] };\r",
							"        const actual_user_count   = readbody.members.length;\r",
							"        const actual_role_count   = readbody.roles.length;\r",
							"        const previouserrors      = pm.variables.get(\"ContinuousErrors\");  // errors holds the number of previous errors before this sucessful event. We need to know this so not to adjust the chunk size.\r",
							"                                                            // adjusting the chunk size after a previous error could be because the previous error was resolved by a repeated call. \r",
							"                                                            // and that repeated call could had taken a fraction of the normal processing time because it had already partly processed it beforehand.\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"                \r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in team');\r",
							"        \r",
							"\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        const this_team_index = array_of_teams.findIndex(team => team.id === currentteam)\r",
							"        const this_team      = array_of_teams[this_team_index];\r",
							"        \r",
							"        const number_of_user_changes_in_the_last_update=pm.variables.get(\"number_of_users_in_this_chunk\");\r",
							"        let team_updated_correctly = true;\r",
							"        if (number_of_user_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const users_per_second = Math.round((number_of_user_changes_in_the_last_update/(pm.response.responseTime/1000))*10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+users_per_second+' users/second');\r",
							"\r",
							"            const users_that_should_had_been_added =pm.variables.get(\"users_added_in_this_chunk\");\r",
							"            users_that_should_had_been_added.forEach( (addeduser) =>\r",
							"            {   \r",
							"                if ( !readbody.members.find(element => element.value === addeduser) )\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+addeduser+' was not found in the team, but was expected to be present');\r",
							"                    team_updated_correctly = false;\r",
							"                }; // end if \r",
							"            }); // end function\r",
							"            const users_that_should_had_been_removed =pm.variables.get(\"users_removed_in_this_chunk\");\r",
							"            users_that_should_had_been_removed.forEach( (removeduser) =>\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === removeduser) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+removeduser+' should had been removed, but was not');\r",
							"                    team_updated_correctly = false;\r",
							"                }; // end if \r",
							"            });  // end function\r",
							"        };\r",
							"        \r",
							"        const users_waiting_to_be_added_in_this_batch  =this_team.users_waiting_to_be_added_in_this_batch;\r",
							"        const users_waiting_to_be_removed_in_this_batch=this_team.users_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"        if( (users_waiting_to_be_added_in_this_batch.length\r",
							"            +users_waiting_to_be_removed_in_this_batch.length >0 ) )\r",
							"        {\r",
							"\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.display+' users: '+actual_user_count+' (yet to add: '+users_waiting_to_be_added_in_this_batch.length+' & remove: '+users_waiting_to_be_removed_in_this_batch.length+')');\r",
							"\r",
							"            // need to test if chucksize is too large, if so we need to reduce it\r",
							"\r",
							"            if (number_of_user_changes_in_the_last_update>0) \r",
							"            {\r",
							"                // then our last update was for adding or removing users, so we need to change the chunk size accordingly\r",
							"                // however, there is a condition where we are removing users to allow updates to roles to be made, before we then start adding users in.\r",
							"                // it means that a chunk update may not have been 'full' of users, this in turn means the last update could had been very quick and we need to\r",
							"                // only adjust the chunk size when the last update was 'full'.\r",
							"\r",
							"                const max_users_in_single_PUT_request = 32767;\r",
							"                if (actual_user_count>=max_users_in_single_PUT_request)\r",
							"                {\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }\r",
							"                else if ( (number_of_user_changes_in_the_last_update === this_team.users_chunk_size) && (previouserrors ===0 ) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.users_chunk_size;\r",
							"                    if (pm.response.responseTime>270000)\r",
							"                    {\r",
							"                        z= Math.round(newchuncksize * 0.6);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime>210000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.8);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 2);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<120000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 1.75);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 2 mins. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.users_chunk_size=newchuncksize;\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                };\r",
							"            }\r",
							"        }\r",
							"        else // the current team has been processed\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.display+' update complete it has '+actual_user_count+' users and is a member of '+actual_role_count+' roles');\r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        break;\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{team_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Groups/{{team_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Groups",
						"{{team_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "DELETE source user(s)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"DELETE user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([204,401,403,404,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 204:  //user not found, so as good as deleted!\r",
							"    case 404:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const UsersNeedToBeDeleted = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"        const user_being_deleted   = UsersNeedToBeDeleted.splice(0,1)[0];\r",
							"        pm.variables.set(\"UsersNeedToBeDeleted\",UsersNeedToBeDeleted)\r",
							"\r",
							"        if (UsersNeedToBeDeleted.length>0) \r",
							"        {\r",
							"            if (pm.variables.get(\"SAMLSSO\")==='email')\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': User '+user_being_deleted.userName+' deleted. User ID migration will only be complete once the target users email has been updated. '+UsersNeedToBeDeleted.length+' user(s) remain to be deleted.');\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': User '+user_being_deleted.userName+' deleted. User ID migration complete for this user. '+UsersNeedToBeDeleted.length+' users remain to be deleted.');\r",
							"            }\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            if (pm.variables.get(\"SAMLSSO\")==='email')\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': User '+user_being_deleted.userName+' deleted. User ID migration will only be complete once the target users email has been updated.');\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.info(pm.info.requestName+' '+pm.info.eventName+': User '+user_being_deleted.userName+' deleted. User ID migration complete for this user.');\r",
							"            }\r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        break;\r",
							"        \r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0);\r",
							"            const UsersNeedToBeDeleted = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            UsersNeedToBeDeleted.splice(0,1);\r",
							"            pm.variables.set(\"UsersNeedToBeDeleted\",UsersNeedToBeDeleted)\r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   };\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const UsersNeedToBeDeleted      = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"    const DeleteThisUser            = UsersNeedToBeDeleted.slice(0,1)[0];\r",
							"    pm.variables.set(\"user_uuid\",DeleteThisUser.id);\r",
							"    pm.variables.set(\"user_to_be_deleted\",DeleteThisUser.userName);\r",
							"    pm.variables.set(\"UsersNeedToBeDeleted\",UsersNeedToBeDeleted);\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Deleting source user: '+ DeleteThisUser.userName );\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "DELETE",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "DELETE source user(s) (Bulk)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"DELETE user (Bulk)\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const SAMLSSO = pm.variables.get(\"SAMLSSO\");\r",
							"\r",
							"        const UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"        const bulk_maxOperations         = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"        const OperationsInThisUpdate     = (UsersNeedToBeDeleted.length<bulk_maxOperations) ? UsersNeedToBeDeleted.length : bulk_maxOperations;\r",
							"        const UsersInThisBulkDelete      = UsersNeedToBeDeleted.splice(0,OperationsInThisUpdate);\r",
							"        const OperationsResponse = JSON.parse(pm.response.text()).Operations.map( (operationresponse, index) =>\r",
							"        { \r",
							"            let status=(operationresponse.status!==undefined) ? parseInt(operationresponse.status) : parseInt(operationresponse.response.status);\r",
							"            let detail=''\r",
							"            try {\r",
							"                detail=operationresponse.response.detail\r",
							"            }\r",
							"            catch(err)\r",
							"            {\r",
							"                detail='';\r",
							"            }\r",
							"            \r",
							"            return {\"id\": UsersInThisBulkDelete[index].id, \"userName\": UsersInThisBulkDelete[index].userName, \"status\": status, \"detail\": detail}\r",
							"        });\r",
							"\r",
							"        const total_users_not_processed  = UsersInThisBulkDelete.length - OperationsResponse.length;\r",
							"        const valid_response_status      = [204];\r",
							"        const users_successfully_deleted = OperationsResponse.filter( (response) => {return  valid_response_status.includes(response.status)} );\r",
							"        const users_not_deleted          = OperationsResponse.filter( (response) => {return !valid_response_status.includes(response.status)} );\r",
							"        const users_not_processed        = UsersInThisBulkDelete.slice( UsersInThisBulkDelete.length - total_users_not_processed )\r",
							"        \r",
							"\r",
							"        users_successfully_deleted.forEach( (user) =>\r",
							"        {\r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'email':\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' deleted.');\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' deleted. User ID migration complete for this user.');\r",
							"                }\r",
							"            }\r",
							"            \r",
							"        } );\r",
							"\r",
							"        users_not_deleted.forEach( (user) =>\r",
							"        {\r",
							"            if (user.status===403)\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' deletion will be re-attempted as it appears the session timed out mid-operation.');\r",
							"                UsersNeedToBeDeleted.push({\"id\": user.id, \"userName\": user.userName});\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' was not deleted. Response code: '+user.status+' '+user.detail);\r",
							"                pm.test('User deletion '+user.userName,function() { throw new Error( user.userName ) });\r",
							"            }\r",
							"        } );\r",
							"\r",
							"        users_not_processed.forEach( (user) =>\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' was not processed in the bulk request. User deletion will be re-attempted.');\r",
							"            UsersNeedToBeDeleted.push(user);\r",
							"        } );\r",
							"\r",
							"        if (UsersNeedToBeDeleted.length>0) \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+UsersNeedToBeDeleted.length+' users remain to be deleted.');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            switch (SAMLSSO)\r",
							"            {\r",
							"                case 'email':\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': All source users deleted. User ID migrations will only be complete once the target users have been updated with the correct e-mail.');\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': All source users deleted and all user ID migrations are now complete.');\r",
							"                }\r",
							"            }\r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        };\r",
							"        pm.variables.set(\"UsersNeedToBeDeleted\",UsersNeedToBeDeleted);\r",
							"        break;\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   };\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"    const bulk_maxOperations         = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"    const OperationsInThisUpdate     = (UsersNeedToBeDeleted.length<bulk_maxOperations) ? UsersNeedToBeDeleted.length : bulk_maxOperations;\r",
							"    const UsersInThisBulkDelete      = UsersNeedToBeDeleted.slice(0,OperationsInThisUpdate);\r",
							"    const Operations                 = UsersInThisBulkDelete.map( user => {\r",
							"        return {\r",
							"            \"method\": \"DELETE\",\r",
							"            \"path\": \"/Users/\".concat(user.id)\r",
							"        }   \r",
							"    });\r",
							"    \r",
							"    const bulk_request=\r",
							"    {\r",
							"        \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:BulkRequest\"],\r",
							"        \"failOnErrors\":1,\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Bulk deleting '+OperationsInThisUpdate+' source users' );\r",
							"    pm.variables.set(\"bulk_request_body\",JSON.stringify(bulk_request));\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "id",
						"value": "I049477V3",
						"type": "text",
						"disabled": true
					},
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Authorization",
						"value": "Bearer ",
						"type": "text",
						"disabled": true
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{bulk_request_body}}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Bulk",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Bulk"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE target user with correct email",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const TargetUsersNeedUpdating       = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"    const UpdateThisUser                = TargetUsersNeedUpdating.slice(0,1)[0];\r",
							"    pm.variables.set(\"target_user_uuid\",UpdateThisUser.id);\r",
							"    pm.variables.set(\"user_to_be_updated\",UpdateThisUser.userName);\r",
							"    pm.variables.set(\"TargetUsersNeedUpdating\",TargetUsersNeedUpdating);\r",
							"\r",
							"\r",
							"    \r",
							"    const Operations=new Array();\r",
							"\r",
							"\r",
							"    switch (pm.variables.get(\"SAMLSSO\"))\r",
							"    {\r",
							"        case 'userid':\r",
							"        {\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"emails\",\r",
							"                \"value\": [ {\"value\":UpdateThisUser.email,\"type\":\"work\",\"primary\":true}]\r",
							"            });\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Updating target user e-mail: '+ UpdateThisUser.userName +' with '+UpdateThisUser.email);\r",
							"            break;\r",
							"        }\r",
							"        \r",
							"        case 'email':\r",
							"        case 'default':\r",
							"        {\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"emails\",\r",
							"                \"value\": [ {\"value\":UpdateThisUser.email,\"type\":\"work\",\"primary\":true}]\r",
							"            });\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                \"value\": UpdateThisUser.email\r",
							"            });\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Updating target user e-mail: '+ UpdateThisUser.userName +' with '+UpdateThisUser.email);\r",
							"            break;\r",
							"        }\r",
							"\r",
							"        case 'custom':\r",
							"        {\r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"emails\",\r",
							"                \"value\": [ {\"value\":UpdateThisUser.email,\"type\":\"work\",\"primary\":true}]\r",
							"            });\r",
							"            \r",
							"            Operations.push({\r",
							"                \"op\": \"replace\",\r",
							"                \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                \"value\": UpdateThisUser.idpUserId // this will fail because we don't store the idpUserId in this object, because this workflow isn't applicable for 'custom' option, but left here in case it was ever needed.\r",
							"            });\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Updating target user e-mail: '+ UpdateThisUser.userName +' with '+UpdateThisUser.email);\r",
							"            break;\r",
							"        }\r",
							"\r",
							"        default: \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': SAML SSO Exception. Target user '+UpdateThisUser.userName );\r",
							"            break;\r",
							"        }\r",
							"    }; // end switch on SAML SSO\r",
							"\r",
							"\r",
							"    const target_user_patch_request=\r",
							"    {\r",
							"        \"schemas\": [\r",
							"            \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\r",
							"        ],\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"\r",
							"\r",
							"    pm.variables.set(\"user_request_body\",JSON.stringify(target_user_patch_request));\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE target user with correct e-mail\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"        const user_being_updated   = TargetUsersNeedUpdating.splice(0,1)[0];\r",
							"        pm.variables.set(\"TargetUsersNeedUpdating\",TargetUsersNeedUpdating)\r",
							"        const updated_user = JSON.parse(pm.response.text());\r",
							"        const user_email_was_updated\t=(updated_user.emails[0].value===user_being_updated.email);\r",
							"        const user_idpUserId_was_updated=(updated_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId===user_being_updated.email);\r",
							"        \r",
							"        if (user_email_was_updated && user_idpUserId_was_updated) // assumes SAML SSO is mapped on email or using default, as we are checking idpUserId which isn't necessary for others\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': User '+updated_user.userName+' updated with e-mail '+updated_user.emails[0].value+' which completes this user ID migration.');\r",
							"            pm.execution.setNextRequest();\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': User '+updated_user.userName+' e-mail was not updated as expected with '+user_being_updated.email+'. It means this user will not be able to login. The target user definition shows an unchanged e-mail: '+ pm.response.text())\r",
							"        }\r",
							"\r",
							"        if (TargetUsersNeedUpdating.length>0) \r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': '+TargetUsersNeedUpdating.length+' user(s) remain to be updated.');\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            pm.execution.setNextRequest(NextPostmanRequest());\r",
							"        }\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default:// response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors updating user '+source_userid+'. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            const TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"            TargetUsersNeedUpdating.splice(0,1);\r",
							"            pm.variables.set(\"TargetUsersNeedUpdating\",TargetUsersNeedUpdating)\r",
							"            pm.execution.setNextRequest(NextPostmanRequest ());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected updating user '+source_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error updating user '+source_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"   }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{target_user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{target_user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE target user(s) with correct email (Bulk)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE target user e-mail (Bulk)\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const TargetUsersNeedUpdating       = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"        const bulk_maxOperations         = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"        const OperationsInThisUpdate     = (TargetUsersNeedUpdating.length<bulk_maxOperations) ? TargetUsersNeedUpdating.length : bulk_maxOperations;\r",
							"        const UsersInThisBulkUpdate      = TargetUsersNeedUpdating.splice(0,OperationsInThisUpdate);\r",
							"        const OperationsResponse = JSON.parse(pm.response.text()).Operations.map( (operationresponse, index) =>\r",
							"        { \r",
							"            let status=(operationresponse.status!==undefined) ? parseInt(operationresponse.status) : parseInt(operationresponse.response.status);\r",
							"            let detail=''\r",
							"            try {\r",
							"                detail=operationresponse.response.detail\r",
							"            }\r",
							"            catch(err)\r",
							"            {\r",
							"                detail='';\r",
							"            }\r",
							"            \r",
							"            return {\"id\": UsersInThisBulkUpdate[index].id, \"userName\": UsersInThisBulkUpdate[index].userName, \"email\": UsersInThisBulkUpdate[index].email, \"status\": status, \"detail\": detail}\r",
							"        });\r",
							"\r",
							"        const total_users_not_processed  = UsersInThisBulkUpdate.length - OperationsResponse.length;\r",
							"        const valid_response_status      = [200];\r",
							"        const users_successfully_updated = OperationsResponse.filter( (response) => {return  valid_response_status.includes(response.status)} );\r",
							"        const users_not_updated          = OperationsResponse.filter( (response) => {return !valid_response_status.includes(response.status)} );\r",
							"        const users_not_processed        = UsersInThisBulkUpdate.slice( UsersInThisBulkUpdate.length - total_users_not_processed )\r",
							"        \r",
							"\r",
							"        users_successfully_updated.forEach( (user) =>\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' e-mail updated. User ID migration complete for this user.');\r",
							"        } );\r",
							"\r",
							"        users_not_updated.forEach( (user) =>\r",
							"        {\r",
							"            if (user.status===403)\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' e-mail update will be re-attempted as it appears the session timed out mid-operation.');\r",
							"                TargetUsersNeedUpdating.push(user);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' e-mail was not updated. Please update the user e-mail so the user can login. Response code: '+user.status+' '+user.detail);\r",
							"                pm.test('Update e-mail '+user.userName,function() { throw new Error( user.userName ) });\r",
							"            }\r",
							"        } );\r",
							"\r",
							"        users_not_processed.forEach( (user) =>\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': User '+user.userName+' was not processed in the bulk request. User e-mail update will be re-attempted.');\r",
							"            TargetUsersNeedUpdating.push( user );\r",
							"        } );\r",
							"\r",
							"        if (TargetUsersNeedUpdating.length>0) \r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+TargetUsersNeedUpdating.length+' users remain to be updated with their correct e-mail.');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': All source users updated and all user ID migrations are now complete.');\r",
							"        };\r",
							"        pm.variables.set(\"TargetUsersNeedUpdating\",TargetUsersNeedUpdating);\r",
							"        pm.execution.setNextRequest( NextPostmanRequest() );\r",
							"        break;\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   };\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const TargetUsersNeedUpdating    = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"    const bulk_maxOperations         = parseInt(pm.collectionVariables.get(\"bulk_maxOperations\"));\r",
							"    const OperationsInThisUpdate     = (TargetUsersNeedUpdating.length<bulk_maxOperations) ? TargetUsersNeedUpdating.length : bulk_maxOperations;\r",
							"    const UsersInThisBulkUpdate      = TargetUsersNeedUpdating.slice(0,OperationsInThisUpdate);\r",
							"    const SAMLSSO                    = pm.variables.get(\"SAMLSSO\")\r",
							"\r",
							"    const Operations                = UsersInThisBulkUpdate.map( user =>\r",
							"    {\r",
							"        switch (SAMLSSO)\r",
							"        {\r",
							"            case 'userid':\r",
							"            {\r",
							"                return {\r",
							"                            \"method\": \"PATCH\",\r",
							"                            \"path\": \"/Users/\".concat(user.id),\r",
							"                            \"data\": {\r",
							"                                \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                \"Operations\":\r",
							"                                [\r",
							"                                    {\r",
							"                                        \"op\": \"replace\",\r",
							"                                        \"path\": \"emails\",\r",
							"                                        \"value\": [ {\"value\":user.email,\"type\":\"work\",\"primary\":true}]\r",
							"                                    }\r",
							"                                ]\r",
							"                        }\r",
							"                }\r",
							"            }\r",
							"            \r",
							"            case 'email':\r",
							"            case 'default':\r",
							"            {\r",
							"                return {\r",
							"                            \"method\": \"PATCH\",\r",
							"                            \"path\": \"/Users/\".concat(user.id),\r",
							"                            \"data\": {\r",
							"                                \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                \"Operations\":\r",
							"                                [\r",
							"                                    {\r",
							"                                        \"op\": \"replace\",\r",
							"                                        \"path\": \"emails\",\r",
							"                                        \"value\": [ {\"value\":user.email,\"type\":\"work\",\"primary\":true}]\r",
							"                                    },\r",
							"                                    {\r",
							"                                        \"op\": \"replace\",\r",
							"                                        \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                        \"value\": user.email\r",
							"                                    }\r",
							"                                ]\r",
							"                        }\r",
							"                }\r",
							"            }\r",
							"\r",
							"            case 'custom':\r",
							"            {\r",
							"                return {\r",
							"                            \"method\": \"PATCH\",\r",
							"                            \"path\": \"/Users/\".concat(user.id),\r",
							"                            \"data\": {\r",
							"                                \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],\r",
							"                                \"Operations\":\r",
							"                                [\r",
							"                                    {\r",
							"                                        \"op\": \"replace\",\r",
							"                                        \"path\": \"emails\",\r",
							"                                        \"value\": [ {\"value\":user.email,\"type\":\"work\",\"primary\":true}]\r",
							"                                    },\r",
							"                                    {\r",
							"                                        \"op\": \"replace\",\r",
							"                                        \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"                                        \"value\": user.idpUserId\r",
							"\r",
							"                                        // this will actually fail because the user object will not have an attribute called idpUserId.\r",
							"                                    }\r",
							"                                ]\r",
							"                        }\r",
							"                }\r",
							"            }\r",
							"\r",
							"        }; // end switch on SAML SSO\r",
							"    } )// end map \r",
							"\r",
							"    \r",
							"    const bulk_request=\r",
							"    {\r",
							"        \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:BulkRequest\"],\r",
							"        \"failOnErrors\":1,\r",
							"        \"Operations\": Operations\r",
							"    };\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName+': Bulk updating '+OperationsInThisUpdate+' target user(s) with correct e-mail' );\r",
							"    pm.variables.set(\"bulk_request_body\",JSON.stringify(bulk_request));\r",
							"}"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "id",
						"value": "I049477V3",
						"type": "text",
						"disabled": true
					},
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Authorization",
						"value": "Bearer ",
						"type": "text",
						"disabled": true
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{bulk_request_body}}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Bulk",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Bulk"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ repository content",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ repository content\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end case response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"    \r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        // load the response into a variable 'resources'\r",
							"        const resources = JSON.parse(pm.response.text())[\"d\"].results.map(myfunction_simplify_resource);\r",
							"\r",
							"        function myfunction_simplify_resource(resourcevalue)\r",
							"        {\r",
							"            let corrected_resource_path=JSON.parse(resourcevalue.ancestorPath).reduce ( myfunction_return_path_as_string, \"\")\r",
							"            function myfunction_return_path_as_string( path, folder)\r",
							"            {\r",
							"                // the array of path is not consistent, for example some folders would store a folder as: \"[\"Public\",\"SAP_Content\",\"Story\"]\"\r",
							"                // when another may store it as \"[\"/\",\"\",\"Public\",\"SAP_Content\",\"Story\"]\"\r",
							"                // So we must normalise the path and we can do that by creating a simple string for the path, rather than an array\r",
							"                if (( folder==='\"') || (folder==='/') || (folder===''))\r",
							"                {\r",
							"                    // if an array value is a \" or / or just null, then we should ignore it.\r",
							"                    return path;\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // otherwise, we need to add the folder to the path\r",
							"                    return path+\"/\"+folder;\r",
							"                }\r",
							"            }; // end myfunction_return_path_as_string\r",
							"\r",
							"            let stored_in_private_folder = false;\r",
							"            let top_parent_folder        = corrected_resource_path.split(\"/\")[1];\r",
							"            let username_extracted_from_folder_name = '';\r",
							"            \r",
							"            switch (top_parent_folder)\r",
							"            {\r",
							"                case 'Users':\r",
							"                {\r",
							"                    // grab the 2nd level foldername and extract the first word before the space character \r",
							"                    //  for example '/Users/ADMIN Private' we extract ADMIN\r",
							"                    try {\r",
							"                        username_extracted_from_folder_name = corrected_resource_path.split(\"/\")[2].split(\" \")[0]; \r",
							"                        stored_in_private_folder            = true;\r",
							"                    }\r",
							"                    catch {\r",
							"                        stored_in_private_folder            = false;\r",
							"                    }\r",
							"                    break;\r",
							"                }\r",
							"                \r",
							"                case 'WORKSPACE':\r",
							"                {\r",
							"                    // grab the 3rd level foldername and extract the first word before the space character\r",
							"                    //  for example '/WORKSPACE/Users/ADMIN Private' we extract ADMIN\r",
							"                    try {\r",
							"                        username_extracted_from_folder_name = corrected_resource_path.split(\"/\")[3].split(\" \")[0];\r",
							"                        stored_in_private_folder            = true;\r",
							"                    }\r",
							"                    catch {\r",
							"                        stored_in_private_folder            = false;\r",
							"                    }\r",
							"                    break;\r",
							"                }\r",
							"\r",
							"                case 'Input Forms':\r",
							"                {\r",
							"                    // Input Forms need to be ignored\r",
							"                    stored_in_private_folder=false;\r",
							"                    break;\r",
							"                }\r",
							"                default:\r",
							"                {\r",
							"                    // The top level folder is something else\r",
							"                    //  for example it might be something like:\r",
							"                    //          /Public/SAP_Content/SAP_FI_Consolidation\r",
							"                    //      or  /ADMIN Private\r",
							"                    let top_parent_folder_has_space_character =  /\\s/g.test(top_parent_folder);\r",
							"\r",
							"                    if (top_parent_folder_has_space_character)\r",
							"                    {\r",
							"                        // then the folder is a user folder, like /ADMIN Private\r",
							"                        // so we grab the username from the first word before the space\r",
							"                        username_extracted_from_folder_name=top_parent_folder.split(\" \")[0];\r",
							"                        stored_in_private_folder = true;\r",
							"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        // its something like:  \\Public   or   \\SYSTEM\r",
							"                        stored_in_private_folder = false;\r",
							"                    }\r",
							"                    break;\r",
							"\r",
							"                }\r",
							"            };\r",
							"\r",
							"            return {\r",
							"                stored_in_private_folder: stored_in_private_folder,\r",
							"                username_of_private_folder: username_extracted_from_folder_name,\r",
							"                resource_created_by: resourcevalue.createdBy\r",
							"            }\r",
							"        }\r",
							"\r",
							"\r",
							"        const users_with_private_content_array=resources.reduce( function_unique_private_users, []);\r",
							"        \r",
							"        function function_unique_private_users(unique_users, this_resource)\r",
							"        {\r",
							"\r",
							"            const user_already_in_array=unique_users.find( user=> (user===this_resource.username_of_private_folder) ) ;\r",
							"            if (user_already_in_array)\r",
							"            {\r",
							"                return unique_users\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                if (this_resource.stored_in_private_folder===true)\r",
							"                {\r",
							"                    return [...unique_users,this_resource.username_of_private_folder] \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return unique_users\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"\r",
							"        const users_with_public_content_array=resources.reduce( function_unique_public_users, []);\r",
							"        \r",
							"        function function_unique_public_users(unique_users, this_resource)\r",
							"        {\r",
							"\r",
							"            const user_already_in_array=unique_users.find( user=> (user===this_resource.resource_created_by) ) ;\r",
							"            if (user_already_in_array)\r",
							"            {\r",
							"                return unique_users\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                if ( (this_resource.stored_in_private_folder===false) && (this_resource.resource_created_by!=''))\r",
							"                {\r",
							"                    return [...unique_users,this_resource.resource_created_by] \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return unique_users\r",
							"                }\r",
							"            }\r",
							"        };\r",
							"\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Repository content read: '+users_with_private_content_array.length+' users with private content, and '+users_with_public_content_array.length+' users with public content');\r",
							"\r",
							"        pm.variables.set(\"users_with_private_content_array\",users_with_private_content_array);\r",
							"        pm.variables.set(\"users_with_public_content_array\",users_with_public_content_array);\r",
							"        pm.variables.set(\"repository_content_read\",true);\r",
							"        pm.execution.setNextRequest(\"READ source user and validate for new user\");\r",
							"\r",
							"        break;\r",
							"    }\r",
							"    default:  // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"    };\r",
							"\r",
							"} // end switch response code"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading repository content');"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "$format",
						"value": "json",
						"type": "text"
					},
					{
						"key": "resourceTypes",
						"value": "STORY",
						"type": "text",
						"disabled": true
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/Repositories?$format=json&$select=createdBy,ancestorPath",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"Repositories"
					],
					"query": [
						{
							"key": "$format",
							"value": "json"
						},
						{
							"key": "$select",
							"value": "createdBy,ancestorPath"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "READ user for repair",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ user for repair\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"function email_is_valid( user )\r",
							"{\r",
							"    switch (pm.variables.get(\"SAMLSSO\"))\r",
							"    {\r",
							"        case 'custom':\r",
							"        {\r",
							"            return (  (user.emails[0].value===user.emails[0].value.toLowerCase())  );\r",
							"            break;\r",
							"        }\r",
							"        case 'email':\r",
							"        case 'default':\r",
							"        {\r",
							"            // we test if the email is in lowercase or not, and we also test if the email stored in idpUserId matches the email address as seen in the user interface.\r",
							"            return (  (user.emails[0].value===user.emails[0].value.toLowerCase()) \r",
							"                    &&(user.emails[0].value===user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId)\r",
							"            )\r",
							"            break;\r",
							"        }\r",
							"        default:\r",
							"        {\r",
							"            return true;\r",
							"            break;\r",
							"        }\r",
							"    }\r",
							"}\r",
							"\r",
							"function UserIsValid( user )\r",
							"{\r",
							"    return (email_is_valid( user ));\r",
							"}\r",
							"\r",
							"function UserIsSystemOwner( user )\r",
							"{\r",
							"    return ((user.roles) && (user.roles[0]==='PROFILE:sap.epm:System_Owner'));\r",
							"}\r",
							"\r",
							"function ConsoleErrorLogUser( user, error )\r",
							"{\r",
							"    console.error(\"User is inconsistent: uuid(id):\"+user.id+\" id(userName):\"+user.userName+\" email(emails.value):\"+user.emails[0].value+\" SAMLmapping(idpUserId):\"+user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId+\" Error:\"+error)\r",
							"}\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end case response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // we will NOT reset the errors to 0 as it could result in an endless loop.\r",
							"        const repair_user=(JSON.parse(pm.response.text()));\r",
							"\r",
							"        if (!UserIsValid(repair_user))\r",
							"        {\r",
							"            ConsoleErrorLogUser( repair_user, \"e-mail inconsistent, or not lowercase\");\r",
							"            if (UserIsSystemOwner( repair_user ))\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+\": Can not repair System Owner as the System Owner can not be updated via the API: \"+repair_user.userName);\r",
							"                pm.execution.setNextRequest(pm.variables.get(\"recovery_from_repair\"));\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+\": Attempting to repair user \"+repair_user.userName);\r",
							"                pm.variables.set(\"repair_user\",repair_user);\r",
							"                pm.execution.setNextRequest(\"REPAIR user\");\r",
							"            }\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': User definition seems consistent: '+repair_user.userName);\r",
							"            pm.execution.setNextRequest(pm.variables.get(\"recovery_from_repair\"));\r",
							"        }\r",
							"        \r",
							"        \r",
							"        break;\r",
							"    }\r",
							"    default:  // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"    };\r",
							"\r",
							"} // end switch response code"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const repair_user = pm.variables.get(\"repair_user\");\r",
							"pm.variables.set(\"user_uuid\",repair_user.id);\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading user for repair: '+ repair_user.userName );"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "REPAIR user",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"REPAIR user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end case response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const repair_user=pm.variables.get(\"repair_user\");\r",
							"        console.info(pm.info.requestName+' '+pm.info.eventName+': User repaired successfully: '+repair_user.userName);\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery_from_repair\"));\r",
							"        break;\r",
							"    }\r",
							"    default:  // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"    };\r",
							"\r",
							"} // end switch response code"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const repair_user=pm.variables.get(\"repair_user\");\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Repairing user: '+ repair_user.userName );\r",
							"\r",
							"const target_user_request= {};\r",
							"const elements_to_remove = ['meta','id'];\r",
							"\r",
							"Object.keys(repair_user).forEach( key => {  if (!elements_to_remove.includes(key)) { target_user_request[key]=repair_user[key] }} );\r",
							"\r",
							"\r",
							"switch (pm.variables.get(\"SAMLSSO\"))\r",
							"{\r",
							"    case 'default':\r",
							"    {\r",
							"        // the next line is important. There's a problem (which may now have been resolved) with the default authentication and creating users with a mixed CaSe of email.\r",
							"        // the problem is/was, that if the idpUserId that contains the email along with the emails[0].value must always be the same for this authenticaiton method (and also when SAML SSO is mapped on email)\r",
							"        // however, when the user is created via the SCIM API, the idpUserId email case is lowered. It means the email is the same email, but in a different case to emails[0].value\r",
							"        // this difference means that PATCH requests will fail. Its gets complicated, because a user could be created manually and then this issue doesn't occur. However, we then have another problem,\r",
							"        // which is the case of these users could also be mixed.  So we shall prevent these problems, by setting the email into lowercase. We shall use the emails[0].value value as the 'source' email as this\r",
							"        // is the one seen, and editable, within the user interface\r",
							"        target_user_request.emails[0].value=target_user_request.emails[0].value.toLowerCase();\r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_user_request.emails[0].value;\r",
							"\r",
							"        // the next line should remain commented-out, because this will copy the idpUserId to the email which is typically not desired\r",
							"        // target_user_request.emails[0].value=target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId;\r",
							"        break;\r",
							"    }\r",
							"    case 'email':\r",
							"    {\r",
							"        //target_user_request.emails[0].value=target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId;\r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_user_request.emails[0].value;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        // nothing to do\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'userid':\r",
							"    {\r",
							"        // SAP Analytics Cloud is using a custom IdP Mapping on userid property. \r",
							"        target_user_request[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId=target_userid;\r",
							"        break;\r",
							"    }\r",
							"\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"\r",
							"pm.variables.set(\"user_request_body\",JSON.stringify(target_user_request));\r",
							"pm.variables.set(\"user_uuid\",repair_user.id);\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "RESTORE source user",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"const source_userid   = pm.iterationData.get(\"file_source_userid\").toUpperCase();\r",
							"const   source_user   = pm.variables.get(\"source_user\");\r",
							"const   email = source_user.emails[0].value;\r",
							"const idpuserid=source_user[\"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters\"].idpUserId\r",
							"const Operations=new Array();\r",
							"\r",
							"\r",
							"switch (pm.variables.get(\"SAMLSSO\"))\r",
							"{\r",
							"    case 'userid':\r",
							"    {\r",
							"        Operations.push({\r",
							"            \"op\": \"replace\",\r",
							"            \"path\": \"emails\",\r",
							"            \"value\": [ {\"value\":email,\"type\":\"work\",\"primary\":true}]\r",
							"        });\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Updating source user '+source_userid+' with original email: '+ email );\r",
							"        break;\r",
							"    }\r",
							"    \r",
							"    case 'email':\r",
							"    case 'default':\r",
							"    {\r",
							"        Operations.push({\r",
							"            \"op\": \"replace\",\r",
							"            \"path\": \"emails\",\r",
							"            \"value\": [ {\"value\":email,\"type\":\"work\",\"primary\":true}]\r",
							"        });\r",
							"        Operations.push({\r",
							"            \"op\": \"replace\",\r",
							"            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"            \"value\": email\r",
							"        });\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Updating source user '+source_userid+' with original email: '+ email );\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    case 'custom':\r",
							"    {\r",
							"        Operations.push({\r",
							"            \"op\": \"replace\",\r",
							"            \"path\": \"emails\",\r",
							"            \"value\": [ {\"value\":email,\"type\":\"work\",\"primary\":true}]\r",
							"        });\r",
							"        \r",
							"        Operations.push({\r",
							"            \"op\": \"replace\",\r",
							"            \"path\": \"urn:sap:params:scim:schemas:extension:sac:2.0:user-custom-parameters:idpUserId\",\r",
							"            \"value\": idpuserid\r",
							"        });\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Updating source user '+source_userid+' with original email: '+ email +', and original idpUserId: '+idpuserid);\r",
							"        break;\r",
							"    }\r",
							"\r",
							"    default: \r",
							"    {\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAML SSO Exception. Source user '+source_userid );\r",
							"        break;\r",
							"    }\r",
							"}; // end switch on SAML SSO\r",
							"\r",
							"\r",
							"let source_user_patch_request=\r",
							"{\r",
							"    \"schemas\": [\r",
							"        \"urn:ietf:params:scim:api:messages:2.0:PatchOp\"\r",
							"    ],\r",
							"    \"Operations\": Operations\r",
							"};\r",
							"\r",
							"\r",
							"pm.variables.set(\"source_user_uuid\",source_user.id);\r",
							"pm.variables.set(\"user_request_body\",JSON.stringify(source_user_patch_request));\r",
							""
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"RESTORE source user\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"function NextPostmanRequest ()\r",
							"{\r",
							"    // to determine what request should be next.\r",
							"    // we will need to update teams membership, if there are any teams to be updated.\r",
							"    // we will also need to delete any users, again if there are any users that need to be deleted.\r",
							"    let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"    if (!array_of_teams) {array_of_teams=[]};\r",
							"\r",
							"    const total_users_in_teams_yet_to_be_updated = array_of_teams.reduce( (total, team) =>\r",
							"    {\r",
							"        return total\r",
							"        + (team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"        + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length  )\r",
							"    } ,0);\r",
							"\r",
							"    const update_based_on_entries_read_so_far = ( ( (pm.info.iteration+1) % parseInt(pm.collectionVariables.get(\"update_teams_and_delete_users_every_x_users\")) ) === 0 );\r",
							"    const update_because_on_last_file_entry   = ( pm.info.iteration===(pm.info.iterationCount-1) );\r",
							"\r",
							"    if ( update_because_on_last_file_entry || update_based_on_entries_read_so_far )\r",
							"    {\r",
							"        if (total_users_in_teams_yet_to_be_updated > 0)\r",
							"        {\r",
							"            const first_team_to_read_index = array_of_teams.findIndex(team => (\r",
							"                    ((team.users_waiting_to_be_added_in_this_batch   ===undefined ? 0 : team.users_waiting_to_be_added_in_this_batch.length  )\r",
							"                + (team.users_waiting_to_be_removed_in_this_batch ===undefined ? 0 : team.users_waiting_to_be_removed_in_this_batch.length)) >0) );\r",
							"            pm.variables.set(\"currentteam\", array_of_teams[first_team_to_read_index].id);\r",
							"            return \"UPDATE team membership\"\r",
							"        }\r",
							"        else  // there are no teams to be updated, but there could be users to delete or users that need their e-mail updated\r",
							"        {\r",
							"            let  UsersNeedToBeDeleted       = pm.variables.get(\"UsersNeedToBeDeleted\");\r",
							"            if (!UsersNeedToBeDeleted)      {UsersNeedToBeDeleted = []};\r",
							"            const use_scim_bulk_operations=( pm.collectionVariables.get(\"use_scim_bulk_operations\") === 'true');\r",
							"\r",
							"            if (UsersNeedToBeDeleted.length>0)\r",
							"            {\r",
							"                if (use_scim_bulk_operations)\r",
							"                {\r",
							"                    return \"DELETE source user(s) (Bulk)\";\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return \"DELETE source user(s)\";\r",
							"                }\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                let TargetUsersNeedUpdating = pm.variables.get(\"TargetUsersNeedUpdating\");\r",
							"                if (!TargetUsersNeedUpdating) {TargetUsersNeedUpdating =[] };\r",
							"                if (TargetUsersNeedUpdating.length>0)\r",
							"                {\r",
							"                    if (use_scim_bulk_operations)\r",
							"                    {\r",
							"                        return \"UPDATE target user(s) with correct email (Bulk)\"\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        return \"UPDATE target user with correct email\";\r",
							"                    }\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    return null;\r",
							"                }\r",
							"    \r",
							"            }\r",
							"        } //end if total_users_in_teams_yet_to_be_updated >0\r",
							"    }\r",
							"    else // there's nothing to do, safe to move to the next user in the data file\r",
							"    {\r",
							"        return null;\r",
							"    }\r",
							"}; // end of NextPostmanRequest function\r",
							"\r",
							"const source_userid = pm.iterationData.get(\"file_source_userid\").toUpperCase();\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"\r",
							"    case 200:\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        let   source_user   = pm.variables.get(\"source_user\");\r",
							"\t\tconsole.info(pm.info.requestName+' '+pm.info.eventName+': User '+source_user.userName+' restored with original values. This user should be able to login as before. The user id migration for this user has been aborted. Please retry.');\r",
							"\t\tpm.execution.setNextRequest(NextPostmanRequest ());\r",
							"\t\t\r",
							"        break;\r",
							"    }\r",
							"    default:// response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors updating user '+source_userid+'. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(NextPostmanRequest ());\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected updating user '+source_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error updating user '+source_userid+'. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"        break;\r",
							"   }\r",
							"};"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PATCH",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{{user_request_body}}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Users/{{source_user_uuid}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Users",
						"{{source_user_uuid}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 200:\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.execution.setNextRequest();                                   // we will now get a new x-csrf-token\r",
							"        break;\r",
							"    }\r",
							"    case 401:\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"    default:\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }; //end if \r",
							"        break;\r",
							"    }\r",
							"}; // switch case\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}/oauth/token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}"
					],
					"path": [
						"oauth",
						"token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "FETCH csrf token",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new x-csrf-token');"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Fetch x-csrf-token\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    } // end if response is 401\r",
							"    case 200:\r",
							"    {\r",
							"        // if NeedGetToBeAuthorised is true, then we're here because we need to issue a GET call to authorise the session (otherwise we could get a 403).\r",
							"        // so we don't need to do post-processing of this call, just continue to the next\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetched a new x-csrf-token');\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request, leaving 'errors' unchanged will ensure that the call is repeated\r",
							"        pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"    } // end switch pm.response.code\r",
							"};\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "fetch",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/csrf",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"csrf"
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "initial_users_chunk_size_for_team_updates",
			"value": "500",
			"type": "string"
		},
		{
			"key": "update_teams_and_delete_users_every_x_users",
			"value": "100",
			"type": "string"
		},
		{
			"key": "use_scim_bulk_operations",
			"value": "true",
			"type": "string"
		},
		{
			"key": "bulk_maxOperations",
			"value": "30",
			"type": "string"
		},
		{
			"key": "resume_migration_if_target_user_already_exists_and_created_within_last_x_hours",
			"value": "24",
			"type": "string"
		},
		{
			"key": "delete_source_user_even_when_personal_content_exists",
			"value": "false",
			"type": "string"
		},
		{
			"key": "delete_source_user_even_when_public_content_exists",
			"value": "false",
			"type": "string"
		}
	]
}