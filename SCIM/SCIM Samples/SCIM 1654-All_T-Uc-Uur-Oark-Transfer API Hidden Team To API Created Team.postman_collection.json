{
	"info": {
		"_postman_id": "07bd492a-8068-4732-bf9a-442f4e0c7434",
		"name": "SCIM 1654-All_T-Uc-Uur-Oark-Transfer API Hidden Team To API Created Team",
		"description": "# Provided 'as is'\n\nThese samples are being provided \"AS IS\", without any warranty obligations whatsoever on the part of SAP. SAP makes no express or implied warranties of any type, including, but not limited to, implied warranties of merchantability and of fitness for a particular purpose.\n\n# User guide\n\n[https://d.dam.sap.com/a/kv3cXuB](https://d.dam.sap.com/a/kv3cXuB)\n\n# Blog (& for other related content)\n\n[https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352](https://community.sap.com/t5/technology-blogs-by-sap/sap-analytics-cloud-user-and-team-provisioning-scim-api-best-practices-and/ba-p/13509352)\n\n# Questions\n\nPlease create a new question [https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions](https://community.sap.com/t5/forums/postpage/choose-node/true/board-id/technology-questions) (rather than a comment to the blog post since blog posts do not support threads)\n\n# About\n\nScript version 0.9\n\nSample scripts created by Matthew Shaw, SAP. [https://community.sap.com/t5/user/viewprofilepage/user-id/70553](https://community.sap.com/t5/user/viewprofilepage/user-id/70553)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "31429660",
		"_collection_link": "https://sap-se.postman.co/workspace/SAP-Analytics-Cloud~8ac5e5ee-c61c-4eda-99cb-9af804973bee/collection/31429660-07bd492a-8068-4732-bf9a-442f4e0c7434?action=share&source=collection_link&creator=31429660"
	},
	"item": [
		{
			"name": "READ source team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200)  )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        \r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Team not found. We have to abort this file entry and move to the next\r",
							"        const source_team=pm.iterationData.get(\"file_source_team\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Source Team is unreadable via the API endpoint /api/v1/scim/Groups/'+ source_team);\r",
							"        pm.execution.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request\r",
							"        pm.execution.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        const source_team=pm.iterationData.get(\"file_source_team\");\r",
							"        const target_team=pm.iterationData.get(\"file_target_team\");\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (   schemas.includes('urn:ietf:params:scim:schemas:core:2.0:Group') );\r",
							"\r",
							"\r",
							"        if (source_team === target_team)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': A team with the same name as the Source team is already readable via the API endpoint /api/v1/scim/Groups/'+ source_team+'. Assuming this team (with '+readbody.members.length+' users) is not the team that should be transferred to '+target_team);\r",
							"            wrong_source_team_was_created = readbody.meta.created;  \r",
							"            pm.variables.set(\"wrong_source_team_was_created\",wrong_source_team_was_created);\r",
							"            pm.execution.setNextRequest();\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Confirmed that the source team is unreadable via the API endpoint /api/v1/scim/Groups/'+ source_team);\r",
							"            pm.variables.set(\"wrong_source_team_was_created\",null); \r",
							"            pm.execution.setNextRequest();\r",
							"        };  // end team index\r",
							"\r",
							"\r",
							"    }  // end response is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading team '+pm.iterationData.get(\"file_source_team\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_source_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_source_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ target team",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,404]);\r",
							"        pm.expect(validschema);\r",
							"    }\r",
							");\r",
							"\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 404)\r",
							"    {\r",
							"        // Team not found, we need to create it.\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false); // we have now authorised this session, albeit with a 404 not found!\r",
							"        const target_team_in_current_file_row=pm.iterationData.get(\"file_target_team\");\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Team not found. Creating new team '+ target_team_in_current_file_row);\r",
							"        pm.variables.set(\"targetteam\",target_team_in_current_file_row);\r",
							"        const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"        if (SAC_platform==='NEO')\r",
							"        {\r",
							"            // NEO does not supoort the scim2 API, only the scim2 API allows teams to be created without a team folder\r",
							"            pm.execution.setNextRequest('CREATE team');\r",
							"        }\r",
							"        else  // we are on a Cloud Foundary Platform\r",
							"        {\r",
							"            pm.execution.setNextRequest('CREATE team without folder');\r",
							"        };\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"        // errors must not be reset as the next call to UPDATE team must re-submit the request\r",
							"        pm.execution.setNextRequest();\r",
							"    }\r",
							"else if ( (pm.response.code === 200) && (!NeedGetToBeAuthorised) )\r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        const readbody    = JSON.parse(pm.response.text());\r",
							"        const schemas     = readbody.schemas;\r",
							"        var validschema = (   schemas.includes('urn:ietf:params:scim:schemas:core:2.0:Group') );\r",
							"\r",
							"        pm.test(\"Valid SCIM schema\", function ()\r",
							"            {\r",
							"                pm.expect(validschema);\r",
							"            }\r",
							"        );\r",
							"\r",
							"        let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"        if (!array_of_teams) { array_of_teams=[] };\r",
							"        const target_team_in_current_file_row= pm.iterationData.get(\"file_target_team\");\r",
							"        let target_team_index = array_of_teams.findIndex(element => element.teamname === target_team_in_current_file_row);\r",
							"        let target_team;\r",
							"\r",
							"        if (target_team_index<0) \r",
							"            {\r",
							"                target_team = {\"teamname\"  : target_team_in_current_file_row,\r",
							"                            \"displayname\": readbody.displayName,\r",
							"                            \"meta\"       : readbody.meta,\r",
							"                            \"members\"    : readbody.members,\r",
							"                            \"roles\"      : readbody.roles,\r",
							"                            \"users_chunk_size\" : 0,\r",
							"                            \"roles_chunk_size\" : 0,\r",
							"                            \"arrayofusers_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofusers_waiting_to_be_removed_in_this_batch\":[],\r",
							"                            \"arrayofroles_waiting_to_be_added_in_this_batch\"  :[],\r",
							"                            \"arrayofroles_waiting_to_be_removed_in_this_batch\":[] };\r",
							"                target_team.users_chunk_size= Math.round(((42-(42-21.85714))*210) - (readbody.members.length * 0.14));\r",
							"                if (target_team.users_chunk_size<1) { target_team.users_chunk_size = 1};\r",
							"                if ( readbody.members.length > 0)\r",
							"                {\r",
							"                    target_team.roles_chunk_size= Math.round((210/(readbody.members.length*46/210))*10);  //210 is the target duration in seconds, 46 is the average rate of users/role/second\r",
							"                    if (target_team.roles_chunk_size<1) { target_team.roles_chunk_size = 1};\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    target_team.roles_chunk_size= 50;\r",
							"                };\r",
							"                array_of_teams.push(target_team);\r",
							"                target_team_index=array_of_teams.findIndex(element => element.teamname === target_team.teamname);\r",
							"            }\r",
							"        else\r",
							"            {\r",
							"                target_team = array_of_teams[target_team_index];\r",
							"            }\r",
							"        ;  // end team index\r",
							"\r",
							"        \r",
							"        array_of_teams[target_team_index]=target_team;\r",
							"        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"        pm.variables.set(\"StartTeamIndex\",1);\r",
							"        pm.variables.set(\"ReadTeamsIndexSize\",parseInt(pm.collectionVariables.get(\"initial_read_index_size\")));\r",
							"\r",
							"\r",
							"    }  // end response is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }\r",
							";"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading target team '+pm.iterationData.get(\"file_target_team\"));\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_target_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_target_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "READ teams page by page",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"READ teams page by page\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401]);\r",
							"    }\r",
							");\r",
							"const NeedGetToBeAuthorised = pm.variables.get(\"NeedGetToBeAuthorised\");\r",
							"const source_team           = pm.iterationData.get(\"file_source_team\");\r",
							"const target_team_name      = pm.iterationData.get(\"file_target_team\");\r",
							"const Users_Action          = pm.iterationData.get(\"file_user_action\");\r",
							"const Roles_Action          = pm.iterationData.get(\"file_role_action\");\r",
							"let   wrong_source_team_was_created = pm.variables.get(\"wrong_source_team_was_created\");\r",
							"if (!wrong_source_team_was_created) { wrong_source_team_was_created=null};\r",
							"let array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"if (!array_of_teams) { array_of_teams=[] };\r",
							"const this_team_index = array_of_teams.findIndex(element => element.teamname === target_team_name);\r",
							"const this_team = array_of_teams[this_team_index];\r",
							"\r",
							"let users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"let users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"let roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"let roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"if (!roles_waiting_to_be_added_in_this_batch)   { roles_waiting_to_be_added_in_this_batch = [] };\r",
							"if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"\r",
							"\r",
							"if ( (pm.response.code === 200) || (pm.response.code === 404) )\r",
							"{\r",
							"        // we are authorised and the csrf-tokem is also valid. We need to set the x-csrf-token so the call is quicker.\r",
							"        // Performing a 'fetch' of the x-csrf-token makes the call longer and its unnecessary. Setting the x-csrf-token to a valid value\r",
							"        // will speed things up by a small fraction (which can be a lot of time if making thousands of calls!)\r",
							"        const csrftoken=pm.environment.get(\"x-csrf-token\");\r",
							"        if (csrftoken===\"fetch\")\r",
							"        {\r",
							"            pm.environment.set(\"x-csrf-token\",pm.response.headers.get(\"x-csrf-token\"));\r",
							"        }\r",
							"};\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); // once a new accesstoken is successfully returned this call will be repeated thanks to the 'recovery' variable set in the pre-request\r",
							"        break;\r",
							"    }\r",
							"    case 200:\r",
							"    {\r",
							"\r",
							"        if (NeedGetToBeAuthorised)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': New session now authorised');\r",
							"            pm.variables.set(\"NeedGetToBeAuthorised\",false);\r",
							"            // errors must not be reset as the next call to UPDATE team must re-submit the request\r",
							"            pm.execution.setNextRequest();\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"            pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"            const readbody                          = JSON.parse(pm.response.text());\r",
							"            const StartTeamIndex                    = pm.variables.get(\"StartTeamIndex\");\r",
							"            let   ReadTeamsIndexSize                = pm.variables.get(\"ReadTeamsIndexSize\");          \r",
							"            const total_teams_in_this_SAC_service   = readbody.totalResults;\r",
							"            const teams_this_page                   = readbody.Resources.length;\r",
							"            let   max_index_size                    = pm.variables.get(\"MaxIndexSize\");\r",
							"\r",
							"            \r",
							"        \r",
							"            if (readbody.itemsPerPage<ReadTeamsIndexSize)\r",
							"            {  // we requested more teams than SAC provided and so SAC is limiting the number of teams we can read per page\r",
							"            // confusingly readbody.itemsPerPage will be 200, even when the number of teams returned could be just 5 (i.e. less than 200).\r",
							"            // this means this code will only be executed if we ask for more teams than we got back (even when the number of teams is less than what we asked for)\r",
							"                max_index_size = readbody.itemsPerPage;\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Maximum index size set by SAP Anlaytics Cloud is '+max_index_size);\r",
							"                pm.variables.set(\"MaxIndexSize\",       max_index_size);\r",
							"                pm.variables.set(\"ReadTeamsIndexSize\", max_index_size); \r",
							"            };\r",
							"            const max_team_index_this_page = StartTeamIndex + teams_this_page -1;\r",
							"            const teams_per_second = Math.round((teams_this_page/(pm.response.responseTime/1000))*10)/10;\r",
							"            \r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Analysing '+teams_this_page+' teams '+StartTeamIndex+' to '+max_team_index_this_page+' (throughput: '+teams_per_second+' teams/sec) of '+total_teams_in_this_SAC_service);\r",
							"        \r",
							"            // search the array of resource (teams) and find the team we are looking for.\r",
							"            // we need to ensure that the meta.created date doesn't match the date of the team we can read (this can happen if the source and target share the same name!)\r",
							"            const found_team=readbody.Resources.find( team => ((team.id===source_team) && (team.meta.created !== wrong_source_team_was_created)));\r",
							"            //console.log(pm.info.requestName+' '+pm.info.eventName+': found_team',found_team);\r",
							"            \r",
							"            if (max_team_index_this_page>=total_teams_in_this_SAC_service)\r",
							"            {\r",
							"                // we have read all the teams so we can now go to update the team, there's no need to change the index size\r",
							"            }\r",
							"            else if ( (teams_this_page === ReadTeamsIndexSize) && (!max_index_size))\r",
							"            {\r",
							"                // there could be a need to change the index size but we only do this if the number of teams returned last was the maximum number we asked for\r",
							"                // and when the max_index_size has not yet been set. max_index_size is set when we find out that SAC is limited the number of teams per page\r",
							"                let newindexsize = ReadTeamsIndexSize;\r",
							"                if (pm.response.responseTime>270000)\r",
							"                {\r",
							"                    newindexsize= Math.round(newindexsize * 0.6);\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was over 4 mins 30 sec. Reducing index size to keep under 5 mins. Index size now '+newindexsize);\r",
							"                }\r",
							"                else if (pm.response.responseTime>210000)\r",
							"                {\r",
							"                    newindexsize= Math.round(newindexsize * 0.8);\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was over 3 mins 30 sec. Reducing index size to keep under 5 mins. Index size now '+newindexsize);\r",
							"                }\r",
							"                else if (pm.response.responseTime<60000)\r",
							"                {\r",
							"                    newindexsize= Math.round(newindexsize * 2);\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was under 1 min. Increasing index size to improve throughput. Index size now '+newindexsize);\r",
							"                }\r",
							"                else if (pm.response.responseTime<120000)\r",
							"                {\r",
							"                    newindexsize= Math.round(newindexsize * 1.75);\r",
							"                    console.log(pm.info.requestName+' '+pm.info.eventName+': Last read was under 2 mins. Increasing index size to improve throughput. Index size now '+newindexsize);            \r",
							"                };\r",
							"                if (newindexsize<1) {newindexsize=1};\r",
							"                pm.variables.set(\"ReadTeamsIndexSize\", newindexsize);   // set the new index size\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // nothing to do.\r",
							"            };\r",
							"\r",
							"            // Define the next set of teams to query, it will start with the team after the last one\r",
							"            const Next_Read_Start_At = max_team_index_this_page + 1\r",
							"            pm.variables.set(\"StartTeamIndex\",Next_Read_Start_At);\r",
							"\r",
							"            // and the size of the last page may not be the full Index Size, it may well be shorter\r",
							"            ReadTeamsIndexSize=pm.variables.get(\"ReadTeamsIndexSize\");\r",
							"            if ((Next_Read_Start_At+ReadTeamsIndexSize-1) > total_teams_in_this_SAC_service)\r",
							"            {\r",
							"                pm.variables.set(\"ReadTeamsIndexSize\",(total_teams_in_this_SAC_service-Next_Read_Start_At+1))\r",
							"            };\r",
							"                \r",
							"            const read_all_teams_in_SAC = ( Next_Read_Start_At>total_teams_in_this_SAC_service);\r",
							"                    \r",
							"            if (read_all_teams_in_SAC || found_team)  // update required of the team. A team update may still be needed.\r",
							"            {\r",
							"\r",
							"                if (found_team)\r",
							"                {\r",
							"                    let total_users_in_source_team=found_team.members.length;\r",
							"                    let total_roles_in_source_team=0;\r",
							"                    if (found_team.roles===null) {total_roles_in_source_team=0} else {total_roles_in_source_team=found_team.roles.length};\r",
							"                    // we need the code just above because if the roles are empty then the array is 'null', unlike if the members are empty when its an empty array\r",
							"                    // this also means we need to test total_roles_in_source_team>0 if we perform any methods on found_team.roles\r",
							"\r",
							"                    if (Users_Action==='keep' && Roles_Action==='keep')\r",
							"                    {\r",
							"                        console.info(pm.info.requestName+' '+pm.info.eventName+': Hidden team found! This team, which can\\'t be read via the /api/v1/scim/Groups/'+source_team+' endpoint has '+total_users_in_source_team+' users and is a member of '+total_roles_in_source_team+' roles. Users and Roles action is \\'keep\\' so no action will be performed');\r",
							"                        pm.execution.setNextRequest(null);\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        console.info(pm.info.requestName+' '+pm.info.eventName+': Hidden team found! This team, which can\\'t be read via the /api/v1/scim/Groups/'+source_team+' endpoint, has '+total_users_in_source_team+' users and is a member of '+total_roles_in_source_team+' roles. Transferring to '+target_team_name+', which can be read via the API');\r",
							"                    \r",
							"                        const target_team_index=array_of_teams.findIndex(element => element.teamname === target_team_name);\r",
							"                        const target_team = array_of_teams[target_team_index];\r",
							"\r",
							"                        switch (Users_Action)\r",
							"                        {\r",
							"                        case \"add\":\r",
							"                            {\r",
							"                            const users_to_add_from_source_team = found_team.members;\r",
							"                            users_to_add_from_source_team.forEach( myfunction_add_user_from_source_team_to_batch );\r",
							"\r",
							"                            function myfunction_add_user_from_source_team_to_batch(value)\r",
							"                            {\r",
							"\r",
							"                                if ( users_waiting_to_be_added_in_this_batch.find(element => element.value === value.value) )  // user_found_in_add_list\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already added to add list. No action needed (UA1)');\r",
							"                                }\r",
							"                                else if (users_waiting_to_be_removed_in_this_batch.find(element => element.value === value.value))  // user_found_in_remove_list\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+' User '+value.value+' found in remove list, will remove user from remove list (UA2)');\r",
							"                                    const userindex = users_waiting_to_be_removed_in_this_batch.findIndex(element => element.value === value.value);\r",
							"                                    users_waiting_to_be_removed_in_this_batch.splice(userindex,1)\r",
							"                                }\r",
							"                                else if ( target_team.members.find(element => element.value === value.value) )  // user_found_in_existing_team_membership\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already a member of team. Taking no action (UA3)');\r",
							"                                }\r",
							"                                else\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' being added to team ' +target_team.teamname+ ' (UA4)');\r",
							"                                    users_waiting_to_be_added_in_this_batch.push(value);\r",
							"                                }; // end if \r",
							"                            };  // end function\r",
							"                            break;\r",
							"                            }  // end case add\r",
							"                        \r",
							"                        case \"replace\":\r",
							"                            {\r",
							"                            //\r",
							"                            users_waiting_to_be_added_in_this_batch = [];\r",
							"                            users_waiting_to_be_removed_in_this_batch = [];\r",
							"                            const users_to_set_for_this_source_team = found_team.members;\r",
							"\r",
							"                            users_to_set_for_this_source_team.forEach( myfunction_add_users_from_set_list_to_add_list );\r",
							"                            function myfunction_add_users_from_set_list_to_add_list(value)\r",
							"                            {  \r",
							"                                if ( target_team.members.find(element => element.value === value.value) ) \r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (US1/US3)');\r",
							"                                }\r",
							"                                else // user not found\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' needs to be added to team (US2)');\r",
							"                                    users_waiting_to_be_added_in_this_batch.push(value);\r",
							"                                }\r",
							"                                ; // end if \r",
							"                            };  // end function\r",
							"\r",
							"                            target_team.members.forEach( myfunction_add_users_from_existing_team_to_remove_list );\r",
							"                            function myfunction_add_users_from_existing_team_to_remove_list(value)\r",
							"                            {   \r",
							"                                if ( users_to_set_for_this_source_team.find(element => element.value === value.value) ) \r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (US3/US1)');\r",
							"                                }\r",
							"                                else // user not found\r",
							"                                {\r",
							"                                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' removed (US4)');\r",
							"                                    users_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                                }\r",
							"                                ; // end if \r",
							"                            };  // end function\r",
							"                            break;\r",
							"                            }  // end case replace\r",
							"                        case \"keep\":\r",
							"                            {\r",
							"                                // nothing to do\r",
							"                                break;\r",
							"                            }\r",
							"                        default:\r",
							"                            {\r",
							"                            console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid user action (supported actions: add, replace, keep): '+ Users_Action);\r",
							"                            } // end default case for users action\r",
							"                        }; // end switch Users Action\r",
							"\r",
							"                        switch (Roles_Action) \r",
							"                        {\r",
							"                        case \"add\":\r",
							"                            {\r",
							"                            if (total_roles_in_source_team>0)\r",
							"                            {\r",
							"                                const roles_to_add_for_this_source_team = found_team.roles;\r",
							"\r",
							"                                roles_to_add_for_this_source_team.forEach( myfunction_add_role_from_source_team_to_batch );\r",
							"\r",
							"                                function myfunction_add_role_from_source_team_to_batch(value)\r",
							"                                {\r",
							"                                    if ( roles_waiting_to_be_added_in_this_batch.find(element => element === value) )  // role_found_in_add_list\r",
							"                                    {\r",
							"                                    //    console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value+' already added to add list. No action needed (RA1)')\r",
							"                                    }\r",
							"                                    else if (roles_waiting_to_be_removed_in_this_batch.find(element => element === value))  // role_found_in_remove_list\r",
							"                                    {\r",
							"                                    //    console.log(pm.info.requestName+' '+pm.info.eventName+' Role '+value+' found in remove list, will remove role from remove list (RA2)');\r",
							"                                        const roleindex = roles_waiting_to_be_removed_in_this_batch.findIndex(element => element === value);\r",
							"                                        roles_waiting_to_be_removed_in_this_batch.splice(roleindex,1)\r",
							"                                    }\r",
							"                                    else if ( target_team.roles.find(element => element === value) )  // team_found_as_existing_role_membership\r",
							"                                    {\r",
							"                                    //    console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of role '+value+'. Taking no action (RA3)');\r",
							"                                    }\r",
							"                                    else\r",
							"                                    {\r",
							"                                    //    console.log(pm.info.requestName+' '+pm.info.eventName+': Team ' +target_team.teamname+ ' being added to Role '+value+' (RA4)');\r",
							"                                        roles_waiting_to_be_added_in_this_batch.push(value);\r",
							"                                    }; // end if \r",
							"                                };  // end function\r",
							"                            }; // end if (total_roles_in_source_team>0)\r",
							"                            break;\r",
							"                            } // end case add\r",
							"                        case \"replace\":\r",
							"                            {\r",
							"                            roles_waiting_to_be_added_in_this_batch = [];\r",
							"                            roles_waiting_to_be_removed_in_this_batch = [];\r",
							"                            if (total_roles_in_source_team>0)\r",
							"                            {\r",
							"                                const roles_to_set_for_this_source_team = found_team.roles;\r",
							"\r",
							"                                roles_to_set_for_this_source_team.forEach( myfunction_add_roles_from_set_list_to_add_list );\r",
							"                                function myfunction_add_roles_from_set_list_to_add_list(value)\r",
							"                                {  \r",
							"                                    if ( target_team.roles.find(element => element === value) ) // \r",
							"                                    {\r",
							"                                        //console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of role '+value.value+' (RS1/RS3)');\r",
							"                                    }\r",
							"                                    else // role not found\r",
							"                                    {\r",
							"                                        //console.log(pm.info.requestName+' '+pm.info.eventName+': Team needs to be added as a member of role '+value.value+' (RS2)');\r",
							"                                        roles_waiting_to_be_added_in_this_batch.push(value);\r",
							"                                    }\r",
							"                                    ; // end if \r",
							"                                };  // end function\r",
							"\r",
							"                                target_team.roles.forEach( myfunction_add_roles_from_existing_team_to_remove_list );\r",
							"                                function myfunction_add_roles_from_existing_team_to_remove_list(value)\r",
							"                                {   \r",
							"                                    if ( roles_to_set_for_this_source_team.find(element => element === value) ) // \r",
							"                                    {\r",
							"                                        //console.log(pm.info.requestName+' '+pm.info.eventName+': Team already a member of Role '+value+' (RS3/RS1)');\r",
							"                                    }\r",
							"                                    else // role not found\r",
							"                                    {\r",
							"                                        //console.log(pm.info.requestName+' '+pm.info.eventName+': Role '+value+' removed (RS4)');\r",
							"                                        roles_waiting_to_be_removed_in_this_batch.push(value);\r",
							"                                    }\r",
							"                                    ; // end if \r",
							"                                };  // end function\r",
							"                            }; //end if (total_roles_in_source_team>0)\r",
							"                            break;\r",
							"                            }  // end case replace\r",
							"                        case \"keep\":\r",
							"                            {\r",
							"                            // nothing to do\r",
							"                            break;\r",
							"                            }\r",
							"                        default:\r",
							"                            {\r",
							"                                console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid role action (supported actions: add, replace, keep): '+ Roles_Action);\r",
							"                            } // end if action\r",
							"                        }; // end swtich Roles_Action\r",
							"\r",
							"\r",
							"                        target_team.arrayofusers_waiting_to_be_added_in_this_batch  =users_waiting_to_be_added_in_this_batch;\r",
							"                        target_team.arrayofusers_waiting_to_be_removed_in_this_batch=users_waiting_to_be_removed_in_this_batch;\r",
							"                        target_team.arrayofroles_waiting_to_be_added_in_this_batch  =roles_waiting_to_be_added_in_this_batch;\r",
							"                        target_team.arrayofroles_waiting_to_be_removed_in_this_batch=roles_waiting_to_be_removed_in_this_batch;\r",
							"                        array_of_teams[target_team_index]=target_team;\r",
							"\r",
							"                        // we can avoid any need to update the target team if no changes are necessary\r",
							"                        const target_team_needs_updating = ( (target_team.arrayofusers_waiting_to_be_added_in_this_batch.length  > 0)\r",
							"                                            || (target_team.arrayofusers_waiting_to_be_removed_in_this_batch.length >0)\r",
							"                                            || (target_team.arrayofroles_waiting_to_be_added_in_this_batch.length   >0)\r",
							"                                            || (target_team.arrayofroles_waiting_to_be_removed_in_this_batch.length >0) );\r",
							"                        if (!target_team_needs_updating) \r",
							"                        {\r",
							"                            array_of_teams.splice(target_team_index,1)\r",
							"                        };\r",
							"                        \r",
							"\r",
							"                        pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"\r",
							"                        if ( target_team_needs_updating )\r",
							"                        {\r",
							"                            pm.variables.set(\"targetteam\", target_team.teamname);\r",
							"                            pm.execution.setNextRequest();\r",
							"                        }\r",
							"                        else \r",
							"                        {\r",
							"                            console.log(pm.info.requestName+' '+pm.info.eventName+': Team already correct. No update needed');\r",
							"                            pm.execution.setNextRequest(null);\r",
							"                        };  // end if target_team_needs_updating\r",
							"                    };  // end the else of if (Users_Action==='keep' && Roles_Action==='keep')\r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    // source team not the same as target team\r",
							"                    if ( (source_team === target_team_name) && (wrong_source_team_was_created) )\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+': There is no other team with the name \\''+source_team+'\\' found that can\\'t already be read via the API. In other words, this team can already be read by the v1 API. Though this team may or may not have the same content namespace as defined in your SAP Analytics Cloud Service. Use sample script 1653 to copy this team to another team if you\\'d like to copy users and/or roles from this team to another. Copying the team to a new team will ensure the new team has the same content namespace as the one defined in your SAP Analytics Cloud Service. The data file for this sample script can also be used by sample script 1653.');\r",
							"                    }\r",
							"                    else\r",
							"                    {\r",
							"                        console.error(pm.info.requestName+' '+pm.info.eventName+': There is no team with the name \\''+source_team+'\\' found. This sample script searched all teams including teams that cannot be read directly by the v1 API. Please check the team name is correct by using the user interface of SAP Analytics Cloud. You may find sample script 1601 and 2601 helpful. Sample 1601 uses the v1 api to list teams, sample 2601 uses the v2 api to list all the teams. For more clarification please refer to the user guide for these samples.');\r",
							"                    };\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }; // end if not found_team\r",
							"\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                pm.execution.setNextRequest(pm.info.requestName);  // we call this same request again because we've not yet found the team\r",
							"            }; // end if updated needed\r",
							"\r",
							"        };\r",
							"        break;\r",
							"        }   // end case response is 200\r",
							"    default:\r",
							"    {\r",
							"        // response code is unexpected\r",
							"        // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"        break;\r",
							"    }\r",
							"}; // end swtich pm.response.code\r",
							""
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const StartTeamIndex=pm.variables.get(\"StartTeamIndex\");\r",
							"const ReadTeamsIndexSize=pm.variables.get(\"ReadTeamsIndexSize\");\r",
							"const MaxTeamIndex=( StartTeamIndex + ReadTeamsIndexSize -1);\r",
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Reading teams '+StartTeamIndex+' to '+MaxTeamIndex);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/?startIndex={{StartTeamIndex}}&count={{ReadTeamsIndexSize}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						""
					],
					"query": [
						{
							"key": "startIndex",
							"value": "{{StartTeamIndex}}"
						},
						{
							"key": "count",
							"value": "{{ReadTeamsIndexSize}}"
						}
					]
				}
			},
			"response": []
		},
		{
			"name": "UPDATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"const targetteam = pm.variables.get(\"targetteam\");\r",
							"//console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+targetteam);\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"if (errors>0)\r",
							"{\r",
							"    console.warn(pm.info.requestName+' '+pm.info.eventName+': Re-submitting request following previous error');\r",
							"}\r",
							"else\r",
							"{\r",
							"    const array_of_teams  = pm.variables.get(\"array_of_teams\");\r",
							"    const this_team_index = array_of_teams.findIndex(element => element.teamname === targetteam);\r",
							"    const this_team       = array_of_teams[this_team_index];\r",
							"\r",
							"    const displayname     = this_team.displayname;\r",
							"    const meta            = this_team.meta;\r",
							"    const users_chucksize       = this_team.users_chunk_size;\r",
							"    const roles_chunksize       = this_team.roles_chunk_size;\r",
							"    const users_in_this_team_update =this_team.members;\r",
							"    const roles_in_this_team_update =this_team.roles;\r",
							"    const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"    const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"    const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"    const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"\r",
							"    if (!users_waiting_to_be_added_in_this_batch)   { users_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!users_waiting_to_be_removed_in_this_batch) { users_waiting_to_be_removed_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_added_in_this_batch)   { roles_waiting_to_be_added_in_this_batch = [] };\r",
							"    if (!roles_waiting_to_be_removed_in_this_batch) { roles_waiting_to_be_removed_in_this_batch = [] };\r",
							"    \r",
							"\r",
							"    let number_of_users_that_can_change_in_this_chunk;\r",
							"    if ((users_waiting_to_be_added_in_this_batch.length+users_waiting_to_be_removed_in_this_batch.length)>=users_chucksize)\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=users_chucksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_change_in_this_chunk=(users_waiting_to_be_added_in_this_batch.length + users_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"\r",
							"    let number_of_users_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_users_that_can_be_added_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_removed_in_this_chunk =0;\r",
							"    let number_of_roles_that_can_be_added_in_this_chunk =0;\r",
							"\r",
							"    if (users_waiting_to_be_removed_in_this_batch.length > number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (users_waiting_to_be_removed_in_this_batch.length<=number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=users_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk-number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (users_waiting_to_be_added_in_this_batch.length<number_of_users_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=users_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_users_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_users_that_can_be_added_in_this_chunk=number_of_users_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    const max_users_in_single_PUT_request = 32767;\r",
							"    if ((this_team.members.length+number_of_users_that_can_be_added_in_this_chunk) > max_users_in_single_PUT_request)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Maximum number of users reached '+max_users_in_single_PUT_request);\r",
							"        number_of_users_that_can_be_added_in_this_chunk=max_users_in_single_PUT_request-this_team.members.length\r",
							"    }\r",
							"\r",
							"\r",
							"\r",
							"    let number_of_roles_that_can_change_in_this_chunk;\r",
							"    if ((roles_waiting_to_be_added_in_this_batch.length+roles_waiting_to_be_removed_in_this_batch.length)>=roles_chunksize)\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=roles_chunksize\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_change_in_this_chunk=(roles_waiting_to_be_added_in_this_batch.length + roles_waiting_to_be_removed_in_this_batch.length);\r",
							"    };\r",
							"    \r",
							"    if (roles_waiting_to_be_removed_in_this_batch.length > number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_removed_in_this_batch.length<=number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=roles_waiting_to_be_removed_in_this_batch.length;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk-number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    }\r",
							"    else if (roles_waiting_to_be_added_in_this_batch.length<number_of_roles_that_can_change_in_this_chunk)\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=roles_waiting_to_be_added_in_this_batch.length;\r",
							"    }\r",
							"    else\r",
							"    {\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=number_of_roles_that_can_change_in_this_chunk;\r",
							"    };\r",
							"\r",
							"    if (number_of_users_that_can_be_removed_in_this_chunk > 0)\r",
							"    {\r",
							"        // if we can remove users, then we should remove all users before adding or removing any roles\r",
							"        // we have disabled the ability for any roles to be added or removed under this condition\r",
							"        number_of_roles_that_can_be_added_in_this_chunk=0;\r",
							"        number_of_roles_that_can_be_removed_in_this_chunk=0;\r",
							"        // but if we have any roles to add or remove then we must also prevent any new user from being added in this chunk\r",
							"        // since it is possible users will be removed and added within the same chunk, hence...\r",
							"        if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"        {\r",
							"            // we have now disabled the ability for new users to be added when users can be removed AND when there are role changes\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"        }\r",
							"    }\r",
							"    else if ( (number_of_users_that_can_be_added_in_this_chunk > 0) && (number_of_roles_that_can_change_in_this_chunk > 0) )\r",
							"    {\r",
							"            // this is when there are users that can be added and there are changed needed to roles.\r",
							"            // in this condition we need to prevent new users from being added until all the role changes have been made.\r",
							"            number_of_users_that_can_be_added_in_this_chunk=0;\r",
							"    };\r",
							"\r",
							"    let number_of_users_removed = 0;\r",
							"    let number_of_users_added   = 0;\r",
							"\r",
							"    const users_removed_in_this_chunk = [];\r",
							"    while (number_of_users_removed < number_of_users_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_user=users_waiting_to_be_removed_in_this_batch.shift();\r",
							"        users_removed_in_this_chunk.push(removing_user);\r",
							"        \r",
							"        let removing_user_index = users_in_this_team_update.findIndex(element => element.value === removing_user.value);\r",
							"        users_in_this_team_update.splice(removing_user_index,1);\r",
							"        number_of_users_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofusers_removed_in_this_chunk\",users_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_users_added < number_of_users_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        users_in_this_team_update.push(users_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_users_added++;\r",
							"    };\r",
							"\r",
							"\r",
							"    let number_of_roles_removed = 0;\r",
							"    let number_of_roles_added   = 0;\r",
							"\r",
							"    const roles_removed_in_this_chunk = [];\r",
							"    while (number_of_roles_removed < number_of_roles_that_can_be_removed_in_this_chunk)\r",
							"    {\r",
							"        let removing_role=roles_waiting_to_be_removed_in_this_batch.shift();\r",
							"        roles_removed_in_this_chunk.push(removing_role);\r",
							"        \r",
							"        let removing_role_index = roles_in_this_team_update.findIndex(element => element === removing_role);\r",
							"        roles_in_this_team_update.splice(removing_role_index,1);\r",
							"        number_of_roles_removed++;\r",
							"    };\r",
							"    pm.variables.set(\"arrayofroles_removed_in_this_chunk\",roles_removed_in_this_chunk);\r",
							"\r",
							"    while (number_of_roles_added < number_of_roles_that_can_be_added_in_this_chunk)\r",
							"    {\r",
							"        roles_in_this_team_update.push(roles_waiting_to_be_added_in_this_batch.shift());\r",
							"        number_of_roles_added++;\r",
							"    };\r",
							"\r",
							"\r",
							"    const number_of_users_actually_changed = number_of_users_that_can_be_added_in_this_chunk + number_of_users_that_can_be_removed_in_this_chunk;\r",
							"    const number_of_roles_actually_changed = number_of_roles_that_can_be_added_in_this_chunk + number_of_roles_that_can_be_removed_in_this_chunk;\r",
							"    pm.variables.set(\"number_of_users_in_this_chunk\",number_of_users_actually_changed);\r",
							"    pm.variables.set(\"number_of_roles_in_this_chunk\",number_of_roles_actually_changed);\r",
							"    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"\r",
							"    pm.variables.set(\"displayname\",displayname);\r",
							"    pm.variables.set(\"meta\",   JSON.stringify(meta));\r",
							"    pm.variables.set(\"members\",JSON.stringify(users_in_this_team_update));\r",
							"    pm.variables.set(\"roles\",  JSON.stringify(roles_in_this_team_update));\r",
							"    pm.variables.set(\"expected_user_count\",users_in_this_team_update.length);\r",
							"    console.log(pm.info.requestName+' '+pm.info.eventName\r",
							"                +': Updating team: '+targetteam+': adding '+number_of_users_that_can_be_added_in_this_chunk\r",
							"                +' users, removing '+number_of_users_that_can_be_removed_in_this_chunk\r",
							"                +' users, adding '+number_of_roles_that_can_be_added_in_this_chunk\r",
							"                +' roles, removing '+number_of_roles_that_can_be_removed_in_this_chunk\r",
							"                +' roles');\r",
							"\r",
							"}  // end if errors"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"UPDATE team\", () => {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([200,401,403])\r",
							"});\r",
							"\r",
							"\r",
							"if (pm.response.code === 401)\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ teams page by page\");\r",
							"    } // end if response is 401\r",
							"else if (pm.response.code === 403)\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ teams page by page\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"    }  //end if response is 403\r",
							"else if (pm.response.code === 200)\r",
							"    {\r",
							"        const readbody            = JSON.parse(pm.response.text());\r",
							"        const expected_user_count = pm.variables.get(\"expected_user_count\");\r",
							"        const actual_user_count   = readbody.members.length;\r",
							"        const previouserrors=pm.variables.get(\"ContinuousErrors\");  // errors holds the number of previous errors before this sucessful event. We need to know this so not to adjust the chunk size.\r",
							"                                                            // adjusting the chunk size after a previous error could be because the previous error was resolved by a repeated call. \r",
							"                                                            // and that repeated call could had taken a fraction of the normal processing time because it had already partly processed it beforehand.\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        \r",
							"        if (expected_user_count === actual_user_count)\r",
							"        {\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in team as expected');\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': '+ actual_user_count+' users in the team, however '+ expected_user_count+' where expected');\r",
							"        };\r",
							"\r",
							"        const array_of_teams = pm.variables.get(\"array_of_teams\");\r",
							"\r",
							"        const this_team_index = array_of_teams.findIndex(element => element.teamname === pm.variables.get(\"targetteam\"));\r",
							"        const this_team = array_of_teams[this_team_index];\r",
							"        \r",
							"        const number_of_user_changes_in_the_last_update=pm.variables.get(\"number_of_users_in_this_chunk\");\r",
							"        if (number_of_user_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const users_per_second = Math.round((number_of_user_changes_in_the_last_update/(pm.response.responseTime/1000))*10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+users_per_second+' users/second');\r",
							"\r",
							"            const users_in_last_request= JSON.parse(pm.variables.get(\"members\"));\r",
							"            users_in_last_request.forEach( myfunction_find_missing_users );\r",
							"            function myfunction_find_missing_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' already member of team (S3/S1)');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' was not found in the team, but was expected to be present');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const users_that_should_had_been_removed =pm.variables.get(\"arrayofusers_removed_in_this_chunk\");\r",
							"            users_that_should_had_been_removed.forEach( myfunction_find_not_removed_users );\r",
							"            function myfunction_find_not_removed_users(value)\r",
							"            {   \r",
							"                if ( readbody.members.find(element => element.value === value.value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': User '+value.value+' should had been removed, but was not');\r",
							"                }\r",
							"                else // user not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"        \r",
							"        const number_of_roles_changes_in_the_last_update=pm.variables.get(\"number_of_roles_in_this_chunk\");\r",
							"        if (number_of_roles_changes_in_the_last_update>0)\r",
							"        {\r",
							"            const roles_per_second = Math.round((number_of_roles_changes_in_the_last_update/(pm.response.responseTime/1000))*100)/100;\r",
							"            const users_per_role_per_second = Math.round( ((this_team.members.length*number_of_roles_changes_in_the_last_update)/(pm.response.responseTime/1000)) *10)/10;\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Throughput: '+roles_per_second+' roles/second, '+users_per_role_per_second+' users/role/second');\r",
							"\r",
							"            const roles_in_last_request= JSON.parse(pm.variables.get(\"roles\"));\r",
							"            roles_in_last_request.forEach( myfunction_find_missing_roles );\r",
							"            function myfunction_find_missing_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    //console.log(pm.info.requestName+' '+pm.info.eventName+': Team, already a member of '+value+' role (R3/R1)');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Team not a member of role '+value+' but was expected to be');\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"            const roles_that_should_had_been_removed =pm.variables.get(\"arrayofroles_removed_in_this_chunk\");\r",
							"            roles_that_should_had_been_removed.forEach( myfunction_find_not_removed_roles );\r",
							"            function myfunction_find_not_removed_roles(value)\r",
							"            {   \r",
							"                if ( readbody.roles.find(element => element === value) ) // \r",
							"                {\r",
							"                    console.warn(pm.info.requestName+' '+pm.info.eventName+': Role '+value.value+' should no longer contain this team, but does');\r",
							"                }\r",
							"                else // role not found\r",
							"                {\r",
							"                    //nothing\r",
							"                }\r",
							"                ; // end if \r",
							"            };  // end function\r",
							"\r",
							"        };\r",
							"\r",
							"        const users_waiting_to_be_added_in_this_batch  =this_team.arrayofusers_waiting_to_be_added_in_this_batch;\r",
							"        const users_waiting_to_be_removed_in_this_batch=this_team.arrayofusers_waiting_to_be_removed_in_this_batch;\r",
							"        const roles_waiting_to_be_added_in_this_batch  =this_team.arrayofroles_waiting_to_be_added_in_this_batch;\r",
							"        const roles_waiting_to_be_removed_in_this_batch=this_team.arrayofroles_waiting_to_be_removed_in_this_batch;\r",
							"\r",
							"        if( (users_waiting_to_be_added_in_this_batch.length\r",
							"            +users_waiting_to_be_removed_in_this_batch.length\r",
							"            +roles_waiting_to_be_added_in_this_batch.length\r",
							"            +roles_waiting_to_be_removed_in_this_batch.length) >0 ) \r",
							"        {\r",
							"            this_team.members=readbody.members;  // we need to reload the members that are actually in the team into our members list so the current list is accurate\r",
							"            this_team.roles  =readbody.roles;\r",
							"\r",
							"            console.log(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' users: '+this_team.members.length+' (yet to add: '+users_waiting_to_be_added_in_this_batch.length+' & remove: '+users_waiting_to_be_removed_in_this_batch.length+') member of: '+this_team.roles.length+' roles (yet to be added to: '+roles_waiting_to_be_added_in_this_batch.length+' & removed from: '+roles_waiting_to_be_removed_in_this_batch.length+')');\r",
							"            // need to test if chucksize is too large, if so we need to reduce it\r",
							"\r",
							"            if (number_of_user_changes_in_the_last_update>0) \r",
							"            {\r",
							"                // then our last update was for adding or removing users, so we need to change the chunk size accordingly\r",
							"                // however, there is a condition where we are removing users to allow updates to roles to be made, before we then start adding users in.\r",
							"                // it means that a chunk update may not have been 'full' of users, this in turn means the last update could had been very quick and we need to\r",
							"                // only adjust the chunk size when the last update was 'full'.\r",
							"\r",
							"                const max_users_in_single_PUT_request = 32767;\r",
							"                if (readbody.members.length>=max_users_in_single_PUT_request)\r",
							"                {\r",
							"                    pm.execution.setNextRequest(null);\r",
							"                }\r",
							"                else if ( (number_of_user_changes_in_the_last_update === this_team.users_chunk_size) && (previouserrors ===0 ) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.users_chunk_size;\r",
							"                    if (pm.response.responseTime>270000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.6);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime>210000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 0.8);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 2);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<120000)\r",
							"                    {\r",
							"                        newchuncksize= Math.round(newchuncksize * 1.75);\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 2 mins. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.users_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                }\r",
							"                else\r",
							"                {\r",
							"                    pm.execution.setNextRequest(pm.info.requestName); \r",
							"                };\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                // our last update was for adding or removing roles, so we need to change the chunk size accordingly \r",
							"                // however we may only remove roles before adding them, so we need to check the chunk was 'full'\r",
							"                if ( (number_of_roles_changes_in_the_last_update === this_team.roles_chunk_size) && (previouserrors === 0) )\r",
							"                {\r",
							"                    let newchuncksize = this_team.roles_chunk_size;\r",
							"                    if ( (pm.response.responseTime>270000)  && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 4 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if ( (pm.response.responseTime>210000) && ( newchuncksize>1) )\r",
							"                    {\r",
							"                        newchuncksize --;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was over 3 mins 30 sec. Reducing chuck size to keep under 5 mins. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<20000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 20 secs. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<60000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min. Increasing chunk size to improve throughput. Chunk size now '+newchuncksize);\r",
							"                    }\r",
							"                    else if (pm.response.responseTime<80000)\r",
							"                    {\r",
							"                        newchuncksize ++;\r",
							"                        console.log(pm.info.requestName+' '+pm.info.eventName+': Last PUT was under 1 min 30 secs. Increasing chuck size to improve throughput. Chunk size now '+newchuncksize);            \r",
							"                    };\r",
							"                    //pm.environment.set(\"chunksize\",newchuncksize);\r",
							"                    if (newchuncksize<1) {newchuncksize=1};\r",
							"                    this_team.roles_chunk_size=newchuncksize;\r",
							"                    pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"                };\r",
							"                pm.execution.setNextRequest(pm.info.requestName); \r",
							"            };\r",
							"        }\r",
							"        else // the current team has been processed\r",
							"        {\r",
							"            console.info(pm.info.requestName+' '+pm.info.eventName+': Team '+this_team.teamname+' update complete it has '+readbody.members.length+' users and is a member of '+readbody.roles.length+' roles');\r",
							"            // so we should now remove the team from the teams array\r",
							"            array_of_teams.splice(this_team_index,1);\r",
							"            pm.variables.set(\"array_of_teams\",array_of_teams);\r",
							"            const teams_to_update = array_of_teams.length;\r",
							"            if ( teams_to_update > 0 )\r",
							"            {\r",
							"                console.log(pm.info.requestName+' '+pm.info.eventName+': Updating team '+array_of_teams[0].teamname);\r",
							"                pm.variables.set(\"targetteam\", array_of_teams[0].teamname);\r",
							"                pm.execution.setNextRequest(pm.info.requestName);\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                //console.log(pm.info.requestName+' '+pm.info.eventName+': All teams updated');\r",
							"                pm.execution.setNextRequest(null);\r",
							"            };\r",
							"\r",
							"        };  // end waiting to be added/removed\r",
							"\r",
							"        \r",
							"    }  // end reponse is 200\r",
							"else // response code is unexpected\r",
							"   {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ;\r",
							"   }  // end if else\r",
							";"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "PUT",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],\r\n    \"id\": \"{{targetteam}}\",\r\n    \"displayName\": \"{{displayname}}\",\r\n    \"meta\": {{meta}},\r\n    \"members\": {{members}},\r\n    \"roles\": {{roles}}\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups/{{file_target_team}}",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups",
						"{{file_target_team}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE team",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating team '+pm.variables.get(\"targetteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403])\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new access token');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");        \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"        break;\r",
							"    } // end case 401\r",
							"\r",
							"    case 403:\r",
							"    {\r",
							"        // We are not authorised, although we have a valid access token and a valid csrf-token!\r",
							"        // We need to issue a GET call to finalise our authorisation. \r",
							"        // It is unlikely we'll get a 403 on this call, but it is possible if the session timed-out between the previous GET and this call, unlikely but possible\r",
							"        // We shall need to get a new access token, new csrf-token and request a GET to finialise the authorisation required on this non-GET calll\r",
							"        // The 'recovery' variable is set to a GET call, when that GET call is issued, the session be fully authorised.\r",
							"        // 'NeedGetToBeAuthorised' is set to true so any post-processing in the GET call will be skipped and we'll come back to his call, when a re-attempt of the call will be made\r",
							"        // because 'ContinuousErrors' will be over 0.  \r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\");\r",
							"        break;\r",
							"    }  //end case 403    \r",
							"\r",
							"    case 201: \r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // the team was created ok, so we can go to re-read the team.\r",
							"        pm.execution.setNextRequest('READ target team');\r",
							"        break;\r",
							"    }  // end case 201\r",
							"\r",
							"    case 400:  // shares the same logic as 409\r",
							"    case 409:\r",
							"    {\r",
							"        // although we obtained an unexpected result, this is handled so we shall set the errors to 0.\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team. Teams cannot be created when the team or the team folder already exists. Team folder names are CaSe sensitive, as are team names when reading a team, but unlike team names when creating a team! This means reading a team (which is case sensitive) may not find a team, but when trying to create a team of the same name (which isn\\'t case sensitive), the team creation fails! Aborting this team.  Response: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";\r",
							"}; // end switch pm.response.code"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n  \"schemas\": [\r\n    \"urn:ietf:params:scim:schemas:core:2.0:Group\"\r\n  ],\r\n  \"id\": \"{{targetteam}}\",\r\n  \"displayName\": \"{{targetteam}} with Team Folder\"\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim/Groups",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "CREATE team without folder",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Creating team '+pm.variables.get(\"targetteam\") );\r",
							"pm.variables.set(\"recovery\",pm.info.requestName);"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"CREATE team\", function ()\r",
							"    {\r",
							"        pm.expect(pm.response.code).to.be.oneOf([201,401,403,429])\r",
							"    }\r",
							");\r",
							"\r",
							"switch (pm.response.code)\r",
							"{\r",
							"    case 401:\r",
							"    case 403:\r",
							"    {\r",
							"        // we are not authorised, so our accesstoken or the csrf-token must be invalid. We shall get new ones of each!\r",
							"        // A 401 error might be because something is wrong with the call or even the SAP SAC SCIM API, so we need to start counting errors,\r",
							"        // so we don't end up in an endless loop.\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': Fetching a new accesstoken');\r",
							"        pm.execution.setNextRequest(\"GET accesstoken\"); \r",
							"        // as this is non-GET call, we shall set NeedGetToBeAuthorised to true and set the 'recovery' to the GET call, so the new session is authorised, once we've obtained a new accesstoken\r",
							"        pm.variables.set(\"NeedGetToBeAuthorised\",true);\r",
							"        pm.variables.set(\"recovery\",\"READ target team\");\r",
							"        break;\r",
							"    } // end case 401 \r",
							"\r",
							"    case 429:\r",
							"    // in the event SAP Analytics Cloud is receiving too many requests, a HTTP response 429 will be issued.\r",
							"    // in such a case, we shall wait for the 'Retry-After' value and simply re-attempt the same request.\r",
							"    {\r",
							"        const retryafter=(pm.response.headers.get('Retry-After')!=undefined) ? parseInt(pm.response.headers.get('Retry-After')) : 5000;\r",
							"        console.log(pm.info.requestName+' '+pm.info.eventName+': SAP Analytics Cloud is receiving too many requests. Retrying in '+retryafter+'ms');\r",
							"        setTimeout(()=> {},retryafter);\r",
							"        pm.execution.setNextRequest(pm.info.requestName);\r",
							"        break;\r",
							"    }  // end case 429\r",
							"\r",
							"    case 201: \r",
							"    {\r",
							"        // Need to set the ContinuousErrors count to 0 as we got a valid response from the API\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"\r",
							"        // the team was created ok, so we can go to re-read the team.\r",
							"        pm.execution.setNextRequest('READ target team');\r",
							"        break;\r",
							"    }  // end case 201\r",
							"\r",
							"    case 400: // same as 409\r",
							"    case 409:\r",
							"    {\r",
							"        // although we obtained an unexpected result, this is handled so we shall set the errors to 0.\r",
							"        pm.variables.set(\"ContinuousErrors\",0);\r",
							"        try {\r",
							"            if ( JSON.parse(pm.response.text()).scimType ==='uniqueness')\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create the team '+pm.variables.get(\"targetteam\")+' using the scim2 endpoint /api/v1/scim2/Groups. This is probably because a team with the same name already exists. Teams created with the scim2 endpoint /api/v1/scim2/Groups will not be readable or updatable using the scim1 /api/v1/scim/Groups/'+pm.variables.get(\"targetteam\")+' endpoint until the System Administration setting \\'Ignore Content Namespace for Teams\\' has been turned ON. Please turn this setting to ON now, and re-run this sample. If this setting is already enabled, but the scim1 /api/v1/scim/Groups/'+pm.variables.get(\"targetteam\")+' endpoint is unable to read the team (a GET request returns a 404), please contact SAP Support. Aborting this team.  Response: '+ pm.response.text());\r",
							"            }\r",
							"            else\r",
							"            {\r",
							"                console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team.  Aborting this team.  Response: '+ pm.response.text());\r",
							"            }\r",
							"        }\r",
							"\t\tcatch (error)\r",
							"        { \r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Unable to create team.  Aborting this team.  Response: '+ pm.response.text());\r",
							"        }\r",
							"        pm.execution.setNextRequest(null);\r",
							"\r",
							"        break;\r",
							"    }\r",
							"    default: // response code is unexpected\r",
							"    {\r",
							"       // we got an unexpected response from the SAC API\r",
							"        let errors=pm.variables.get(\"ContinuousErrors\");\r",
							"        if (!errors) { errors=0 };  // in case errors has not yet been set we need to set it to 0\r",
							"        errors++;\r",
							"        pm.variables.set(\"ContinuousErrors\",errors);\r",
							"        const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors should be at least 2 to allow for recovery of invalid access token and csrf tokens\r",
							"                            // it means a setting of 1 would mean any call following would not be allowed to re-attempt the call.\r",
							"                            // a setting of 3 is recommended to allow at least 1 re-attempted call and any subsequent call also failing for a potentially different reason\r",
							"        if (errors >= maxerrors)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting. Response: '+ pm.response.text());\r",
							"            pm.variables.set(\"ContinuousErrors\",0); \r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else if (errors >= 2)\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Unexpected error. Response: '+ pm.response.text());\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        };\r",
							"   }\r",
							";\r",
							"}; // end switch pm.response.code"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{accesstoken}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [
					{
						"key": "x-csrf-token",
						"value": "{{x-csrf-token}}",
						"type": "text"
					},
					{
						"key": "x-sap-sac-custom-auth",
						"value": "true",
						"type": "text"
					},
					{
						"key": "Content-Type",
						"value": "application/json",
						"name": "Content-Type",
						"type": "text"
					},
					{
						"key": "x-sap-sac-create-team-folder",
						"value": "false",
						"type": "text"
					}
				],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"schemas\": [\r\n        \"urn:ietf:params:scim:schemas:core:2.0:Group\",\r\n        \"urn:sap:params:scim:schemas:extension:sac:2.0:group-custom-parameters\"\r\n    ],\r\n    \"displayName\": \"{{targetteam}}\",\r\n    \"members\": [],\r\n    \"urn:sap:params:scim:schemas:extension:sac:2.0:group-custom-parameters\": {\r\n        \"description\": \"{{targetteam}}\"\r\n    }\r\n}"
				},
				"url": {
					"raw": "https://{{SACserviceFQDN}}/api/v1/scim2/Groups",
					"protocol": "https",
					"host": [
						"{{SACserviceFQDN}}"
					],
					"path": [
						"api",
						"v1",
						"scim2",
						"Groups"
					]
				}
			},
			"response": []
		},
		{
			"name": "GET accesstoken",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"console.log(pm.info.requestName+' '+pm.info.eventName+': Getting access token');\r",
							"const SAC_platform = pm.variables.get(\"SACplatform\");\r",
							"if (SAC_platform==='NEO')\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth2/api/v1/\");\r",
							"}\r",
							"else  // we are on a Cloud Foundary Platform\r",
							"{\r",
							"    pm.variables.set(\"oauthpath\",\"/oauth/\");\r",
							"};"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"GET accesstoken\", function()\r",
							"    {\r",
							"    pm.expect(pm.response.code).to.equal(200)\r",
							"    }\r",
							");\r",
							"\r",
							"if (pm.response.code === 200)\r",
							"    {\r",
							"        const jsonData = JSON.parse(pm.response.text());\r",
							"        pm.environment.set(\"accesstoken\", jsonData.access_token);  // setting the accesstoken so its re-used for all subsequent requests\r",
							"        pm.environment.set(\"x-csrf-token\", \"fetch\");               // we will need to request a new csrf-token as we have a new session\r",
							"        pm.execution.setNextRequest(pm.variables.get(\"recovery\"));      // we will now return to the request that sent us here in the first place\r",
							"    }\r",
							"else if (pm.response.code === 401)\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Invalid username or password: '+ pm.response.text());\r",
							"        pm.execution.setNextRequest(null);\r",
							"    }\r",
							"else\r",
							"    {\r",
							"        console.error(pm.info.requestName+' '+pm.info.eventName+': Unhandled error. Response Body: '+ pm.response.text());\r",
							"        if (pm.variables.get(\"recovery\") === pm.info.requestName)\r",
							"        {\r",
							"            console.error(pm.info.requestName+' '+pm.info.eventName+': Already attempted to get a valid request. Will now quit');\r",
							"            pm.execution.setNextRequest(null);\r",
							"        }\r",
							"        else\r",
							"        {\r",
							"            console.warn(pm.info.requestName+' '+pm.info.eventName+': Will make one more attempt to get a new accesstoken');\r",
							"            pm.variables.set(\"recovery\",pm.info.requestName);\r",
							"            pm.execution.setNextRequest(pm.info.requestName);\r",
							"        }\r",
							"        ; //end if \r",
							"    }\r",
							"; // end if\r",
							"\r",
							"const errors=pm.variables.get(\"ContinuousErrors\");\r",
							"const maxerrors=parseInt( (pm.environment.get(\"abort_after_continous_errors_reaches\")!=undefined) ? parseInt(pm.environment.get(\"abort_after_continous_errors_reaches\")) : 3 );  // maxerrors needs to be at least 2, otherwise valid workflows may be able to correctly recover from an invalid access tokens or invalid csrf-tokens\r",
							"\r",
							"if (errors >= maxerrors)\r",
							"{\r",
							"    console.error(pm.info.requestName+' '+pm.info.eventName+': Too many continuous errors. Aborting');\r",
							"    pm.variables.set(\"ContinuousErrors\",0); \r",
							"    pm.execution.setNextRequest(null);\r",
							"}\r",
							"else if (errors >= 2)\r",
							"{\r",
							"    console.info(pm.info.requestName+' '+pm.info.eventName+': Continuous errors detected');\r",
							"    // a valid accesstoken may have been obtained, but the request where it came from could have failed, hence the need to trap for a continous loop of errors here\r",
							"};"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "basic",
					"basic": [
						{
							"key": "username",
							"value": "{{Username}}",
							"type": "string"
						},
						{
							"key": "password",
							"value": "{{Password}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"url": {
					"raw": "https://{{SACtokenFQDN}}{{oauthpath}}token?grant_type=client_credentials",
					"protocol": "https",
					"host": [
						"{{SACtokenFQDN}}{{oauthpath}}token"
					],
					"query": [
						{
							"key": "grant_type",
							"value": "client_credentials"
						}
					]
				}
			},
			"response": []
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "initial_read_index_size",
			"value": "200"
		}
	]
}